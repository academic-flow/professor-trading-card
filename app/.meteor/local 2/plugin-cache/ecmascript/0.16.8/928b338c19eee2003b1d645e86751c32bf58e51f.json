{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/alanning:roles/roles/roles_common_async.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/alanning:roles/roles/roles_common_async.js","filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/alanning:roles/roles/roles_common_async.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/phatca/Documents/GitHub/professor-trading-card/app","root":"/Users/phatca/Documents/GitHub/professor-trading-card/app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/alanning:roles/roles/roles_common_async.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/alanning:roles/roles/roles_common_async.js"}},"code":"!function (module1) {\n  let Meteor;\n  module1.link(\"meteor/meteor\", {\n    Meteor(v) {\n      Meteor = v;\n    }\n  }, 0);\n  let Mongo;\n  module1.link(\"meteor/mongo\", {\n    Mongo(v) {\n      Mongo = v;\n    }\n  }, 1);\n  /**\n   * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n   *\n   * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n   *  - `_id`: role name\n   *  - `children`: list of subdocuments:\n   *    - `_id`\n   *\n   * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n   *\n   * Roles can have multiple parents and can be children (subroles) of multiple roles.\n   *\n   * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n   *\n   * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n   * It's documents consist of\n   *  - `_id`: Internal MongoDB id\n   *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n   *  - `user`: A user object, usually only contains the `_id` property\n   *  - `scope`: scope name\n   *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n   *\n   * @module Roles\n   */\n  if (!Meteor.roles) {\n    Meteor.roles = new Mongo.Collection('roles');\n  }\n  if (!Meteor.roleAssignment) {\n    Meteor.roleAssignment = new Mongo.Collection('role-assignment');\n  }\n\n  /**\n   * @class Roles\n   */\n  if (typeof Roles === 'undefined') {\n    Roles = {}; // eslint-disable-line no-global-assign\n  }\n  let getGroupsForUserDeprecationWarning = false;\n\n  /**\n   * Helper, resolves async some\n   * @param {*} arr\n   * @param {*} predicate\n   * @returns {Promise<Boolean>}\n   */\n  const asyncSome = (arr, predicate) => Promise.asyncApply(() => {\n    for (const e of arr) {\n      if (Promise.await(predicate(e))) return true;\n    }\n    return false;\n  });\n  Object.assign(Roles, {\n    /**\n     * Used as a global group (now scope) name. Not used anymore.\n     *\n     * @property GLOBAL_GROUP\n     * @static\n     * @deprecated\n     */\n    GLOBAL_GROUP: null,\n    /**\n     * Create a new role.\n     *\n     * @method createRoleAsync\n     * @param {String} roleName Name of role.\n     * @param {Object} [options] Options:\n     *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n     * @return {Promise<String>} ID of the new role or null.\n     * @static\n     */\n    createRoleAsync: function (roleName, options) {\n      return Promise.asyncApply(() => {\n        Roles._checkRoleName(roleName);\n        options = Object.assign({\n          unlessExists: false\n        }, options);\n        let insertedId = null;\n        const existingRole = Promise.await(Meteor.roles.findOneAsync({\n          _id: roleName\n        }));\n        if (existingRole) {\n          Promise.await(Meteor.roles.updateAsync({\n            _id: roleName\n          }, {\n            $setOnInsert: {\n              children: []\n            }\n          }));\n          return null;\n        } else {\n          insertedId = Promise.await(Meteor.roles.insertAsync({\n            _id: roleName,\n            children: []\n          }));\n        }\n        if (!insertedId) {\n          if (options.unlessExists) return null;\n          throw new Error(\"Role '\" + roleName + \"' already exists.\");\n        }\n        return insertedId;\n      });\n    },\n    /**\n     * Delete an existing role.\n     *\n     * If the role is set for any user, it is automatically unset.\n     *\n     * @method deleteRoleAsync\n     * @param {String} roleName Name of role.\n     * @returns {Promise}\n     * @static\n     */\n    deleteRoleAsync: function (roleName) {\n      return Promise.asyncApply(() => {\n        let roles;\n        let inheritedRoles;\n        Roles._checkRoleName(roleName);\n\n        // Remove all assignments\n        Promise.await(Meteor.roleAssignment.removeAsync({\n          'role._id': roleName\n        }));\n        do {\n          // For all roles who have it as a dependency ...\n          roles = Roles._getParentRoleNames(Promise.await(Meteor.roles.findOneAsync({\n            _id: roleName\n          })));\n          for (const r of Promise.await(Meteor.roles.find({\n            _id: {\n              $in: roles\n            }\n          }).fetchAsync())) {\n            Promise.await(Meteor.roles.updateAsync({\n              _id: r._id\n            }, {\n              $pull: {\n                children: {\n                  _id: roleName\n                }\n              }\n            }));\n            inheritedRoles = Promise.await(Roles._getInheritedRoleNamesAsync(Promise.await(Meteor.roles.findOneAsync({\n              _id: r._id\n            }))));\n            Promise.await(Meteor.roleAssignment.updateAsync({\n              'role._id': r._id\n            }, {\n              $set: {\n                inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({\n                  _id: r2\n                }))\n              }\n            }, {\n              multi: true\n            }));\n          }\n        } while (roles.length > 0);\n\n        // And finally remove the role itself\n        Promise.await(Meteor.roles.removeAsync({\n          _id: roleName\n        }));\n      });\n    },\n    /**\n     * Rename an existing role.\n     *\n     * @method renameRoleAsync\n     * @param {String} oldName Old name of a role.\n     * @param {String} newName New name of a role.\n     * @returns {Promise}\n     * @static\n     */\n    renameRoleAsync: function (oldName, newName) {\n      return Promise.asyncApply(() => {\n        let count;\n        Roles._checkRoleName(oldName);\n        Roles._checkRoleName(newName);\n        if (oldName === newName) return;\n        const role = Promise.await(Meteor.roles.findOneAsync({\n          _id: oldName\n        }));\n        if (!role) {\n          throw new Error(\"Role '\" + oldName + \"' does not exist.\");\n        }\n        role._id = newName;\n        Promise.await(Meteor.roles.insertAsync(role));\n        do {\n          count = Promise.await(Meteor.roleAssignment.updateAsync({\n            'role._id': oldName\n          }, {\n            $set: {\n              'role._id': newName\n            }\n          }, {\n            multi: true\n          }));\n        } while (count > 0);\n        do {\n          count = Promise.await(Meteor.roleAssignment.updateAsync({\n            'inheritedRoles._id': oldName\n          }, {\n            $set: {\n              'inheritedRoles.$._id': newName\n            }\n          }, {\n            multi: true\n          }));\n        } while (count > 0);\n        do {\n          count = Promise.await(Meteor.roles.updateAsync({\n            'children._id': oldName\n          }, {\n            $set: {\n              'children.$._id': newName\n            }\n          }, {\n            multi: true\n          }));\n        } while (count > 0);\n        Promise.await(Meteor.roles.removeAsync({\n          _id: oldName\n        }));\n      });\n    },\n    /**\n     * Add role parent to roles.\n     *\n     * Previous parents are kept (role can have multiple parents). For users which have the\n     * parent role set, new subroles are added automatically.\n     *\n     * @method addRolesToParentAsync\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @static\n     */\n    addRolesToParentAsync: function (rolesNames, parentName) {\n      return Promise.asyncApply(() => {\n        // ensure arrays\n        if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n        for (const roleName of rolesNames) {\n          Promise.await(Roles._addRoleToParentAsync(roleName, parentName));\n        }\n      });\n    },\n    /**\n     * @method _addRoleToParentAsync\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _addRoleToParentAsync: function (roleName, parentName) {\n      return Promise.asyncApply(() => {\n        Roles._checkRoleName(roleName);\n        Roles._checkRoleName(parentName);\n\n        // query to get role's children\n        const role = Promise.await(Meteor.roles.findOneAsync({\n          _id: roleName\n        }));\n        if (!role) {\n          throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n        }\n\n        // detect cycles\n        if (Promise.await(Roles._getInheritedRoleNamesAsync(role)).includes(parentName)) {\n          throw new Error(\"Roles '\" + roleName + \"' and '\" + parentName + \"' would form a cycle.\");\n        }\n        const count = Promise.await(Meteor.roles.updateAsync({\n          _id: parentName,\n          'children._id': {\n            $ne: role._id\n          }\n        }, {\n          $push: {\n            children: {\n              _id: role._id\n            }\n          }\n        }));\n\n        // if there was no change, parent role might not exist, or role is\n        // already a sub-role; in any case we do not have anything more to do\n        if (!count) return;\n        Promise.await(Meteor.roleAssignment.updateAsync({\n          'inheritedRoles._id': parentName\n        }, {\n          $push: {\n            inheritedRoles: {\n              $each: [role._id, ...Promise.await(Roles._getInheritedRoleNamesAsync(role))].map(r => ({\n                _id: r\n              }))\n            }\n          }\n        }, {\n          multi: true\n        }));\n      });\n    },\n    /**\n     * Remove role parent from roles.\n     *\n     * Other parents are kept (role can have multiple parents). For users which have the\n     * parent role set, removed subrole is removed automatically.\n     *\n     * @method removeRolesFromParentAsync\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @static\n     */\n    removeRolesFromParentAsync: function (rolesNames, parentName) {\n      return Promise.asyncApply(() => {\n        // ensure arrays\n        if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n        for (const roleName of rolesNames) {\n          Promise.await(Roles._removeRoleFromParentAsync(roleName, parentName));\n        }\n      });\n    },\n    /**\n     * @method _removeRoleFromParentAsync\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _removeRoleFromParentAsync: function (roleName, parentName) {\n      return Promise.asyncApply(() => {\n        Roles._checkRoleName(roleName);\n        Roles._checkRoleName(parentName);\n\n        // check for role existence\n        // this would not really be needed, but we are trying to match addRolesToParent\n        const role = Promise.await(Meteor.roles.findOneAsync({\n          _id: roleName\n        }, {\n          fields: {\n            _id: 1\n          }\n        }));\n        if (!role) {\n          throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n        }\n        const count = Promise.await(Meteor.roles.updateAsync({\n          _id: parentName\n        }, {\n          $pull: {\n            children: {\n              _id: role._id\n            }\n          }\n        }));\n\n        // if there was no change, parent role might not exist, or role was\n        // already not a subrole; in any case we do not have anything more to do\n        if (!count) return;\n\n        // For all roles who have had it as a dependency ...\n        const roles = [...Promise.await(Roles._getParentRoleNamesAsync(Promise.await(Meteor.roles.findOneAsync({\n          _id: parentName\n        })))), parentName];\n        for (const r of Promise.await(Meteor.roles.find({\n          _id: {\n            $in: roles\n          }\n        }).fetchAsync())) {\n          const inheritedRoles = Promise.await(Roles._getInheritedRoleNamesAsync(Promise.await(Meteor.roles.findOneAsync({\n            _id: r._id\n          }))));\n          Promise.await(Meteor.roleAssignment.updateAsync({\n            'role._id': r._id,\n            'inheritedRoles._id': role._id\n          }, {\n            $set: {\n              inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({\n                _id: r2\n              }))\n            }\n          }, {\n            multi: true\n          }));\n        }\n      });\n    },\n    /**\n     * Add users to roles.\n     *\n     * Adds roles to existing roles for each user.\n     *\n     * @example\n     *     Roles.addUsersToRolesAsync(userId, 'admin')\n     *     Roles.addUsersToRolesAsync(userId, ['view-secrets'], 'example.com')\n     *     Roles.addUsersToRolesAsync([user1, user2], ['user','editor'])\n     *     Roles.addUsersToRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method addUsersToRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    addUsersToRolesAsync: function (users, roles, options) {\n      return Promise.asyncApply(() => {\n        let id;\n        if (!users) throw new Error(\"Missing 'users' param.\");\n        if (!roles) throw new Error(\"Missing 'roles' param.\");\n        options = Roles._normalizeOptions(options);\n\n        // ensure arrays\n        if (!Array.isArray(users)) users = [users];\n        if (!Array.isArray(roles)) roles = [roles];\n        Roles._checkScopeName(options.scope);\n        options = Object.assign({\n          ifExists: false\n        }, options);\n        for (const user of users) {\n          if (typeof user === 'object') {\n            id = user._id;\n          } else {\n            id = user;\n          }\n          for (const role of roles) {\n            Promise.await(Roles._addUserToRoleAsync(id, role, options));\n          }\n        }\n      });\n    },\n    /**\n     * Set users' roles.\n     *\n     * Replaces all existing roles with a new set of roles.\n     *\n     * @example\n     *     await Roles.setUserRolesAsync(userId, 'admin')\n     *     await Roles.setUserRolesAsync(userId, ['view-secrets'], 'example.com')\n     *     await Roles.setUserRolesAsync([user1, user2], ['user','editor'])\n     *     await Roles.setUserRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method setUserRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    setUserRolesAsync: function (users, roles, options) {\n      return Promise.asyncApply(() => {\n        let id;\n        if (!users) throw new Error(\"Missing 'users' param.\");\n        if (!roles) throw new Error(\"Missing 'roles' param.\");\n        options = Roles._normalizeOptions(options);\n\n        // ensure arrays\n        if (!Array.isArray(users)) users = [users];\n        if (!Array.isArray(roles)) roles = [roles];\n        Roles._checkScopeName(options.scope);\n        options = Object.assign({\n          ifExists: false,\n          anyScope: false\n        }, options);\n        for (const user of users) {\n          if (typeof user === 'object') {\n            id = user._id;\n          } else {\n            id = user;\n          }\n          // we first clear all roles for the user\n          const selector = {\n            'user._id': id\n          };\n          if (!options.anyScope) {\n            selector.scope = options.scope;\n          }\n          Promise.await(Meteor.roleAssignment.removeAsync(selector));\n\n          // and then add all\n          for (const role of roles) {\n            Promise.await(Roles._addUserToRole(id, role, options));\n          }\n        }\n      });\n    },\n    /**\n     * Add one user to one role.\n     *\n     * @method _addUserToRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _addUserToRoleAsync: function (userId, roleName, options) {\n      return Promise.asyncApply(() => {\n        Roles._checkRoleName(roleName);\n        Roles._checkScopeName(options.scope);\n        if (!userId) {\n          return;\n        }\n        const role = Promise.await(Meteor.roles.findOneAsync({\n          _id: roleName\n        }, {\n          fields: {\n            children: 1\n          }\n        }));\n        if (!role) {\n          if (options.ifExists) {\n            return [];\n          } else {\n            throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n          }\n        }\n\n        // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n        // TODO revisit this\n        /* const res = await Meteor.roleAssignment.upsertAsync(\n          {\n            \"user._id\": userId,\n            \"role._id\": roleName,\n            scope: options.scope,\n          },\n          {\n            $setOnInsert: {\n              user: { _id: userId },\n              role: { _id: roleName },\n              scope: options.scope,\n            },\n          }\n        ); */\n        const existingAssignment = Promise.await(Meteor.roleAssignment.findOneAsync({\n          'user._id': userId,\n          'role._id': roleName,\n          scope: options.scope\n        }));\n        let insertedId;\n        let res;\n        if (existingAssignment) {\n          Promise.await(Meteor.roleAssignment.updateAsync(existingAssignment._id, {\n            $set: {\n              user: {\n                _id: userId\n              },\n              role: {\n                _id: roleName\n              },\n              scope: options.scope\n            }\n          }));\n          res = Promise.await(Meteor.roleAssignment.findOneAsync(existingAssignment._id));\n        } else {\n          insertedId = Promise.await(Meteor.roleAssignment.insertAsync({\n            user: {\n              _id: userId\n            },\n            role: {\n              _id: roleName\n            },\n            scope: options.scope\n          }));\n        }\n        if (insertedId) {\n          Promise.await(Meteor.roleAssignment.updateAsync({\n            _id: insertedId\n          }, {\n            $set: {\n              inheritedRoles: [roleName, ...Promise.await(Roles._getInheritedRoleNamesAsync(role))].map(r => ({\n                _id: r\n              }))\n            }\n          }));\n          res = Promise.await(Meteor.roleAssignment.findOneAsync({\n            _id: insertedId\n          }));\n        }\n        res.insertedId = insertedId; // For backward compatibility\n\n        return res;\n      });\n    },\n    /**\n     * Returns an array of role names the given role name is a child of.\n     *\n     * @example\n     *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getParentRoleNames\n     * @param {object} role The role object\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _getParentRoleNamesAsync: function (role) {\n      return Promise.asyncApply(() => {\n        if (!role) {\n          return [];\n        }\n        const parentRoles = new Set([role._id]);\n        for (const roleName of parentRoles) {\n          for (const parentRole of Promise.await(Meteor.roles.find({\n            'children._id': roleName\n          }).fetchAsync())) {\n            parentRoles.add(parentRole._id);\n          }\n        }\n        parentRoles.delete(role._id);\n        return [...parentRoles];\n      });\n    },\n    /**\n     * Returns an array of role names the given role name is a parent of.\n     *\n     * @example\n     *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getInheritedRoleNames\n     * @param {object} role The role object\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _getInheritedRoleNamesAsync: function (role) {\n      return Promise.asyncApply(() => {\n        const inheritedRoles = new Set();\n        const nestedRoles = new Set([role]);\n        for (const r of nestedRoles) {\n          const roles = Promise.await(Meteor.roles.find({\n            _id: {\n              $in: r.children.map(r => r._id)\n            }\n          }, {\n            fields: {\n              children: 1\n            }\n          }).fetchAsync());\n          for (const r2 of roles) {\n            inheritedRoles.add(r2._id);\n            nestedRoles.add(r2);\n          }\n        }\n        return [...inheritedRoles];\n      });\n    },\n    /**\n     * Remove users from assigned roles.\n     *\n     * @example\n     *     await Roles.removeUsersFromRolesAsync(userId, 'admin')\n     *     await Roles.removeUsersFromRolesAsync([userId, user2], ['editor'])\n     *     await Roles.removeUsersFromRolesAsync(userId, ['user'], 'group1')\n     *\n     * @method removeUsersFromRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    removeUsersFromRolesAsync: function (users, roles, options) {\n      return Promise.asyncApply(() => {\n        if (!users) throw new Error(\"Missing 'users' param.\");\n        if (!roles) throw new Error(\"Missing 'roles' param.\");\n        options = Roles._normalizeOptions(options);\n\n        // ensure arrays\n        if (!Array.isArray(users)) users = [users];\n        if (!Array.isArray(roles)) roles = [roles];\n        Roles._checkScopeName(options.scope);\n        for (const user of users) {\n          if (!user) return;\n          for (const role of roles) {\n            let id;\n            if (typeof user === 'object') {\n              id = user._id;\n            } else {\n              id = user;\n            }\n            Promise.await(Roles._removeUserFromRoleAsync(id, role, options));\n          }\n        }\n      });\n    },\n    /**\n     * Remove one user from one role.\n     *\n     * @method _removeUserFromRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _removeUserFromRoleAsync: function (userId, roleName, options) {\n      return Promise.asyncApply(() => {\n        Roles._checkRoleName(roleName);\n        Roles._checkScopeName(options.scope);\n        if (!userId) return;\n        const selector = {\n          'user._id': userId,\n          'role._id': roleName\n        };\n        if (!options.anyScope) {\n          selector.scope = options.scope;\n        }\n        Promise.await(Meteor.roleAssignment.removeAsync(selector));\n      });\n    },\n    /**\n     * Check if user has specified roles.\n     *\n     * @example\n     *     // global roles\n     *     await Roles.userIsInRoleAsync(user, 'admin')\n     *     await Roles.userIsInRoleAsync(user, ['admin','editor'])\n     *     await Roles.userIsInRoleAsync(userId, 'admin')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'])\n     *\n     *     // scope roles (global roles are still checked)\n     *     await Roles.userIsInRoleAsync(user, 'admin', 'group1')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], 'group1')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], {scope: 'group1'})\n     *\n     * @method userIsInRoleAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n     *                             will return `true` if user is in _any_ role.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope; if supplied, limits check to just that scope\n     *     the user's global roles will always be checked whether scope is specified or not\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Promise<Boolean>} `true` if user is in _any_ of the target roles\n     * @static\n     */\n    userIsInRoleAsync: function (user, roles, options) {\n      return Promise.asyncApply(() => {\n        let id;\n        options = Roles._normalizeOptions(options);\n\n        // ensure array to simplify code\n        if (!Array.isArray(roles)) roles = [roles];\n        roles = roles.filter(r => r != null);\n        if (!roles.length) return false;\n        Roles._checkScopeName(options.scope);\n        options = Object.assign({\n          anyScope: false\n        }, options);\n        if (user && typeof user === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        if (!id) return false;\n        if (typeof id !== 'string') return false;\n        const selector = {\n          'user._id': id\n        };\n        if (!options.anyScope) {\n          selector.scope = {\n            $in: [options.scope, null]\n          };\n        }\n        const res = Promise.await(asyncSome(roles, roleName => Promise.asyncApply(() => {\n          selector['inheritedRoles._id'] = roleName;\n          const out = Promise.await(Meteor.roleAssignment.find(selector, {\n            limit: 1\n          }).countAsync()) > 0;\n          return out;\n        })));\n        return res;\n      });\n    },\n    /**\n     * Retrieve user's roles.\n     *\n     * @method getRolesForUserAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n     *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n     *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n     *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n     *     result strongly dependent on the internal data structure of this plugin.\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Promise<Array>} Array of user's roles, unsorted.\n     * @static\n     */\n    getRolesForUserAsync: function (user, options) {\n      return Promise.asyncApply(() => {\n        let id;\n        options = Roles._normalizeOptions(options);\n        Roles._checkScopeName(options.scope);\n        options = Object.assign({\n          fullObjects: false,\n          onlyAssigned: false,\n          anyScope: false,\n          onlyScoped: false\n        }, options);\n        if (user && typeof user === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        if (!id) return [];\n        const selector = {\n          'user._id': id\n        };\n        const filter = {\n          fields: {\n            'inheritedRoles._id': 1\n          }\n        };\n        if (!options.anyScope) {\n          selector.scope = {\n            $in: [options.scope]\n          };\n          if (!options.onlyScoped) {\n            selector.scope.$in.push(null);\n          }\n        }\n        if (options.onlyAssigned) {\n          delete filter.fields['inheritedRoles._id'];\n          filter.fields['role._id'] = 1;\n        }\n        if (options.fullObjects) {\n          delete filter.fields;\n        }\n        const roles = Promise.await(Meteor.roleAssignment.find(selector, filter).fetchAsync());\n        if (options.fullObjects) {\n          return roles;\n        }\n        return [...new Set(roles.reduce((rev, current) => {\n          if (current.inheritedRoles) {\n            return rev.concat(current.inheritedRoles.map(r => r._id));\n          } else if (current.role) {\n            rev.push(current.role._id);\n          }\n          return rev;\n        }, []))];\n      });\n    },\n    /**\n     * Retrieve cursor of all existing roles.\n     *\n     * @method getAllRoles\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.roles.find(query, options)`.\n     * @return {Cursor} Cursor of existing roles.\n     * @static\n     */\n    getAllRoles: function (queryOptions) {\n      queryOptions = queryOptions || {\n        sort: {\n          _id: 1\n        }\n      };\n      return Meteor.roles.find({}, queryOptions);\n    },\n    /**\n     * Retrieve all users who are in target role.\n     *\n     * Options:\n     *\n     * @method getUsersInRoleAsync\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.users.find(query, options)`\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.users.find(query, options)`\n     * @return {Promise<Cursor>} Cursor of users in roles.\n     * @static\n     */\n    getUsersInRoleAsync: function (roles, options, queryOptions) {\n      return Promise.asyncApply(() => {\n        const ids = Promise.await(Roles.getUserAssignmentsForRole(roles, options).fetchAsync()).map(a => a.user._id);\n        return Meteor.users.find({\n          _id: {\n            $in: ids\n          }\n        }, options && options.queryOptions || queryOptions || {});\n      });\n    },\n    /**\n     * Retrieve all assignments of a user which are for the target role.\n     *\n     * Options:\n     *\n     * @method getUserAssignmentsForRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.roleAssignment.find(query, options)`\n      * Alternatively, it can be a scope name string.\n     * @return {Cursor} Cursor of user assignments for roles.\n     * @static\n     */\n    getUserAssignmentsForRole: function (roles, options) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        queryOptions: {}\n      }, options);\n      return Roles._getUsersInRoleCursor(roles, options, options.queryOptions);\n    },\n    /**\n     * @method _getUsersInRoleCursor\n     * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n     *                             returned which have at least one of the roles\n     *                             assigned but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [filter] Options which are passed directly\n     *                                through to `Meteor.roleAssignment.find(query, options)`\n     * @return {Object} Cursor to the assignment documents\n     * @private\n     * @static\n     */\n    _getUsersInRoleCursor: function (roles, options, filter) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n\n      // ensure array to simplify code\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      filter = Object.assign({\n        fields: {\n          'user._id': 1\n        }\n      }, filter);\n      const selector = {\n        'inheritedRoles._id': {\n          $in: roles\n        }\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n      return Meteor.roleAssignment.find(selector, filter);\n    },\n    /**\n     * Deprecated. Use `getScopesForUser` instead.\n     *\n     * @method getGroupsForUserAsync\n     * @returns {Promise<Array>}\n     * @static\n     * @deprecated\n     */\n    getGroupsForUserAsync: function () {\n      return Promise.asyncApply(() => {\n        if (!getGroupsForUserDeprecationWarning) {\n          getGroupsForUserDeprecationWarning = true;\n          console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.');\n        }\n        return Promise.await(Roles.getScopesForUser(...arguments));\n      });\n    },\n    /**\n     * Retrieve users scopes, if any.\n     *\n     * @method getScopesForUserAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} [roles] Name of roles to restrict scopes to.\n     *\n     * @return {Promise<Array>} Array of user's scopes, unsorted.\n     * @static\n     */\n    getScopesForUserAsync: function (user, roles) {\n      return Promise.asyncApply(() => {\n        let id;\n        if (roles && !Array.isArray(roles)) roles = [roles];\n        if (user && typeof user === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        if (!id) return [];\n        const selector = {\n          'user._id': id,\n          scope: {\n            $ne: null\n          }\n        };\n        if (roles) {\n          selector['inheritedRoles._id'] = {\n            $in: roles\n          };\n        }\n        const scopes = Promise.await(Meteor.roleAssignment.find(selector, {\n          fields: {\n            scope: 1\n          }\n        }).fetchAsync()).map(obi => obi.scope);\n        return [...new Set(scopes)];\n      });\n    },\n    /**\n     * Rename a scope.\n     *\n     * Roles assigned with a given scope are changed to be under the new scope.\n     *\n     * @method renameScopeAsync\n     * @param {String} oldName Old name of a scope.\n     * @param {String} newName New name of a scope.\n     * @returns {Promise}\n     * @static\n     */\n    renameScopeAsync: function (oldName, newName) {\n      return Promise.asyncApply(() => {\n        let count;\n        Roles._checkScopeName(oldName);\n        Roles._checkScopeName(newName);\n        if (oldName === newName) return;\n        do {\n          count = Promise.await(Meteor.roleAssignment.updateAsync({\n            scope: oldName\n          }, {\n            $set: {\n              scope: newName\n            }\n          }, {\n            multi: true\n          }));\n        } while (count > 0);\n      });\n    },\n    /**\n     * Remove a scope.\n     *\n     * Roles assigned with a given scope are removed.\n     *\n     * @method removeScopeAsync\n     * @param {String} name The name of a scope.\n     * @returns {Promise}\n     * @static\n     */\n    removeScopeAsync: function (name) {\n      return Promise.asyncApply(() => {\n        Roles._checkScopeName(name);\n        Promise.await(Meteor.roleAssignment.removeAsync({\n          scope: name\n        }));\n      });\n    },\n    /**\n     * Throw an exception if `roleName` is an invalid role name.\n     *\n     * @method _checkRoleName\n     * @param {String} roleName A role name to match against.\n     * @private\n     * @static\n     */\n    _checkRoleName: function (roleName) {\n      if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n        throw new Error(\"Invalid role name '\" + roleName + \"'.\");\n      }\n    },\n    /**\n     * Find out if a role is an ancestor of another role.\n     *\n     * WARNING: If you check this on the client, please make sure all roles are published.\n     *\n     * @method isParentOfAsync\n     * @param {String} parentRoleName The role you want to research.\n     * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n     * @returns {Promise}\n     * @static\n     */\n    isParentOfAsync: function (parentRoleName, childRoleName) {\n      return Promise.asyncApply(() => {\n        if (parentRoleName === childRoleName) {\n          return true;\n        }\n        if (parentRoleName == null || childRoleName == null) {\n          return false;\n        }\n        Roles._checkRoleName(parentRoleName);\n        Roles._checkRoleName(childRoleName);\n        let rolesToCheck = [parentRoleName];\n        while (rolesToCheck.length !== 0) {\n          const roleName = rolesToCheck.pop();\n          if (roleName === childRoleName) {\n            return true;\n          }\n          const role = Promise.await(Meteor.roles.findOneAsync({\n            _id: roleName\n          }));\n\n          // This should not happen, but this is a problem to address at some other time.\n          if (!role) continue;\n          rolesToCheck = rolesToCheck.concat(role.children.map(r => r._id));\n        }\n        return false;\n      });\n    },\n    /**\n     * Normalize options.\n     *\n     * @method _normalizeOptions\n     * @param {Object} options Options to normalize.\n     * @return {Object} Normalized options.\n     * @private\n     * @static\n     */\n    _normalizeOptions: function (options) {\n      options = options === undefined ? {} : options;\n      if (options === null || typeof options === 'string') {\n        options = {\n          scope: options\n        };\n      }\n      options.scope = Roles._normalizeScopeName(options.scope);\n      return options;\n    },\n    /**\n     * Normalize scope name.\n     *\n     * @method _normalizeScopeName\n     * @param {String} scopeName A scope name to normalize.\n     * @return {String} Normalized scope name.\n     * @private\n     * @static\n     */\n    _normalizeScopeName: function (scopeName) {\n      // map undefined and null to null\n      if (scopeName == null) {\n        return null;\n      } else {\n        return scopeName;\n      }\n    },\n    /**\n     * Throw an exception if `scopeName` is an invalid scope name.\n     *\n     * @method _checkRoleName\n     * @param {String} scopeName A scope name to match against.\n     * @private\n     * @static\n     */\n    _checkScopeName: function (scopeName) {\n      if (scopeName === null) return;\n      if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n        throw new Error(\"Invalid scope name '\" + scopeName + \"'.\");\n      }\n    }\n  });\n}.call(this, module);","map":{"version":3,"names":["Meteor","module1","link","v","Mongo","roles","Collection","roleAssignment","Roles","getGroupsForUserDeprecationWarning","asyncSome","arr","predicate","Promise","asyncApply","e","await","Object","assign","GLOBAL_GROUP","createRoleAsync","roleName","options","_checkRoleName","unlessExists","insertedId","existingRole","findOneAsync","_id","updateAsync","$setOnInsert","children","insertAsync","Error","deleteRoleAsync","inheritedRoles","removeAsync","_getParentRoleNames","r","find","$in","fetchAsync","$pull","_getInheritedRoleNamesAsync","$set","map","r2","multi","length","renameRoleAsync","oldName","newName","count","role","addRolesToParentAsync","rolesNames","parentName","Array","isArray","_addRoleToParentAsync","includes","$ne","$push","$each","removeRolesFromParentAsync","_removeRoleFromParentAsync","fields","_getParentRoleNamesAsync","addUsersToRolesAsync","users","id","_normalizeOptions","_checkScopeName","scope","ifExists","user","_addUserToRoleAsync","setUserRolesAsync","anyScope","selector","_addUserToRole","userId","existingAssignment","res","parentRoles","Set","parentRole","add","delete","nestedRoles","removeUsersFromRolesAsync","_removeUserFromRoleAsync","userIsInRoleAsync","filter","out","limit","countAsync","getRolesForUserAsync","fullObjects","onlyAssigned","onlyScoped","push","reduce","rev","current","concat","getAllRoles","queryOptions","sort","getUsersInRoleAsync","ids","getUserAssignmentsForRole","a","_getUsersInRoleCursor","getGroupsForUserAsync","console","warn","getScopesForUser","arguments","getScopesForUserAsync","scopes","obi","renameScopeAsync","removeScopeAsync","name","trim","isParentOfAsync","parentRoleName","childRoleName","rolesToCheck","pop","undefined","_normalizeScopeName","scopeName","call","module"],"sources":["packages/alanning:roles/roles/roles_common_async.js"],"sourcesContent":["/* global Roles */\nimport { Meteor } from 'meteor/meteor'\nimport { Mongo } from 'meteor/mongo'\n\n/**\n * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n *\n * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n *  - `_id`: role name\n *  - `children`: list of subdocuments:\n *    - `_id`\n *\n * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n *\n * Roles can have multiple parents and can be children (subroles) of multiple roles.\n *\n * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n *\n * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n * It's documents consist of\n *  - `_id`: Internal MongoDB id\n *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n *  - `user`: A user object, usually only contains the `_id` property\n *  - `scope`: scope name\n *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n *\n * @module Roles\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Mongo.Collection('roles')\n}\n\nif (!Meteor.roleAssignment) {\n  Meteor.roleAssignment = new Mongo.Collection('role-assignment')\n}\n\n/**\n * @class Roles\n */\nif (typeof Roles === 'undefined') {\n  Roles = {} // eslint-disable-line no-global-assign\n}\n\nlet getGroupsForUserDeprecationWarning = false\n\n/**\n * Helper, resolves async some\n * @param {*} arr\n * @param {*} predicate\n * @returns {Promise<Boolean>}\n */\nconst asyncSome = async (arr, predicate) => {\n  for (const e of arr) {\n    if (await predicate(e)) return true\n  }\n  return false\n}\n\nObject.assign(Roles, {\n  /**\n   * Used as a global group (now scope) name. Not used anymore.\n   *\n   * @property GLOBAL_GROUP\n   * @static\n   * @deprecated\n   */\n  GLOBAL_GROUP: null,\n\n  /**\n   * Create a new role.\n   *\n   * @method createRoleAsync\n   * @param {String} roleName Name of role.\n   * @param {Object} [options] Options:\n   *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n   * @return {Promise<String>} ID of the new role or null.\n   * @static\n   */\n  createRoleAsync: async function (roleName, options) {\n    Roles._checkRoleName(roleName)\n\n    options = Object.assign(\n      {\n        unlessExists: false\n      },\n      options\n    )\n\n    let insertedId = null\n\n    const existingRole = await Meteor.roles.findOneAsync({ _id: roleName })\n\n    if (existingRole) {\n      await Meteor.roles.updateAsync(\n        { _id: roleName },\n        { $setOnInsert: { children: [] } }\n      )\n      return null\n    } else {\n      insertedId = await Meteor.roles.insertAsync({\n        _id: roleName,\n        children: []\n      })\n    }\n\n    if (!insertedId) {\n      if (options.unlessExists) return null\n      throw new Error(\"Role '\" + roleName + \"' already exists.\")\n    }\n\n    return insertedId\n  },\n\n  /**\n   * Delete an existing role.\n   *\n   * If the role is set for any user, it is automatically unset.\n   *\n   * @method deleteRoleAsync\n   * @param {String} roleName Name of role.\n   * @returns {Promise}\n   * @static\n   */\n  deleteRoleAsync: async function (roleName) {\n    let roles\n    let inheritedRoles\n\n    Roles._checkRoleName(roleName)\n\n    // Remove all assignments\n    await Meteor.roleAssignment.removeAsync({\n      'role._id': roleName\n    })\n\n    do {\n      // For all roles who have it as a dependency ...\n      roles = Roles._getParentRoleNames(\n        await Meteor.roles.findOneAsync({ _id: roleName })\n      )\n\n      for (const r of await Meteor.roles\n        .find({ _id: { $in: roles } })\n        .fetchAsync()) {\n        await Meteor.roles.updateAsync(\n          {\n            _id: r._id\n          },\n          {\n            $pull: {\n              children: {\n                _id: roleName\n              }\n            }\n          }\n        )\n\n        inheritedRoles = await Roles._getInheritedRoleNamesAsync(\n          await Meteor.roles.findOneAsync({ _id: r._id })\n        )\n        await Meteor.roleAssignment.updateAsync(\n          {\n            'role._id': r._id\n          },\n          {\n            $set: {\n              inheritedRoles: [r._id, ...inheritedRoles].map((r2) => ({\n                _id: r2\n              }))\n            }\n          },\n          { multi: true }\n        )\n      }\n    } while (roles.length > 0)\n\n    // And finally remove the role itself\n    await Meteor.roles.removeAsync({ _id: roleName })\n  },\n\n  /**\n   * Rename an existing role.\n   *\n   * @method renameRoleAsync\n   * @param {String} oldName Old name of a role.\n   * @param {String} newName New name of a role.\n   * @returns {Promise}\n   * @static\n   */\n  renameRoleAsync: async function (oldName, newName) {\n    let count\n\n    Roles._checkRoleName(oldName)\n    Roles._checkRoleName(newName)\n\n    if (oldName === newName) return\n\n    const role = await Meteor.roles.findOneAsync({ _id: oldName })\n\n    if (!role) {\n      throw new Error(\"Role '\" + oldName + \"' does not exist.\")\n    }\n\n    role._id = newName\n\n    await Meteor.roles.insertAsync(role)\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          'role._id': oldName\n        },\n        {\n          $set: {\n            'role._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          'inheritedRoles._id': oldName\n        },\n        {\n          $set: {\n            'inheritedRoles.$._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    do {\n      count = await Meteor.roles.updateAsync(\n        {\n          'children._id': oldName\n        },\n        {\n          $set: {\n            'children.$._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    await Meteor.roles.removeAsync({ _id: oldName })\n  },\n\n  /**\n   * Add role parent to roles.\n   *\n   * Previous parents are kept (role can have multiple parents). For users which have the\n   * parent role set, new subroles are added automatically.\n   *\n   * @method addRolesToParentAsync\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @static\n   */\n  addRolesToParentAsync: async function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    for (const roleName of rolesNames) {\n      await Roles._addRoleToParentAsync(roleName, parentName)\n    }\n  },\n\n  /**\n   * @method _addRoleToParentAsync\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _addRoleToParentAsync: async function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // query to get role's children\n    const role = await Meteor.roles.findOneAsync({ _id: roleName })\n\n    if (!role) {\n      throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n    }\n\n    // detect cycles\n    if ((await Roles._getInheritedRoleNamesAsync(role)).includes(parentName)) {\n      throw new Error(\n        \"Roles '\" + roleName + \"' and '\" + parentName + \"' would form a cycle.\"\n      )\n    }\n\n    const count = await Meteor.roles.updateAsync(\n      {\n        _id: parentName,\n        'children._id': {\n          $ne: role._id\n        }\n      },\n      {\n        $push: {\n          children: {\n            _id: role._id\n          }\n        }\n      }\n    )\n\n    // if there was no change, parent role might not exist, or role is\n    // already a sub-role; in any case we do not have anything more to do\n    if (!count) return\n\n    await Meteor.roleAssignment.updateAsync(\n      {\n        'inheritedRoles._id': parentName\n      },\n      {\n        $push: {\n          inheritedRoles: {\n            $each: [\n              role._id,\n              ...(await Roles._getInheritedRoleNamesAsync(role))\n            ].map((r) => ({ _id: r }))\n          }\n        }\n      },\n      { multi: true }\n    )\n  },\n\n  /**\n   * Remove role parent from roles.\n   *\n   * Other parents are kept (role can have multiple parents). For users which have the\n   * parent role set, removed subrole is removed automatically.\n   *\n   * @method removeRolesFromParentAsync\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @static\n   */\n  removeRolesFromParentAsync: async function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    for (const roleName of rolesNames) {\n      await Roles._removeRoleFromParentAsync(roleName, parentName)\n    }\n  },\n\n  /**\n   * @method _removeRoleFromParentAsync\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _removeRoleFromParentAsync: async function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // check for role existence\n    // this would not really be needed, but we are trying to match addRolesToParent\n    const role = await Meteor.roles.findOneAsync(\n      { _id: roleName },\n      { fields: { _id: 1 } }\n    )\n\n    if (!role) {\n      throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n    }\n\n    const count = await Meteor.roles.updateAsync(\n      {\n        _id: parentName\n      },\n      {\n        $pull: {\n          children: {\n            _id: role._id\n          }\n        }\n      }\n    )\n\n    // if there was no change, parent role might not exist, or role was\n    // already not a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    // For all roles who have had it as a dependency ...\n    const roles = [\n      ...(await Roles._getParentRoleNamesAsync(\n        await Meteor.roles.findOneAsync({ _id: parentName })\n      )),\n      parentName\n    ]\n\n    for (const r of await Meteor.roles\n      .find({ _id: { $in: roles } })\n      .fetchAsync()) {\n      const inheritedRoles = await Roles._getInheritedRoleNamesAsync(\n        await Meteor.roles.findOneAsync({ _id: r._id })\n      )\n      await Meteor.roleAssignment.updateAsync(\n        {\n          'role._id': r._id,\n          'inheritedRoles._id': role._id\n        },\n        {\n          $set: {\n            inheritedRoles: [r._id, ...inheritedRoles].map((r2) => ({\n              _id: r2\n            }))\n          }\n        },\n        { multi: true }\n      )\n    }\n  },\n\n  /**\n   * Add users to roles.\n   *\n   * Adds roles to existing roles for each user.\n   *\n   * @example\n   *     Roles.addUsersToRolesAsync(userId, 'admin')\n   *     Roles.addUsersToRolesAsync(userId, ['view-secrets'], 'example.com')\n   *     Roles.addUsersToRolesAsync([user1, user2], ['user','editor'])\n   *     Roles.addUsersToRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method addUsersToRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  addUsersToRolesAsync: async function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        ifExists: false\n      },\n      options\n    )\n\n    for (const user of users) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n\n      for (const role of roles) {\n        await Roles._addUserToRoleAsync(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Set users' roles.\n   *\n   * Replaces all existing roles with a new set of roles.\n   *\n   * @example\n   *     await Roles.setUserRolesAsync(userId, 'admin')\n   *     await Roles.setUserRolesAsync(userId, ['view-secrets'], 'example.com')\n   *     await Roles.setUserRolesAsync([user1, user2], ['user','editor'])\n   *     await Roles.setUserRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method setUserRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  setUserRolesAsync: async function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        ifExists: false,\n        anyScope: false\n      },\n      options\n    )\n\n    for (const user of users) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n      // we first clear all roles for the user\n      const selector = { 'user._id': id }\n      if (!options.anyScope) {\n        selector.scope = options.scope\n      }\n\n      await Meteor.roleAssignment.removeAsync(selector)\n\n      // and then add all\n      for (const role of roles) {\n        await Roles._addUserToRole(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Add one user to one role.\n   *\n   * @method _addUserToRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _addUserToRoleAsync: async function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) {\n      return\n    }\n\n    const role = await Meteor.roles.findOneAsync(\n      { _id: roleName },\n      { fields: { children: 1 } }\n    )\n\n    if (!role) {\n      if (options.ifExists) {\n        return []\n      } else {\n        throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n      }\n    }\n\n    // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n    // TODO revisit this\n    /* const res = await Meteor.roleAssignment.upsertAsync(\n      {\n        \"user._id\": userId,\n        \"role._id\": roleName,\n        scope: options.scope,\n      },\n      {\n        $setOnInsert: {\n          user: { _id: userId },\n          role: { _id: roleName },\n          scope: options.scope,\n        },\n      }\n    ); */\n    const existingAssignment = await Meteor.roleAssignment.findOneAsync({\n      'user._id': userId,\n      'role._id': roleName,\n      scope: options.scope\n    })\n\n    let insertedId\n    let res\n    if (existingAssignment) {\n      await Meteor.roleAssignment.updateAsync(existingAssignment._id, {\n        $set: {\n          user: { _id: userId },\n          role: { _id: roleName },\n          scope: options.scope\n        }\n      })\n\n      res = await Meteor.roleAssignment.findOneAsync(existingAssignment._id)\n    } else {\n      insertedId = await Meteor.roleAssignment.insertAsync({\n        user: { _id: userId },\n        role: { _id: roleName },\n        scope: options.scope\n      })\n    }\n\n    if (insertedId) {\n      await Meteor.roleAssignment.updateAsync(\n        { _id: insertedId },\n        {\n          $set: {\n            inheritedRoles: [\n              roleName,\n              ...(await Roles._getInheritedRoleNamesAsync(role))\n            ].map((r) => ({ _id: r }))\n          }\n        }\n      )\n\n      res = await Meteor.roleAssignment.findOneAsync({ _id: insertedId })\n    }\n    res.insertedId = insertedId // For backward compatibility\n\n    return res\n  },\n\n  /**\n   * Returns an array of role names the given role name is a child of.\n   *\n   * @example\n   *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getParentRoleNames\n   * @param {object} role The role object\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _getParentRoleNamesAsync: async function (role) {\n    if (!role) {\n      return []\n    }\n\n    const parentRoles = new Set([role._id])\n\n    for (const roleName of parentRoles) {\n      for (const parentRole of await Meteor.roles\n        .find({ 'children._id': roleName })\n        .fetchAsync()) {\n        parentRoles.add(parentRole._id)\n      }\n    }\n\n    parentRoles.delete(role._id)\n\n    return [...parentRoles]\n  },\n\n  /**\n   * Returns an array of role names the given role name is a parent of.\n   *\n   * @example\n   *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getInheritedRoleNames\n   * @param {object} role The role object\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _getInheritedRoleNamesAsync: async function (role) {\n    const inheritedRoles = new Set()\n    const nestedRoles = new Set([role])\n\n    for (const r of nestedRoles) {\n      const roles = await Meteor.roles\n        .find(\n          { _id: { $in: r.children.map((r) => r._id) } },\n          { fields: { children: 1 } }\n        )\n        .fetchAsync()\n\n      for (const r2 of roles) {\n        inheritedRoles.add(r2._id)\n        nestedRoles.add(r2)\n      }\n    }\n\n    return [...inheritedRoles]\n  },\n\n  /**\n   * Remove users from assigned roles.\n   *\n   * @example\n   *     await Roles.removeUsersFromRolesAsync(userId, 'admin')\n   *     await Roles.removeUsersFromRolesAsync([userId, user2], ['editor'])\n   *     await Roles.removeUsersFromRolesAsync(userId, ['user'], 'group1')\n   *\n   * @method removeUsersFromRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  removeUsersFromRolesAsync: async function (users, roles, options) {\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    for (const user of users) {\n      if (!user) return\n\n      for (const role of roles) {\n        let id\n        if (typeof user === 'object') {\n          id = user._id\n        } else {\n          id = user\n        }\n\n        await Roles._removeUserFromRoleAsync(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Remove one user from one role.\n   *\n   * @method _removeUserFromRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _removeUserFromRoleAsync: async function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) return\n\n    const selector = {\n      'user._id': userId,\n      'role._id': roleName\n    }\n\n    if (!options.anyScope) {\n      selector.scope = options.scope\n    }\n\n    await Meteor.roleAssignment.removeAsync(selector)\n  },\n\n  /**\n   * Check if user has specified roles.\n   *\n   * @example\n   *     // global roles\n   *     await Roles.userIsInRoleAsync(user, 'admin')\n   *     await Roles.userIsInRoleAsync(user, ['admin','editor'])\n   *     await Roles.userIsInRoleAsync(userId, 'admin')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'])\n   *\n   *     // scope roles (global roles are still checked)\n   *     await Roles.userIsInRoleAsync(user, 'admin', 'group1')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], 'group1')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], {scope: 'group1'})\n   *\n   * @method userIsInRoleAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n   *                             will return `true` if user is in _any_ role.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope; if supplied, limits check to just that scope\n   *     the user's global roles will always be checked whether scope is specified or not\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Promise<Boolean>} `true` if user is in _any_ of the target roles\n   * @static\n   */\n  userIsInRoleAsync: async function (user, roles, options) {\n    let id\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    roles = roles.filter((r) => r != null)\n\n    if (!roles.length) return false\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        anyScope: false\n      },\n      options\n    )\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return false\n    if (typeof id !== 'string') return false\n\n    const selector = {\n      'user._id': id\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope, null] }\n    }\n\n    const res = await asyncSome(roles, async (roleName) => {\n      selector['inheritedRoles._id'] = roleName\n      const out =\n        (await Meteor.roleAssignment\n          .find(selector, { limit: 1 })\n          .countAsync()) > 0\n      return out\n    })\n\n    return res\n  },\n\n  /**\n   * Retrieve user's roles.\n   *\n   * @method getRolesForUserAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n   *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n   *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n   *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n   *     result strongly dependent on the internal data structure of this plugin.\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Promise<Array>} Array of user's roles, unsorted.\n   * @static\n   */\n  getRolesForUserAsync: async function (user, options) {\n    let id\n\n    options = Roles._normalizeOptions(options)\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      fullObjects: false,\n      onlyAssigned: false,\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id\n    }\n\n    const filter = {\n      fields: { 'inheritedRoles._id': 1 }\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    if (options.onlyAssigned) {\n      delete filter.fields['inheritedRoles._id']\n      filter.fields['role._id'] = 1\n    }\n\n    if (options.fullObjects) {\n      delete filter.fields\n    }\n\n    const roles = await Meteor.roleAssignment.find(selector, filter).fetchAsync()\n\n    if (options.fullObjects) {\n      return roles\n    }\n\n    return [\n      ...new Set(\n        roles.reduce((rev, current) => {\n          if (current.inheritedRoles) {\n            return rev.concat(current.inheritedRoles.map((r) => r._id))\n          } else if (current.role) {\n            rev.push(current.role._id)\n          }\n          return rev\n        }, [])\n      )\n    ]\n  },\n\n  /**\n   * Retrieve cursor of all existing roles.\n   *\n   * @method getAllRoles\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.roles.find(query, options)`.\n   * @return {Cursor} Cursor of existing roles.\n   * @static\n   */\n  getAllRoles: function (queryOptions) {\n    queryOptions = queryOptions || { sort: { _id: 1 } }\n\n    return Meteor.roles.find({}, queryOptions)\n  },\n\n  /**\n   * Retrieve all users who are in target role.\n   *\n   * Options:\n   *\n   * @method getUsersInRoleAsync\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.users.find(query, options)`\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.users.find(query, options)`\n   * @return {Promise<Cursor>} Cursor of users in roles.\n   * @static\n   */\n  getUsersInRoleAsync: async function (roles, options, queryOptions) {\n    const ids = (\n      await Roles.getUserAssignmentsForRole(roles, options).fetchAsync()\n    ).map((a) => a.user._id)\n\n    return Meteor.users.find(\n      { _id: { $in: ids } },\n      (options && options.queryOptions) || queryOptions || {}\n    )\n  },\n\n  /**\n   * Retrieve all assignments of a user which are for the target role.\n   *\n   * Options:\n   *\n   * @method getUserAssignmentsForRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.roleAssignment.find(query, options)`\n\n   * Alternatively, it can be a scope name string.\n   * @return {Cursor} Cursor of user assignments for roles.\n   * @static\n   */\n  getUserAssignmentsForRole: function (roles, options) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign(\n      {\n        anyScope: false,\n        queryOptions: {}\n      },\n      options\n    )\n\n    return Roles._getUsersInRoleCursor(roles, options, options.queryOptions)\n  },\n\n  /**\n   * @method _getUsersInRoleCursor\n   * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n   *                             returned which have at least one of the roles\n   *                             assigned but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [filter] Options which are passed directly\n   *                                through to `Meteor.roleAssignment.find(query, options)`\n   * @return {Object} Cursor to the assignment documents\n   * @private\n   * @static\n   */\n  _getUsersInRoleCursor: function (roles, options, filter) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign(\n      {\n        anyScope: false,\n        onlyScoped: false\n      },\n      options\n    )\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    filter = Object.assign(\n      {\n        fields: { 'user._id': 1 }\n      },\n      filter\n    )\n\n    const selector = {\n      'inheritedRoles._id': { $in: roles }\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    return Meteor.roleAssignment.find(selector, filter)\n  },\n\n  /**\n   * Deprecated. Use `getScopesForUser` instead.\n   *\n   * @method getGroupsForUserAsync\n   * @returns {Promise<Array>}\n   * @static\n   * @deprecated\n   */\n  getGroupsForUserAsync: async function (...args) {\n    if (!getGroupsForUserDeprecationWarning) {\n      getGroupsForUserDeprecationWarning = true\n      console &&\n        console.warn(\n          'getGroupsForUser has been deprecated. Use getScopesForUser instead.'\n        )\n    }\n\n    return await Roles.getScopesForUser(...args)\n  },\n\n  /**\n   * Retrieve users scopes, if any.\n   *\n   * @method getScopesForUserAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} [roles] Name of roles to restrict scopes to.\n   *\n   * @return {Promise<Array>} Array of user's scopes, unsorted.\n   * @static\n   */\n  getScopesForUserAsync: async function (user, roles) {\n    let id\n\n    if (roles && !Array.isArray(roles)) roles = [roles]\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id,\n      scope: { $ne: null }\n    }\n\n    if (roles) {\n      selector['inheritedRoles._id'] = { $in: roles }\n    }\n\n    const scopes = (\n      await Meteor.roleAssignment\n        .find(selector, { fields: { scope: 1 } })\n        .fetchAsync()\n    ).map((obi) => obi.scope)\n\n    return [...new Set(scopes)]\n  },\n\n  /**\n   * Rename a scope.\n   *\n   * Roles assigned with a given scope are changed to be under the new scope.\n   *\n   * @method renameScopeAsync\n   * @param {String} oldName Old name of a scope.\n   * @param {String} newName New name of a scope.\n   * @returns {Promise}\n   * @static\n   */\n  renameScopeAsync: async function (oldName, newName) {\n    let count\n\n    Roles._checkScopeName(oldName)\n    Roles._checkScopeName(newName)\n\n    if (oldName === newName) return\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          scope: oldName\n        },\n        {\n          $set: {\n            scope: newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n  },\n\n  /**\n   * Remove a scope.\n   *\n   * Roles assigned with a given scope are removed.\n   *\n   * @method removeScopeAsync\n   * @param {String} name The name of a scope.\n   * @returns {Promise}\n   * @static\n   */\n  removeScopeAsync: async function (name) {\n    Roles._checkScopeName(name)\n\n    await Meteor.roleAssignment.removeAsync({ scope: name })\n  },\n\n  /**\n   * Throw an exception if `roleName` is an invalid role name.\n   *\n   * @method _checkRoleName\n   * @param {String} roleName A role name to match against.\n   * @private\n   * @static\n   */\n  _checkRoleName: function (roleName) {\n    if (\n      !roleName ||\n      typeof roleName !== 'string' ||\n      roleName.trim() !== roleName\n    ) {\n      throw new Error(\"Invalid role name '\" + roleName + \"'.\")\n    }\n  },\n\n  /**\n   * Find out if a role is an ancestor of another role.\n   *\n   * WARNING: If you check this on the client, please make sure all roles are published.\n   *\n   * @method isParentOfAsync\n   * @param {String} parentRoleName The role you want to research.\n   * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n   * @returns {Promise}\n   * @static\n   */\n  isParentOfAsync: async function (parentRoleName, childRoleName) {\n    if (parentRoleName === childRoleName) {\n      return true\n    }\n\n    if (parentRoleName == null || childRoleName == null) {\n      return false\n    }\n\n    Roles._checkRoleName(parentRoleName)\n    Roles._checkRoleName(childRoleName)\n\n    let rolesToCheck = [parentRoleName]\n    while (rolesToCheck.length !== 0) {\n      const roleName = rolesToCheck.pop()\n\n      if (roleName === childRoleName) {\n        return true\n      }\n\n      const role = await Meteor.roles.findOneAsync({ _id: roleName })\n\n      // This should not happen, but this is a problem to address at some other time.\n      if (!role) continue\n\n      rolesToCheck = rolesToCheck.concat(role.children.map((r) => r._id))\n    }\n\n    return false\n  },\n\n  /**\n   * Normalize options.\n   *\n   * @method _normalizeOptions\n   * @param {Object} options Options to normalize.\n   * @return {Object} Normalized options.\n   * @private\n   * @static\n   */\n  _normalizeOptions: function (options) {\n    options = options === undefined ? {} : options\n\n    if (options === null || typeof options === 'string') {\n      options = { scope: options }\n    }\n\n    options.scope = Roles._normalizeScopeName(options.scope)\n\n    return options\n  },\n\n  /**\n   * Normalize scope name.\n   *\n   * @method _normalizeScopeName\n   * @param {String} scopeName A scope name to normalize.\n   * @return {String} Normalized scope name.\n   * @private\n   * @static\n   */\n  _normalizeScopeName: function (scopeName) {\n    // map undefined and null to null\n    if (scopeName == null) {\n      return null\n    } else {\n      return scopeName\n    }\n  },\n\n  /**\n   * Throw an exception if `scopeName` is an invalid scope name.\n   *\n   * @method _checkRoleName\n   * @param {String} scopeName A scope name to match against.\n   * @private\n   * @static\n   */\n  _checkScopeName: function (scopeName) {\n    if (scopeName === null) return\n\n    if (\n      !scopeName ||\n      typeof scopeName !== 'string' ||\n      scopeName.trim() !== scopeName\n    ) {\n      throw new Error(\"Invalid scope name '\" + scopeName + \"'.\")\n    }\n  }\n})\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"928b338c19eee2003b1d645e86751c32bf58e51f"}
