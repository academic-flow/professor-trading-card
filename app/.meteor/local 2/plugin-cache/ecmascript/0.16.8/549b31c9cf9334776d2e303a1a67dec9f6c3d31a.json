{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/models/methods.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/montiapm:agent/lib/models/methods.js","filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/models/methods.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/phatca/Documents/GitHub/professor-trading-card/app","root":"/Users/phatca/Documents/GitHub/professor-trading-card/app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/models/methods.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/montiapm:agent/lib/models/methods.js"}},"code":"module.export({\n  MethodsModel: () => MethodsModel\n});\nlet _;\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n}, 0);\nlet KadiraModel;\nmodule.link(\"./0model\", {\n  KadiraModel(v) {\n    KadiraModel = v;\n  }\n}, 1);\nlet TracerStore;\nmodule.link(\"../tracer/tracer_store\", {\n  TracerStore(v) {\n    TracerStore = v;\n  }\n}, 2);\nlet Ntp;\nmodule.link(\"../ntp\", {\n  Ntp(v) {\n    Ntp = v;\n  }\n}, 3);\nconst {\n  DDSketch\n} = require('monti-apm-sketches-js');\nconst METHOD_METRICS_FIELDS = ['wait', 'db', 'http', 'email', 'async', 'compute', 'total'];\nfunction MethodsModel(metricsThreshold) {\n  this.methodMetricsByMinute = Object.create(null);\n  this.errorMap = Object.create(null);\n  this._metricsThreshold = _.extend({\n    wait: 100,\n    db: 100,\n    http: 1000,\n    email: 100,\n    async: 100,\n    compute: 100,\n    total: 200\n  }, metricsThreshold || Object.create(null));\n\n  // store max time elapsed methods for each method, event(metrics-field)\n  this.maxEventTimesForMethods = Object.create(null);\n  this.tracerStore = new TracerStore({\n    // process traces every minute\n    interval: 1000 * 60,\n    // for 30 minutes\n    maxTotalPoints: 30,\n    // always trace for every 5 minutes\n    archiveEvery: 5\n  });\n  this.tracerStore.start();\n}\n_.extend(MethodsModel.prototype, KadiraModel.prototype);\nMethodsModel.prototype._getMetrics = function (timestamp, method) {\n  const dateId = this._getDateId(timestamp);\n  if (!this.methodMetricsByMinute[dateId]) {\n    this.methodMetricsByMinute[dateId] = {\n      methods: Object.create(null)\n    };\n  }\n  let methods = this.methodMetricsByMinute[dateId].methods;\n\n  // initialize method\n  if (!methods[method]) {\n    methods[method] = {\n      count: 0,\n      errors: 0,\n      fetchedDocSize: 0,\n      sentMsgSize: 0,\n      histogram: new DDSketch({\n        alpha: 0.02\n      })\n    };\n    METHOD_METRICS_FIELDS.forEach(function (field) {\n      methods[method][field] = 0;\n    });\n  }\n  return this.methodMetricsByMinute[dateId].methods[method];\n};\nMethodsModel.prototype.processMethod = function (methodTrace) {\n  const dateId = this._getDateId(methodTrace.at);\n\n  // append metrics to previous values\n  this._appendMetrics(dateId, methodTrace);\n  if (methodTrace.errored) {\n    this.methodMetricsByMinute[dateId].methods[methodTrace.name].errors++;\n  }\n  this.tracerStore.addTrace(methodTrace);\n};\nMethodsModel.prototype._appendMetrics = function (id, methodTrace) {\n  const methodMetrics = this._getMetrics(id, methodTrace.name);\n\n  // startTime needs to be converted into serverTime before sending\n  if (!this.methodMetricsByMinute[id].startTime) {\n    this.methodMetricsByMinute[id].startTime = methodTrace.at;\n  }\n\n  // merge\n  METHOD_METRICS_FIELDS.forEach(function (field) {\n    let value = methodTrace.metrics[field];\n    if (value > 0) {\n      methodMetrics[field] += value;\n    }\n  });\n  methodMetrics.count++;\n  methodMetrics.histogram.add(methodTrace.metrics.total);\n  this.methodMetricsByMinute[id].endTime = methodTrace.metrics.at;\n};\nMethodsModel.prototype.trackDocSize = function (method, size) {\n  const timestamp = Ntp._now();\n  const dateId = this._getDateId(timestamp);\n  let methodMetrics = this._getMetrics(dateId, method);\n  methodMetrics.fetchedDocSize += size;\n};\nMethodsModel.prototype.trackMsgSize = function (method, size) {\n  const timestamp = Ntp._now();\n  const dateId = this._getDateId(timestamp);\n  let methodMetrics = this._getMetrics(dateId, method);\n  methodMetrics.sentMsgSize += size;\n};\n\n/*\n  There are two types of data\n\n  1. methodMetrics - metrics about the methods (for every 10 secs)\n  2. methodRequests - raw method request. normally max, min for every 1 min and errors always\n*/\nMethodsModel.prototype.buildPayload = function () {\n  const payload = {\n    methodMetrics: [],\n    methodRequests: []\n  };\n\n  // handling metrics\n  let methodMetricsByMinute = this.methodMetricsByMinute;\n  this.methodMetricsByMinute = Object.create(null);\n\n  // create final payload for methodMetrics\n  for (let key in methodMetricsByMinute) {\n    const methodMetrics = methodMetricsByMinute[key];\n    // converting startTime into the actual serverTime\n    let startTime = methodMetrics.startTime;\n    methodMetrics.startTime = Kadira.syncedDate.syncTime(startTime);\n    for (let methodName in methodMetrics.methods) {\n      METHOD_METRICS_FIELDS.forEach(function (field) {\n        methodMetrics.methods[methodName][field] /= methodMetrics.methods[methodName].count;\n      });\n    }\n    payload.methodMetrics.push(methodMetricsByMinute[key]);\n  }\n\n  // collect traces and send them with the payload\n  payload.methodRequests = this.tracerStore.collectTraces();\n  return payload;\n};","map":{"version":3,"names":["module","export","MethodsModel","_","link","v","KadiraModel","TracerStore","Ntp","DDSketch","require","METHOD_METRICS_FIELDS","metricsThreshold","methodMetricsByMinute","Object","create","errorMap","_metricsThreshold","extend","wait","db","http","email","async","compute","total","maxEventTimesForMethods","tracerStore","interval","maxTotalPoints","archiveEvery","start","prototype","_getMetrics","timestamp","method","dateId","_getDateId","methods","count","errors","fetchedDocSize","sentMsgSize","histogram","alpha","forEach","field","processMethod","methodTrace","at","_appendMetrics","errored","name","addTrace","id","methodMetrics","startTime","value","metrics","add","endTime","trackDocSize","size","_now","trackMsgSize","buildPayload","payload","methodRequests","key","Kadira","syncedDate","syncTime","methodName","push","collectTraces"],"sources":["packages/montiapm:agent/lib/models/methods.js"],"sourcesContent":["import { _ } from 'meteor/underscore';\nconst { DDSketch } = require('monti-apm-sketches-js');\nimport { KadiraModel } from './0model';\nimport { TracerStore } from '../tracer/tracer_store';\nimport { Ntp } from '../ntp';\n\nconst METHOD_METRICS_FIELDS = ['wait', 'db', 'http', 'email', 'async', 'compute', 'total'];\n\nexport function MethodsModel (metricsThreshold) {\n  this.methodMetricsByMinute = Object.create(null);\n  this.errorMap = Object.create(null);\n\n  this._metricsThreshold = _.extend({\n    wait: 100,\n    db: 100,\n    http: 1000,\n    email: 100,\n    async: 100,\n    compute: 100,\n    total: 200\n  }, metricsThreshold || Object.create(null));\n\n  // store max time elapsed methods for each method, event(metrics-field)\n  this.maxEventTimesForMethods = Object.create(null);\n\n  this.tracerStore = new TracerStore({\n    // process traces every minute\n    interval: 1000 * 60,\n    // for 30 minutes\n    maxTotalPoints: 30,\n    // always trace for every 5 minutes\n    archiveEvery: 5\n  });\n\n  this.tracerStore.start();\n}\n\n_.extend(MethodsModel.prototype, KadiraModel.prototype);\n\nMethodsModel.prototype._getMetrics = function (timestamp, method) {\n  const dateId = this._getDateId(timestamp);\n\n  if (!this.methodMetricsByMinute[dateId]) {\n    this.methodMetricsByMinute[dateId] = {\n      methods: Object.create(null),\n    };\n  }\n\n  let methods = this.methodMetricsByMinute[dateId].methods;\n\n  // initialize method\n  if (!methods[method]) {\n    methods[method] = {\n      count: 0,\n      errors: 0,\n      fetchedDocSize: 0,\n      sentMsgSize: 0,\n      histogram: new DDSketch({\n        alpha: 0.02\n      })\n    };\n\n    METHOD_METRICS_FIELDS.forEach(function (field) {\n      methods[method][field] = 0;\n    });\n  }\n\n  return this.methodMetricsByMinute[dateId].methods[method];\n};\n\nMethodsModel.prototype.processMethod = function (methodTrace) {\n  const dateId = this._getDateId(methodTrace.at);\n\n  // append metrics to previous values\n  this._appendMetrics(dateId, methodTrace);\n  if (methodTrace.errored) {\n    this.methodMetricsByMinute[dateId].methods[methodTrace.name].errors++;\n  }\n\n  this.tracerStore.addTrace(methodTrace);\n};\n\nMethodsModel.prototype._appendMetrics = function (id, methodTrace) {\n  const methodMetrics = this._getMetrics(id, methodTrace.name);\n\n  // startTime needs to be converted into serverTime before sending\n  if (!this.methodMetricsByMinute[id].startTime) {\n    this.methodMetricsByMinute[id].startTime = methodTrace.at;\n  }\n\n  // merge\n  METHOD_METRICS_FIELDS.forEach(function (field) {\n    let value = methodTrace.metrics[field];\n    if (value > 0) {\n      methodMetrics[field] += value;\n    }\n  });\n\n  methodMetrics.count++;\n  methodMetrics.histogram.add(methodTrace.metrics.total);\n  this.methodMetricsByMinute[id].endTime = methodTrace.metrics.at;\n};\n\nMethodsModel.prototype.trackDocSize = function (method, size) {\n  const timestamp = Ntp._now();\n  const dateId = this._getDateId(timestamp);\n\n  let methodMetrics = this._getMetrics(dateId, method);\n  methodMetrics.fetchedDocSize += size;\n};\n\nMethodsModel.prototype.trackMsgSize = function (method, size) {\n  const timestamp = Ntp._now();\n  const dateId = this._getDateId(timestamp);\n\n  let methodMetrics = this._getMetrics(dateId, method);\n  methodMetrics.sentMsgSize += size;\n};\n\n/*\n  There are two types of data\n\n  1. methodMetrics - metrics about the methods (for every 10 secs)\n  2. methodRequests - raw method request. normally max, min for every 1 min and errors always\n*/\nMethodsModel.prototype.buildPayload = function () {\n  const payload = {\n    methodMetrics: [],\n    methodRequests: []\n  };\n\n  // handling metrics\n  let methodMetricsByMinute = this.methodMetricsByMinute;\n  this.methodMetricsByMinute = Object.create(null);\n\n  // create final payload for methodMetrics\n  for (let key in methodMetricsByMinute) {\n    const methodMetrics = methodMetricsByMinute[key];\n    // converting startTime into the actual serverTime\n    let startTime = methodMetrics.startTime;\n    methodMetrics.startTime = Kadira.syncedDate.syncTime(startTime);\n\n    for (let methodName in methodMetrics.methods) {\n      METHOD_METRICS_FIELDS.forEach(function (field) {\n        methodMetrics.methods[methodName][field] /=\n          methodMetrics.methods[methodName].count;\n      });\n    }\n\n    payload.methodMetrics.push(methodMetricsByMinute[key]);\n  }\n\n  // collect traces and send them with the payload\n  payload.methodRequests = this.tracerStore.collectTraces();\n\n  return payload;\n};\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"549b31c9cf9334776d2e303a1a67dec9f6c3d31a"}
