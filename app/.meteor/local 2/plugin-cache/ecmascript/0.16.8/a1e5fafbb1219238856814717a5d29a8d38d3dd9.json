{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/accounts-password/password_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/accounts-password/password_server.js","filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/accounts-password/password_server.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/phatca/Documents/GitHub/professor-trading-card/app","root":"/Users/phatca/Documents/GitHub/professor-trading-card/app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/accounts-password/password_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/accounts-password/password_server.js"}},"code":"let _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n}, 0);\nlet bcryptHash, bcryptCompare;\nmodule.link(\"bcrypt\", {\n  hash(v) {\n    bcryptHash = v;\n  },\n  compare(v) {\n    bcryptCompare = v;\n  }\n}, 0);\nlet Accounts;\nmodule.link(\"meteor/accounts-base\", {\n  Accounts(v) {\n    Accounts = v;\n  }\n}, 1);\n// Utility for grabbing user\nconst getUserById = (id, options) => Meteor.users.findOne(id, Accounts._addDefaultFieldSelector(options));\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords.\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\nAccounts._bcryptRounds = () => Accounts._options.bcryptRounds || 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nconst getPasswordString = password => {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else {\n    // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" + \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nconst hashPassword = password => Promise.asyncApply(() => {\n  password = getPasswordString(password);\n  return Promise.await(bcryptHash(password, Accounts._bcryptRounds()));\n});\n\n// Extract the number of rounds used in the specified bcrypt hash.\nconst getRoundsFromBcryptHash = hash => {\n  let rounds;\n  if (hash) {\n    const hashSegments = hash.split('$');\n    if (hashSegments.length > 2) {\n      rounds = parseInt(hashSegments[2], 10);\n    }\n  }\n  return rounds;\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\n// The user parameter needs at least user._id and user.services\nAccounts._checkPasswordUserFields = {\n  _id: 1,\n  services: 1\n};\n//\nconst checkPasswordAsync = (user, password) => Promise.asyncApply(() => {\n  const result = {\n    userId: user._id\n  };\n  const formattedPassword = getPasswordString(password);\n  const hash = user.services.password.bcrypt;\n  const hashRounds = getRoundsFromBcryptHash(hash);\n  if (!Promise.await(bcryptCompare(formattedPassword, hash))) {\n    result.error = Accounts._handleError(\"Incorrect password\", false);\n  } else if (hash && Accounts._bcryptRounds() != hashRounds) {\n    // The password checks out, but the user's bcrypt hash needs to be updated.\n\n    Meteor.defer(() => Promise.asyncApply(() => {\n      Meteor.users.update({\n        _id: user._id\n      }, {\n        $set: {\n          'services.password.bcrypt': Promise.await(bcryptHash(formattedPassword, Accounts._bcryptRounds()))\n        }\n      });\n    }));\n  }\n  return result;\n});\nconst checkPassword = (user, password) => {\n  return Promise.await(checkPasswordAsync(user, password));\n};\nAccounts._checkPassword = checkPassword;\nAccounts._checkPasswordAsync = checkPasswordAsync;\n\n///\n/// LOGIN\n///\n\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByUsername = (username, options) => Accounts._findUserByQuery({\n  username\n}, options);\n\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByEmail = (email, options) => Accounts._findUserByQuery({\n  email\n}, options);\n\n// XXX maybe this belongs in the check package\nconst NonEmptyString = Match.Where(x => {\n  check(x, String);\n  return x.length > 0;\n});\nconst passwordValidator = Match.OneOf(Match.Where(str => {\n  var _Meteor$settings, _Meteor$settings$pack, _Meteor$settings$pack2;\n  return Match.test(str, String) && str.length <= ((_Meteor$settings = Meteor.settings) === null || _Meteor$settings === void 0 ? void 0 : (_Meteor$settings$pack = _Meteor$settings.packages) === null || _Meteor$settings$pack === void 0 ? void 0 : (_Meteor$settings$pack2 = _Meteor$settings$pack.accounts) === null || _Meteor$settings$pack2 === void 0 ? void 0 : _Meteor$settings$pack2.passwordMaxLength) || 256;\n}), {\n  digest: Match.Where(str => Match.test(str, String) && str.length === 64),\n  algorithm: Match.OneOf('sha-256')\n});\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", options => Promise.asyncApply(() => {\n  var _Accounts$_check2faEn, _Accounts;\n  if (!options.password) return undefined; // don't handle\n\n  check(options, {\n    user: Accounts._userQueryValidator,\n    password: passwordValidator,\n    code: Match.Optional(NonEmptyString)\n  });\n  const user = Accounts._findUserByQuery(options.user, {\n    fields: _objectSpread({\n      services: 1\n    }, Accounts._checkPasswordUserFields)\n  });\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n  if (!user.services || !user.services.password || !user.services.password.bcrypt) {\n    Accounts._handleError(\"User has no password set\");\n  }\n  const result = Promise.await(checkPasswordAsync(user, options.password));\n  // This method is added by the package accounts-2fa\n  // First the login is validated, then the code situation is checked\n  if (!result.error && (_Accounts$_check2faEn = (_Accounts = Accounts)._check2faEnabled) !== null && _Accounts$_check2faEn !== void 0 && _Accounts$_check2faEn.call(_Accounts, user)) {\n    if (!options.code) {\n      Accounts._handleError('2FA code must be informed', true, 'no-2fa-code');\n    }\n    if (!Accounts._isTokenValid(user.services.twoFactorAuthentication.secret, options.code)) {\n      Accounts._handleError('Invalid 2FA code', true, 'invalid-2fa-code');\n    }\n  }\n  return result;\n}));\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\nAccounts.setUsername = (userId, newUsername) => {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n  const user = getUserById(userId, {\n    fields: {\n      username: 1\n    }\n  });\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n  const oldUsername = user.username;\n\n  // Perform a case insensitive check for duplicates before update\n  Accounts._checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $set: {\n      username: newUsername\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    Accounts._checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $set: {\n        username: oldUsername\n      }\n    });\n    throw ex;\n  }\n};\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\nMeteor.methods({\n  changePassword: function (oldPassword, newPassword) {\n    return Promise.asyncApply(() => {\n      check(oldPassword, passwordValidator);\n      check(newPassword, passwordValidator);\n      if (!this.userId) {\n        throw new Meteor.Error(401, \"Must be logged in\");\n      }\n      const user = getUserById(this.userId, {\n        fields: _objectSpread({\n          services: 1\n        }, Accounts._checkPasswordUserFields)\n      });\n      if (!user) {\n        Accounts._handleError(\"User not found\");\n      }\n      if (!user.services || !user.services.password || !user.services.password.bcrypt) {\n        Accounts._handleError(\"User has no password set\");\n      }\n      const result = Promise.await(checkPasswordAsync(user, oldPassword));\n      if (result.error) {\n        throw result.error;\n      }\n      const hashed = Promise.await(hashPassword(newPassword));\n\n      // It would be better if this removed ALL existing tokens and replaced\n      // the token for the current connection with a new one, but that would\n      // be tricky, so we'll settle for just replacing all tokens other than\n      // the one for the current connection.\n      const currentToken = Accounts._getLoginToken(this.connection.id);\n      Meteor.users.update({\n        _id: this.userId\n      }, {\n        $set: {\n          'services.password.bcrypt': hashed\n        },\n        $pull: {\n          'services.resume.loginTokens': {\n            hashedToken: {\n              $ne: currentToken\n            }\n          }\n        },\n        $unset: {\n          'services.password.reset': 1\n        }\n      });\n      return {\n        passwordChanged: true\n      };\n    });\n  }\n});\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPasswordAsync = (userId, newPlaintextPassword, options) => Promise.asyncApply(() => {\n  check(userId, String);\n  check(newPlaintextPassword, Match.Where(str => {\n    var _Meteor$settings2, _Meteor$settings2$pac, _Meteor$settings2$pac2;\n    return Match.test(str, String) && str.length <= ((_Meteor$settings2 = Meteor.settings) === null || _Meteor$settings2 === void 0 ? void 0 : (_Meteor$settings2$pac = _Meteor$settings2.packages) === null || _Meteor$settings2$pac === void 0 ? void 0 : (_Meteor$settings2$pac2 = _Meteor$settings2$pac.accounts) === null || _Meteor$settings2$pac2 === void 0 ? void 0 : _Meteor$settings2$pac2.passwordMaxLength) || 256;\n  }));\n  check(options, Match.Maybe({\n    logout: Boolean\n  }));\n  options = _objectSpread({\n    logout: true\n  }, options);\n  const user = getUserById(userId, {\n    fields: {\n      _id: 1\n    }\n  });\n  if (!user) {\n    throw new Meteor.Error(403, \"User not found\");\n  }\n  const update = {\n    $unset: {\n      'services.password.reset': 1\n    },\n    $set: {\n      'services.password.bcrypt': Promise.await(hashPassword(newPlaintextPassword))\n    }\n  };\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n  Meteor.users.update({\n    _id: user._id\n  }, update);\n});\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPassword = (userId, newPlaintextPassword, options) => {\n  return Promise.await(Accounts.setPasswordAsync(userId, newPlaintextPassword, options));\n};\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Utility for plucking addresses from emails\nconst pluckAddresses = function () {\n  let emails = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return emails.map(email => email.address);\n};\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({\n  forgotPassword: options => {\n    check(options, {\n      email: String\n    });\n    const user = Accounts.findUserByEmail(options.email, {\n      fields: {\n        emails: 1\n      }\n    });\n    if (!user) {\n      Accounts._handleError(\"User not found\");\n    }\n    const emails = pluckAddresses(user.emails);\n    const caseSensitiveEmail = emails.find(email => email.toLowerCase() === options.email.toLowerCase());\n    Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n  }\n});\n\n/**\n * @summary Generates a reset token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the reset token for.\n * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateResetToken = (userId, email, reason, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = getUserById(userId);\n  if (!user) {\n    Accounts._handleError(\"Can't find user\");\n  }\n\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  }\n\n  // make sure we have a valid email\n  if (!email || !pluckAddresses(user.emails).includes(email)) {\n    Accounts._handleError(\"No such email for user.\");\n  }\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    email,\n    when: new Date()\n  };\n  if (reason === 'resetPassword') {\n    tokenRecord.reason = 'reset';\n  } else if (reason === 'enrollAccount') {\n    tokenRecord.reason = 'enroll';\n  } else if (reason) {\n    // fallback so that this function can be used for unknown reasons as well\n    tokenRecord.reason = reason;\n  }\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n  // if this method is called from the enroll account work-flow then\n  // store the token record in 'services.password.enroll' db field\n  // else store the token record in in 'services.password.reset' db field\n  if (reason === 'enrollAccount') {\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $set: {\n        'services.password.enroll': tokenRecord\n      }\n    });\n    // before passing to template, update user object with new token\n    Meteor._ensure(user, 'services', 'password').enroll = tokenRecord;\n  } else {\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $set: {\n        'services.password.reset': tokenRecord\n      }\n    });\n    // before passing to template, update user object with new token\n    Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n  }\n  return {\n    email,\n    user,\n    token\n  };\n};\n\n/**\n * @summary Generates an e-mail verification token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the  e-mail verification token for.\n * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateVerificationToken = (userId, email, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = getUserById(userId);\n  if (!user) {\n    Accounts._handleError(\"Can't find user\");\n  }\n\n  // pick the first unverified email if we weren't passed an email.\n  if (!email) {\n    const emailRecord = (user.emails || []).find(e => !e.verified);\n    email = (emailRecord || {}).address;\n    if (!email) {\n      Accounts._handleError(\"That user has no unverified email addresses.\");\n    }\n  }\n\n  // make sure we have a valid email\n  if (!email || !pluckAddresses(user.emails).includes(email)) {\n    Accounts._handleError(\"No such email for user.\");\n  }\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    // TODO: This should probably be renamed to \"email\" to match reset token record.\n    address: email,\n    when: new Date()\n  };\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $push: {\n      'services.email.verificationTokens': tokenRecord\n    }\n  });\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n  return {\n    email,\n    user,\n    token\n  };\n};\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the reset url.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendResetPasswordEmail = (userId, email, extraTokenData, extraParams) => {\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n  const url = Accounts.urls.resetPassword(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(\"\\nReset password URL: \".concat(url));\n  }\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the enrollment url.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendEnrollmentEmail = (userId, email, extraTokenData, extraParams) => {\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n  const url = Accounts.urls.enrollAccount(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(\"\\nEnrollment email URL: \".concat(url));\n  }\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n};\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({\n  resetPassword: function () {\n    return Promise.asyncApply(() => {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const token = args[0];\n      const newPassword = args[1];\n      return Promise.await(Accounts._loginMethod(this, \"resetPassword\", args, \"password\", () => Promise.asyncApply(() => {\n        var _Accounts$_check2faEn2, _Accounts2;\n        check(token, String);\n        check(newPassword, passwordValidator);\n        let user = Meteor.users.findOne({\n          \"services.password.reset.token\": token\n        }, {\n          fields: {\n            services: 1,\n            emails: 1\n          }\n        });\n        let isEnroll = false;\n        // if token is in services.password.reset db field implies\n        // this method is was not called from enroll account workflow\n        // else this method is called from enroll account workflow\n        if (!user) {\n          user = Meteor.users.findOne({\n            \"services.password.enroll.token\": token\n          }, {\n            fields: {\n              services: 1,\n              emails: 1\n            }\n          });\n          isEnroll = true;\n        }\n        if (!user) {\n          throw new Meteor.Error(403, \"Token expired\");\n        }\n        let tokenRecord = {};\n        if (isEnroll) {\n          tokenRecord = user.services.password.enroll;\n        } else {\n          tokenRecord = user.services.password.reset;\n        }\n        const {\n          when,\n          email\n        } = tokenRecord;\n        let tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n        if (isEnroll) {\n          tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n        }\n        const currentTimeMs = Date.now();\n        if (currentTimeMs - when > tokenLifetimeMs) throw new Meteor.Error(403, \"Token expired\");\n        if (!pluckAddresses(user.emails).includes(email)) return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n        const hashed = Promise.await(hashPassword(newPassword));\n\n        // NOTE: We're about to invalidate tokens on the user, who we might be\n        // logged in as. Make sure to avoid logging ourselves out if this\n        // happens. But also make sure not to leave the connection in a state\n        // of having a bad token set if things fail.\n        const oldToken = Accounts._getLoginToken(this.connection.id);\n        Accounts._setLoginToken(user._id, this.connection, null);\n        const resetToOldToken = () => Accounts._setLoginToken(user._id, this.connection, oldToken);\n        try {\n          // Update the user record by:\n          // - Changing the password to the new one\n          // - Forgetting about the reset token or enroll token that was just used\n          // - Verifying their email, since they got the password reset via email.\n          let affectedRecords = {};\n          // if reason is enroll then check services.password.enroll.token field for affected records\n          if (isEnroll) {\n            affectedRecords = Meteor.users.update({\n              _id: user._id,\n              'emails.address': email,\n              'services.password.enroll.token': token\n            }, {\n              $set: {\n                'services.password.bcrypt': hashed,\n                'emails.$.verified': true\n              },\n              $unset: {\n                'services.password.enroll': 1\n              }\n            });\n          } else {\n            affectedRecords = Meteor.users.update({\n              _id: user._id,\n              'emails.address': email,\n              'services.password.reset.token': token\n            }, {\n              $set: {\n                'services.password.bcrypt': hashed,\n                'emails.$.verified': true\n              },\n              $unset: {\n                'services.password.reset': 1\n              }\n            });\n          }\n          if (affectedRecords !== 1) return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n        } catch (err) {\n          resetToOldToken();\n          throw err;\n        }\n\n        // Replace all valid login tokens with new ones (changing\n        // password should invalidate existing sessions).\n        Accounts._clearAllLoginTokens(user._id);\n        if ((_Accounts$_check2faEn2 = (_Accounts2 = Accounts)._check2faEnabled) !== null && _Accounts$_check2faEn2 !== void 0 && _Accounts$_check2faEn2.call(_Accounts2, user)) {\n          return {\n            userId: user._id,\n            error: Accounts._handleError('Changed password, but user not logged in because 2FA is enabled', false, '2fa-enabled')\n          };\n        }\n        return {\n          userId: user._id\n        };\n      })));\n    });\n  }\n});\n\n///\n/// EMAIL VERIFICATION\n///\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the verification url.\n *\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendVerificationEmail = (userId, email, extraTokenData, extraParams) => {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateVerificationToken(userId, email, extraTokenData);\n  const url = Accounts.urls.verifyEmail(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(\"\\nVerification email URL: \".concat(url));\n  }\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({\n  verifyEmail: function () {\n    return Promise.asyncApply(() => {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      const token = args[0];\n      return Promise.await(Accounts._loginMethod(this, \"verifyEmail\", args, \"password\", () => {\n        var _Accounts$_check2faEn3, _Accounts3;\n        check(token, String);\n        const user = Meteor.users.findOne({\n          'services.email.verificationTokens.token': token\n        }, {\n          fields: {\n            services: 1,\n            emails: 1\n          }\n        });\n        if (!user) throw new Meteor.Error(403, \"Verify email link expired\");\n        const tokenRecord = user.services.email.verificationTokens.find(t => t.token == token);\n        if (!tokenRecord) return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n        const emailsRecord = user.emails.find(e => e.address == tokenRecord.address);\n        if (!emailsRecord) return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n        // By including the address in the query, we can use 'emails.$' in the\n        // modifier to get a reference to the specific object in the emails\n        // array. See\n        // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n        // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n        Meteor.users.update({\n          _id: user._id,\n          'emails.address': tokenRecord.address\n        }, {\n          $set: {\n            'emails.$.verified': true\n          },\n          $pull: {\n            'services.email.verificationTokens': {\n              address: tokenRecord.address\n            }\n          }\n        });\n        if ((_Accounts$_check2faEn3 = (_Accounts3 = Accounts)._check2faEnabled) !== null && _Accounts$_check2faEn3 !== void 0 && _Accounts$_check2faEn3.call(_Accounts3, user)) {\n          return {\n            userId: user._id,\n            error: Accounts._handleError('Email verified, but user not logged in because 2FA is enabled', false, '2fa-enabled')\n          };\n        }\n        return {\n          userId: user._id\n        };\n      }));\n    });\n  }\n});\n\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\nAccounts.addEmail = (userId, newEmail, verified) => {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n  if (verified === void 0) {\n    verified = false;\n  }\n  const user = getUserById(userId, {\n    fields: {\n      emails: 1\n    }\n  });\n  if (!user) throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  const caseInsensitiveRegExp = new RegExp(\"^\".concat(Meteor._escapeRegExp(newEmail), \"$\"), 'i');\n  const didUpdateOwnEmail = (user.emails || []).reduce((prev, email) => {\n    if (caseInsensitiveRegExp.test(email.address)) {\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': email.address\n      }, {\n        $set: {\n          'emails.$.address': newEmail,\n          'emails.$.verified': verified\n        }\n      });\n      return true;\n    } else {\n      return prev;\n    }\n  }, false);\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  Accounts._checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    Accounts._checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $pull: {\n        emails: {\n          address: newEmail\n        }\n      }\n    });\n    throw ex;\n  }\n};\n\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\nAccounts.removeEmail = (userId, email) => {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n  const user = getUserById(userId, {\n    fields: {\n      _id: 1\n    }\n  });\n  if (!user) throw new Meteor.Error(403, \"User not found\");\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $pull: {\n      emails: {\n        address: email\n      }\n    }\n  });\n};\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nconst createUser = options => Promise.asyncApply(() => {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n  const {\n    username,\n    email,\n    password\n  } = options;\n  if (!username && !email) throw new Meteor.Error(400, \"Need to set a username or email\");\n  const user = {\n    services: {}\n  };\n  if (password) {\n    const hashed = Promise.await(hashPassword(password));\n    user.services.password = {\n      bcrypt: hashed\n    };\n  }\n  return Accounts._createUserCheckingDuplicates({\n    user,\n    email,\n    username,\n    options\n  });\n});\n\n// method for create user. Requests come from the client.\nMeteor.methods({\n  createUser: function () {\n    return Promise.asyncApply(() => {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      const options = args[0];\n      return Promise.await(Accounts._loginMethod(this, \"createUser\", args, \"password\", () => Promise.asyncApply(() => {\n        // createUser() above does more checking.\n        check(options, Object);\n        if (Accounts._options.forbidClientAccountCreation) return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n        const userId = Promise.await(Accounts.createUserVerifyingEmail(options));\n\n        // client gets logged in as the new user afterwards.\n        return {\n          userId: userId\n        };\n      })));\n    });\n  }\n});\n\n/**\n * @summary Creates an user and sends an email if `options.email` is informed.\n * Then if the `sendVerificationEmail` option from the `Accounts` package is\n * enabled, you'll send a verification email if `options.password` is informed,\n * otherwise you'll send an enrollment email.\n * @locus Server\n * @param {Object} options The options object to be passed down when creating\n * the user\n * @param {String} options.username A unique name for this user.\n * @param {String} options.email The user's email address.\n * @param {String} options.password The user's password. This is __not__ sent in plain text over the wire.\n * @param {Object} options.profile The user's profile, typically including the `name` field.\n * @importFromPackage accounts-base\n * */\nAccounts.createUserVerifyingEmail = options => Promise.asyncApply(() => {\n  options = _objectSpread({}, options);\n  // Create user. result contains id and token.\n  const userId = Promise.await(createUser(options));\n  // safety belt. createUser is supposed to throw on error. send 500 error\n  // instead of sending a verification email with empty userid.\n  if (!userId) throw new Error(\"createUser failed to insert new user\");\n\n  // If `Accounts._options.sendVerificationEmail` is set, register\n  // a token to verify the user's primary email, and send it to\n  // that address.\n  if (options.email && Accounts._options.sendVerificationEmail) {\n    if (options.password) {\n      Accounts.sendVerificationEmail(userId, options.email);\n    } else {\n      Accounts.sendEnrollmentEmail(userId, options.email);\n    }\n  }\n  return userId;\n});\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns Promise<userId> or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\n\nAccounts.createUserAsync = (options, callback) => Promise.asyncApply(() => {\n  options = _objectSpread({}, options);\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n  return createUser(options);\n});\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\n\nAccounts.createUser = (options, callback) => {\n  return Promise.await(Accounts.createUserAsync(options, callback));\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users.createIndexAsync('services.email.verificationTokens.token', {\n  unique: true,\n  sparse: true\n});\nMeteor.users.createIndexAsync('services.password.reset.token', {\n  unique: true,\n  sparse: true\n});\nMeteor.users.createIndexAsync('services.password.enroll.token', {\n  unique: true,\n  sparse: true\n});","map":{"version":3,"names":["_objectSpread","module","link","default","v","bcryptHash","bcryptCompare","hash","compare","Accounts","getUserById","id","options","Meteor","users","findOne","_addDefaultFieldSelector","_bcryptRounds","_options","bcryptRounds","getPasswordString","password","SHA256","algorithm","Error","digest","hashPassword","Promise","asyncApply","await","getRoundsFromBcryptHash","rounds","hashSegments","split","length","parseInt","_checkPasswordUserFields","_id","services","checkPasswordAsync","user","result","userId","formattedPassword","bcrypt","hashRounds","error","_handleError","defer","update","$set","checkPassword","_checkPassword","_checkPasswordAsync","findUserByUsername","username","_findUserByQuery","findUserByEmail","email","NonEmptyString","Match","Where","x","check","String","passwordValidator","OneOf","str","_Meteor$settings","_Meteor$settings$pack","_Meteor$settings$pack2","test","settings","packages","accounts","passwordMaxLength","registerLoginHandler","_Accounts$_check2faEn","_Accounts","undefined","_userQueryValidator","code","Optional","fields","_check2faEnabled","call","_isTokenValid","twoFactorAuthentication","secret","setUsername","newUsername","oldUsername","_checkForCaseInsensitiveDuplicates","ex","methods","changePassword","oldPassword","newPassword","hashed","currentToken","_getLoginToken","connection","$pull","hashedToken","$ne","$unset","passwordChanged","setPasswordAsync","newPlaintextPassword","_Meteor$settings2","_Meteor$settings2$pac","_Meteor$settings2$pac2","Maybe","logout","Boolean","setPassword","pluckAddresses","emails","arguments","map","address","forgotPassword","caseSensitiveEmail","find","toLowerCase","sendResetPasswordEmail","generateResetToken","reason","extraTokenData","includes","token","Random","tokenRecord","when","Date","Object","assign","_ensure","enroll","reset","generateVerificationToken","emailRecord","e","verified","$push","verificationTokens","push","extraParams","realEmail","url","urls","resetPassword","generateOptionsForEmail","Email","send","isDevelopment","console","log","concat","sendEnrollmentEmail","enrollAccount","_len","args","Array","_key","_loginMethod","_Accounts$_check2faEn2","_Accounts2","isEnroll","tokenLifetimeMs","_getPasswordResetTokenLifetimeMs","_getPasswordEnrollTokenLifetimeMs","currentTimeMs","now","oldToken","_setLoginToken","resetToOldToken","affectedRecords","err","_clearAllLoginTokens","sendVerificationEmail","verifyEmail","_len2","_key2","_Accounts$_check2faEn3","_Accounts3","t","emailsRecord","addEmail","newEmail","caseInsensitiveRegExp","RegExp","_escapeRegExp","didUpdateOwnEmail","reduce","prev","$addToSet","removeEmail","createUser","ObjectIncluding","_createUserCheckingDuplicates","_len3","_key3","forbidClientAccountCreation","createUserVerifyingEmail","createUserAsync","callback","createIndexAsync","unique","sparse"],"sources":["packages/accounts-password/password_server.js"],"sourcesContent":["import { hash as bcryptHash, compare as bcryptCompare } from 'bcrypt';\nimport { Accounts } from \"meteor/accounts-base\";\n\n// Utility for grabbing user\nconst getUserById = (id, options) => Meteor.users.findOne(id, Accounts._addDefaultFieldSelector(options));\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords.\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = () => Accounts._options.bcryptRounds || 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nconst getPasswordString = password => {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nconst hashPassword = async password => {\n  password = getPasswordString(password);\n  return await bcryptHash(password, Accounts._bcryptRounds());\n};\n\n// Extract the number of rounds used in the specified bcrypt hash.\nconst getRoundsFromBcryptHash = hash => {\n  let rounds;\n  if (hash) {\n    const hashSegments = hash.split('$');\n    if (hashSegments.length > 2) {\n      rounds = parseInt(hashSegments[2], 10);\n    }\n  }\n  return rounds;\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\n// The user parameter needs at least user._id and user.services\nAccounts._checkPasswordUserFields = {_id: 1, services: 1};\n//\nconst checkPasswordAsync = async (user, password) => {\n  const result = {\n    userId: user._id\n  };\n\n  const formattedPassword = getPasswordString(password);\n  const hash = user.services.password.bcrypt;\n  const hashRounds = getRoundsFromBcryptHash(hash);\n\n  if (! await bcryptCompare(formattedPassword, hash)) {\n    result.error = Accounts._handleError(\"Incorrect password\", false);\n  } else if (hash && Accounts._bcryptRounds() != hashRounds) {\n    // The password checks out, but the user's bcrypt hash needs to be updated.\n\n    Meteor.defer(async () => {\n      Meteor.users.update({ _id: user._id }, {\n        $set: {\n          'services.password.bcrypt':\n            await bcryptHash(formattedPassword, Accounts._bcryptRounds())\n        }\n      });\n    });\n  }\n\n  return result;\n};\n\nconst checkPassword = (user, password) => {\n  return Promise.await(checkPasswordAsync(user, password));\n};\n\nAccounts._checkPassword = checkPassword;\nAccounts._checkPasswordAsync =  checkPasswordAsync;\n\n///\n/// LOGIN\n///\n\n\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByUsername =\n  (username, options) => Accounts._findUserByQuery({ username }, options);\n\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @param {Object} [options]\n * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByEmail =\n  (email, options) => Accounts._findUserByQuery({ email }, options);\n\n// XXX maybe this belongs in the check package\nconst NonEmptyString = Match.Where(x => {\n  check(x, String);\n  return x.length > 0;\n});\n\nconst passwordValidator = Match.OneOf(\n  Match.Where(str => Match.test(str, String) && str.length <= Meteor.settings?.packages?.accounts?.passwordMaxLength || 256), {\n    digest: Match.Where(str => Match.test(str, String) && str.length === 64),\n    algorithm: Match.OneOf('sha-256')\n  }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", async options => {\n  if (!options.password)\n    return undefined; // don't handle\n\n  check(options, {\n    user: Accounts._userQueryValidator,\n    password: passwordValidator,\n    code: Match.Optional(NonEmptyString),\n  });\n\n\n  const user = Accounts._findUserByQuery(options.user, {fields: {\n    services: 1,\n    ...Accounts._checkPasswordUserFields,\n  }});\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n\n\n  if (!user.services || !user.services.password ||\n      !user.services.password.bcrypt) {\n    Accounts._handleError(\"User has no password set\");\n  }\n\n  const result = await checkPasswordAsync(user, options.password);\n  // This method is added by the package accounts-2fa\n  // First the login is validated, then the code situation is checked\n  if (\n    !result.error &&\n    Accounts._check2faEnabled?.(user)\n  ) {\n    if (!options.code) {\n      Accounts._handleError('2FA code must be informed', true, 'no-2fa-code');\n    }\n    if (\n      !Accounts._isTokenValid(\n        user.services.twoFactorAuthentication.secret,\n        options.code\n      )\n    ) {\n      Accounts._handleError('Invalid 2FA code', true, 'invalid-2fa-code');\n    }\n  }\n\n  return result;\n});\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\nAccounts.setUsername = (userId, newUsername) => {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n\n  const user = getUserById(userId, {fields: {\n    username: 1,\n  }});\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n\n  const oldUsername = user.username;\n\n  // Perform a case insensitive check for duplicates before update\n  Accounts._checkForCaseInsensitiveDuplicates('username',\n    'Username', newUsername, user._id);\n\n  Meteor.users.update({_id: user._id}, {$set: {username: newUsername}});\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    Accounts._checkForCaseInsensitiveDuplicates('username',\n      'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id}, {$set: {username: oldUsername}});\n    throw ex;\n  }\n};\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\nMeteor.methods({changePassword: async function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId) {\n    throw new Meteor.Error(401, \"Must be logged in\");\n  }\n\n  const user = getUserById(this.userId, {fields: {\n    services: 1,\n    ...Accounts._checkPasswordUserFields,\n  }});\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password || !user.services.password.bcrypt) {\n    Accounts._handleError(\"User has no password set\");\n  }\n\n  const result = await checkPasswordAsync(user, oldPassword);\n  if (result.error) {\n    throw result.error;\n  }\n\n  const hashed = await hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  const currentToken = Accounts._getLoginToken(this.connection.id);\n  Meteor.users.update(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPasswordAsync = async (userId, newPlaintextPassword, options) => {\n  check(userId, String);\n  check(newPlaintextPassword, Match.Where(str => Match.test(str, String) && str.length <= Meteor.settings?.packages?.accounts?.passwordMaxLength || 256));\n  check(options, Match.Maybe({ logout: Boolean }));\n  options = { logout: true , ...options };\n\n  const user = getUserById(userId, {fields: {_id: 1}});\n  if (!user) {\n    throw new Meteor.Error(403, \"User not found\");\n  }\n\n  const update = {\n    $unset: {\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': await hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({_id: user._id}, update);\n};\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPassword = (userId, newPlaintextPassword, options) => {\n  return Promise.await(Accounts.setPasswordAsync(userId, newPlaintextPassword, options));\n};\n\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Utility for plucking addresses from emails\nconst pluckAddresses = (emails = []) => emails.map(email => email.address);\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: options => {\n  check(options, {email: String})\n\n  const user = Accounts.findUserByEmail(options.email, { fields: { emails: 1 } });\n\n  if (!user) {\n    Accounts._handleError(\"User not found\");\n  }\n\n  const emails = pluckAddresses(user.emails);\n  const caseSensitiveEmail = emails.find(\n    email => email.toLowerCase() === options.email.toLowerCase()\n  );\n\n  Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n}});\n\n/**\n * @summary Generates a reset token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the reset token for.\n * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateResetToken = (userId, email, reason, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = getUserById(userId);\n  if (!user) {\n    Accounts._handleError(\"Can't find user\");\n  }\n\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  }\n\n  // make sure we have a valid email\n  if (!email ||\n    !(pluckAddresses(user.emails).includes(email))) {\n    Accounts._handleError(\"No such email for user.\");\n  }\n\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    email,\n    when: new Date()\n  };\n\n  if (reason === 'resetPassword') {\n    tokenRecord.reason = 'reset';\n  } else if (reason === 'enrollAccount') {\n    tokenRecord.reason = 'enroll';\n  } else if (reason) {\n    // fallback so that this function can be used for unknown reasons as well\n    tokenRecord.reason = reason;\n  }\n\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n  // if this method is called from the enroll account work-flow then\n  // store the token record in 'services.password.enroll' db field\n  // else store the token record in in 'services.password.reset' db field\n  if(reason === 'enrollAccount') {\n    Meteor.users.update({_id: user._id}, {\n      $set : {\n        'services.password.enroll': tokenRecord\n      }\n    });\n    // before passing to template, update user object with new token\n    Meteor._ensure(user, 'services', 'password').enroll = tokenRecord;\n  } else {\n    Meteor.users.update({_id: user._id}, {\n      $set : {\n        'services.password.reset': tokenRecord\n      }\n    });\n    // before passing to template, update user object with new token\n    Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n  }\n\n  return {email, user, token};\n};\n\n/**\n * @summary Generates an e-mail verification token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the  e-mail verification token for.\n * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateVerificationToken = (userId, email, extraTokenData) => {\n  // Make sure the user exists, and email is one of their addresses.\n  // Don't limit the fields in the user object since the user is returned\n  // by the function and some other fields might be used elsewhere.\n  const user = getUserById(userId);\n  if (!user) {\n    Accounts._handleError(\"Can't find user\");\n  }\n\n  // pick the first unverified email if we weren't passed an email.\n  if (!email) {\n    const emailRecord = (user.emails || []).find(e => !e.verified);\n    email = (emailRecord || {}).address;\n\n    if (!email) {\n      Accounts._handleError(\"That user has no unverified email addresses.\");\n    }\n  }\n\n  // make sure we have a valid email\n  if (!email ||\n    !(pluckAddresses(user.emails).includes(email))) {\n    Accounts._handleError(\"No such email for user.\");\n  }\n\n  const token = Random.secret();\n  const tokenRecord = {\n    token,\n    // TODO: This should probably be renamed to \"email\" to match reset token record.\n    address: email,\n    when: new Date()\n  };\n\n  if (extraTokenData) {\n    Object.assign(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({_id: user._id}, {$push: {\n    'services.email.verificationTokens': tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  return {email, user, token};\n};\n\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the reset url.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendResetPasswordEmail = (userId, email, extraTokenData, extraParams) => {\n  const {email: realEmail, user, token} =\n    Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n  const url = Accounts.urls.resetPassword(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(`\\nReset password URL: ${url}`);\n  }\n  return {email: realEmail, user, token, url, options};\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the enrollment url.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendEnrollmentEmail = (userId, email, extraTokenData, extraParams) => {\n  const {email: realEmail, user, token} =\n    Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n  const url = Accounts.urls.enrollAccount(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(`\\nEnrollment email URL: ${url}`);\n  }\n  return {email: realEmail, user, token, url, options};\n};\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({resetPassword: async function (...args) {\n  const token = args[0];\n  const newPassword = args[1];\n  return await Accounts._loginMethod(\n    this,\n    \"resetPassword\",\n    args,\n    \"password\",\n    async () => {\n      check(token, String);\n      check(newPassword, passwordValidator);\n\n      let user = Meteor.users.findOne(\n        {\"services.password.reset.token\": token},\n        {fields: {\n          services: 1,\n          emails: 1,\n        }}\n      );\n\n      let isEnroll = false;\n      // if token is in services.password.reset db field implies\n      // this method is was not called from enroll account workflow\n      // else this method is called from enroll account workflow\n      if(!user) {\n        user = Meteor.users.findOne(\n          {\"services.password.enroll.token\": token},\n          {fields: {\n            services: 1,\n            emails: 1,\n          }}\n        );\n        isEnroll = true;\n      }\n      if (!user) {\n        throw new Meteor.Error(403, \"Token expired\");\n      }\n      let tokenRecord = {};\n      if(isEnroll) {\n        tokenRecord = user.services.password.enroll;\n      } else {\n        tokenRecord = user.services.password.reset;\n      }\n      const { when, email } = tokenRecord;\n      let tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n      if (isEnroll) {\n        tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n      }\n      const currentTimeMs = Date.now();\n      if ((currentTimeMs - when) > tokenLifetimeMs)\n        throw new Meteor.Error(403, \"Token expired\");\n      if (!(pluckAddresses(user.emails).includes(email)))\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n\n      const hashed = await hashPassword(newPassword);\n\n      // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n      const oldToken = Accounts._getLoginToken(this.connection.id);\n      Accounts._setLoginToken(user._id, this.connection, null);\n      const resetToOldToken = () =>\n        Accounts._setLoginToken(user._id, this.connection, oldToken);\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token or enroll token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        let affectedRecords = {};\n        // if reason is enroll then check services.password.enroll.token field for affected records\n        if(isEnroll) {\n          affectedRecords = Meteor.users.update(\n            {\n              _id: user._id,\n              'emails.address': email,\n              'services.password.enroll.token': token\n            },\n            {$set: {'services.password.bcrypt': hashed,\n                    'emails.$.verified': true},\n              $unset: {'services.password.enroll': 1 }});\n        } else {\n          affectedRecords = Meteor.users.update(\n            {\n              _id: user._id,\n              'emails.address': email,\n              'services.password.reset.token': token\n            },\n            {$set: {'services.password.bcrypt': hashed,\n                    'emails.$.verified': true},\n              $unset: {'services.password.reset': 1 }});\n        }\n        if (affectedRecords !== 1)\n          return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      }\n\n      // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n      Accounts._clearAllLoginTokens(user._id);\n\n      if (Accounts._check2faEnabled?.(user)) {\n        return {\n          userId: user._id,\n          error: Accounts._handleError(\n            'Changed password, but user not logged in because 2FA is enabled',\n            false,\n            '2fa-enabled'\n          ),\n        };\n      }\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @param {Object} [extraParams] Optional additional params to be added to the verification url.\n *\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendVerificationEmail = (userId, email, extraTokenData, extraParams) => {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  const {email: realEmail, user, token} =\n    Accounts.generateVerificationToken(userId, email, extraTokenData);\n  const url = Accounts.urls.verifyEmail(token, extraParams);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n  Email.send(options);\n  if (Meteor.isDevelopment) {\n    console.log(`\\nVerification email URL: ${url}`);\n  }\n  return {email: realEmail, user, token, url, options};\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({verifyEmail: async function (...args) {\n  const token = args[0];\n  return await Accounts._loginMethod(\n    this,\n    \"verifyEmail\",\n    args,\n    \"password\",\n    () => {\n      check(token, String);\n\n      const user = Meteor.users.findOne(\n        {'services.email.verificationTokens.token': token},\n        {fields: {\n          services: 1,\n          emails: 1,\n        }}\n      );\n      if (!user)\n        throw new Meteor.Error(403, \"Verify email link expired\");\n\n        const tokenRecord = user.services.email.verificationTokens.find(\n          t => t.token == token\n        );\n      if (!tokenRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n\n      const emailsRecord = user.emails.find(\n        e => e.address == tokenRecord.address\n      );\n      if (!emailsRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n      // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n      Meteor.users.update(\n        {_id: user._id,\n         'emails.address': tokenRecord.address},\n        {$set: {'emails.$.verified': true},\n         $pull: {'services.email.verificationTokens': {address: tokenRecord.address}}});\n\n      if (Accounts._check2faEnabled?.(user)) {\n        return {\n          userId: user._id,\n          error: Accounts._handleError(\n            'Email verified, but user not logged in because 2FA is enabled',\n            false,\n            '2fa-enabled'\n          ),\n        };\n      }\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\nAccounts.addEmail = (userId, newEmail, verified) => {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (verified === void 0) {\n    verified = false;\n  }\n\n  const user = getUserById(userId, {fields: {emails: 1}});\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  const caseInsensitiveRegExp =\n    new RegExp(`^${Meteor._escapeRegExp(newEmail)}$`, 'i');\n\n  const didUpdateOwnEmail = (user.emails || []).reduce(\n    (prev, email) => {\n      if (caseInsensitiveRegExp.test(email.address)) {\n        Meteor.users.update({\n          _id: user._id,\n          'emails.address': email.address\n        }, {$set: {\n          'emails.$.address': newEmail,\n          'emails.$.verified': verified\n        }});\n        return true;\n      } else {\n        return prev;\n      }\n    },\n    false\n  );\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  Accounts._checkForCaseInsensitiveDuplicates('emails.address',\n    'Email', newEmail, user._id);\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    Accounts._checkForCaseInsensitiveDuplicates('emails.address',\n      'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id},\n      {$pull: {emails: {address: newEmail}}});\n    throw ex;\n  }\n}\n\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\nAccounts.removeEmail = (userId, email) => {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n\n  const user = getUserById(userId, {fields: {_id: 1}});\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Meteor.users.update({_id: user._id},\n    {$pull: {emails: {address: email}}});\n}\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nconst createUser = async options => {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n\n  const { username, email, password } = options;\n  if (!username && !email)\n    throw new Meteor.Error(400, \"Need to set a username or email\");\n\n  const user = {services: {}};\n  if (password) {\n    const hashed = await hashPassword(password);\n    user.services.password = { bcrypt: hashed };\n  }\n\n  return Accounts._createUserCheckingDuplicates({ user, email, username, options });\n};\n\n// method for create user. Requests come from the client.\nMeteor.methods({createUser: async function (...args) {\n  const options = args[0];\n  return await Accounts._loginMethod(\n    this,\n    \"createUser\",\n    args,\n    \"password\",\n    async () => {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation)\n        return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n\n      const userId = await Accounts.createUserVerifyingEmail(options);\n\n      // client gets logged in as the new user afterwards.\n      return {userId: userId};\n    }\n  );\n}});\n\n/**\n * @summary Creates an user and sends an email if `options.email` is informed.\n * Then if the `sendVerificationEmail` option from the `Accounts` package is\n * enabled, you'll send a verification email if `options.password` is informed,\n * otherwise you'll send an enrollment email.\n * @locus Server\n * @param {Object} options The options object to be passed down when creating\n * the user\n * @param {String} options.username A unique name for this user.\n * @param {String} options.email The user's email address.\n * @param {String} options.password The user's password. This is __not__ sent in plain text over the wire.\n * @param {Object} options.profile The user's profile, typically including the `name` field.\n * @importFromPackage accounts-base\n * */\nAccounts.createUserVerifyingEmail = async (options) => {\n  options = { ...options };\n  // Create user. result contains id and token.\n  const userId = await createUser(options);\n  // safety belt. createUser is supposed to throw on error. send 500 error\n  // instead of sending a verification email with empty userid.\n  if (! userId)\n    throw new Error(\"createUser failed to insert new user\");\n\n  // If `Accounts._options.sendVerificationEmail` is set, register\n  // a token to verify the user's primary email, and send it to\n  // that address.\n  if (options.email && Accounts._options.sendVerificationEmail) {\n    if (options.password) {\n      Accounts.sendVerificationEmail(userId, options.email);\n    } else {\n      Accounts.sendEnrollmentEmail(userId, options.email);\n    }\n  }\n\n  return userId;\n};\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns Promise<userId> or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\n\nAccounts.createUserAsync = async (options, callback) => {\n  options = { ...options };\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n};\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\n\nAccounts.createUser = (options, callback) => {\n  return Promise.await(Accounts.createUserAsync(options, callback));\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users.createIndexAsync('services.email.verificationTokens.token',\n                              { unique: true, sparse: true });\nMeteor.users.createIndexAsync('services.password.reset.token',\n                              { unique: true, sparse: true });\nMeteor.users.createIndexAsync('services.password.enroll.token',\n                              { unique: true, sparse: true });\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"a1e5fafbb1219238856814717a5d29a8d38d3dd9"}
