{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/tracer/tracer.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/montiapm:agent/lib/tracer/tracer.js","filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/tracer/tracer.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/phatca/Documents/GitHub/professor-trading-card/app","root":"/Users/phatca/Documents/GitHub/professor-trading-card/app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/tracer/tracer.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/montiapm:agent/lib/tracer/tracer.js"}},"code":"module.export({\n  Tracer: () => Tracer\n});\nlet _;\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n}, 0);\nlet objectHasData;\nmodule.link(\"../common/utils\", {\n  objectHasData(v) {\n    objectHasData = v;\n  }\n}, 1);\nlet CreateUserStack, DefaultUniqueId;\nmodule.link(\"../utils\", {\n  CreateUserStack(v) {\n    CreateUserStack = v;\n  },\n  DefaultUniqueId(v) {\n    DefaultUniqueId = v;\n  }\n}, 2);\nlet Ntp;\nmodule.link(\"../ntp\", {\n  Ntp(v) {\n    Ntp = v;\n  }\n}, 3);\nlet eventLogger = Npm.require('debug')('kadira:tracer');\nlet REPETITIVE_EVENTS = {\n  db: true,\n  http: true,\n  email: true,\n  wait: true,\n  async: true,\n  custom: true,\n  fs: true\n};\nlet TRACE_TYPES = ['sub', 'method', 'http'];\nlet MAX_TRACE_EVENTS = 1500;\nconst Tracer = function () {\n  this._filters = [];\n  this._filterFields = ['password'];\n  this.maxArrayItemsToFilter = 20;\n};\n// In the future, we might wan't to track inner fiber events too.\n// Then we can't serialize the object with methods\n// That's why we use this method of returning the data\nTracer.prototype.start = function (name, type) {\n  let {\n    sessionId,\n    msgId,\n    userId\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // for backward compatibility\n  if (typeof name === 'object' && typeof type === 'object') {\n    let session = name;\n    let msg = type;\n    sessionId = session.id;\n    msgId = msg.id;\n    userId = session.userId;\n    if (msg.msg === 'method') {\n      type = 'method';\n      name = msg.method;\n    } else if (msg.msg === 'sub') {\n      type = 'sub';\n      name = msg.name;\n    } else {\n      return null;\n    }\n  }\n  if (TRACE_TYPES.indexOf(type) === -1) {\n    console.warn(\"Monti APM: unknown trace type \\\"\".concat(type, \"\\\"\"));\n    return null;\n  }\n  const traceInfo = {\n    _id: \"\".concat(sessionId, \"::\").concat(msgId || DefaultUniqueId.get()),\n    type,\n    name,\n    session: sessionId,\n    id: msgId,\n    events: [],\n    userId\n  };\n  return traceInfo;\n};\nTracer.prototype.event = function (traceInfo, type, data, metaData) {\n  // do not allow to proceed, if already completed or errored\n  let lastEvent = this.getLastEvent(traceInfo);\n  if (\n  // trace completed but has not been processed\n  lastEvent && ['complete', 'error'].indexOf(lastEvent.type) >= 0 ||\n  // trace completed and processed.\n  traceInfo.isEventsProcessed) {\n    return false;\n  }\n  let event = {\n    type,\n    at: Ntp._now(),\n    endAt: null,\n    nested: []\n  };\n\n  // special handling for events that are not repetitive\n  if (!REPETITIVE_EVENTS[type]) {\n    event.endAt = event.at;\n  }\n  if (data) {\n    let info = _.pick(traceInfo, 'type', 'name');\n    event.data = this._applyFilters(type, data, info, 'start');\n  }\n  if (metaData && metaData.name) {\n    event.name = metaData.name;\n  }\n  if (Kadira.options.eventStackTrace) {\n    event.stack = CreateUserStack();\n  }\n  eventLogger('%s %s', type, traceInfo._id);\n  if (lastEvent && !lastEvent.endAt) {\n    if (!lastEvent.nested) {\n      console.error('Monti: invalid trace. Please share the trace below at');\n      console.error('Monti: https://github.com/monti-apm/monti-apm-agent/issues/14');\n      console.dir(traceInfo, {\n        depth: 10\n      });\n    }\n    let lastNested = lastEvent.nested[lastEvent.nested.length - 1];\n\n    // Only nest one level\n    if (!lastNested || lastNested.endAt) {\n      lastEvent.nested.push(event);\n      return event;\n    }\n    return false;\n  }\n  traceInfo.events.push(event);\n  return event;\n};\nTracer.prototype.eventEnd = function (traceInfo, event, data) {\n  if (event.endAt) {\n    // Event already ended or is not a repititive event\n    return false;\n  }\n  event.endAt = Ntp._now();\n  if (data) {\n    let info = _.pick(traceInfo, 'type', 'name');\n    event.data = Object.assign(event.data || {}, this._applyFilters(\"\".concat(event.type, \"end\"), data, info, 'end'));\n  }\n  eventLogger('%s %s', \"\".concat(event.type, \"end\"), traceInfo._id);\n  return true;\n};\nTracer.prototype.getLastEvent = function (traceInfo) {\n  return traceInfo.events[traceInfo.events.length - 1];\n};\nTracer.prototype.endLastEvent = function (traceInfo) {\n  let lastEvent = this.getLastEvent(traceInfo);\n  if (!lastEvent.endAt) {\n    this.eventEnd(traceInfo, lastEvent);\n    lastEvent.forcedEnd = true;\n    return true;\n  }\n  return false;\n};\n\n// Most of the time, all the nested events are async\n// which is not helpful. This returns true if\n// there are nested events other than async.\nTracer.prototype._hasUsefulNested = function (event) {\n  return event.nested && event.nested.length && !event.nested.every(e => e.type === 'async');\n};\nTracer.prototype.buildEvent = function (event) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let trace = arguments.length > 2 ? arguments[2] : undefined;\n  let elapsedTimeForEvent = event.endAt - event.at;\n  let builtEvent = [event.type];\n  let nested = [];\n  builtEvent.push(elapsedTimeForEvent);\n  builtEvent.push(event.data || {});\n  if (this._hasUsefulNested(event)) {\n    let prevEnd = event.at;\n    for (let i = 0; i < event.nested.length; i++) {\n      let nestedEvent = event.nested[i];\n      if (!nestedEvent.endAt) {\n        this.eventEnd(trace, nestedEvent);\n        nestedEvent.forcedEnd = true;\n      }\n      let computeTime = nestedEvent.at - prevEnd;\n      if (computeTime > 0) {\n        nested.push(['compute', computeTime]);\n      }\n      nested.push(this.buildEvent(nestedEvent, depth + 1, trace));\n      prevEnd = nestedEvent.endAt;\n    }\n  }\n  if (nested.length || event.stack || event.forcedEnd || event.name) {\n    builtEvent.push({\n      stack: event.stack,\n      nested: nested.length ? nested : undefined,\n      forcedEnd: event.forcedEnd,\n      name: event.name\n    });\n  }\n  return builtEvent;\n};\nTracer.prototype.buildTrace = function (traceInfo) {\n  let firstEvent = traceInfo.events[0];\n  let lastEvent = traceInfo.events[traceInfo.events.length - 1];\n  let processedEvents = [];\n  if (firstEvent.type !== 'start') {\n    console.warn('Monti APM: trace has not started yet');\n    return null;\n  } else if (lastEvent.type !== 'complete' && lastEvent.type !== 'error') {\n    // trace is not completed or errored yet\n    console.warn('Monti APM: trace has not completed or errored yet');\n    return null;\n  }\n  // build the metrics\n  traceInfo.errored = lastEvent.type === 'error';\n  traceInfo.at = firstEvent.at;\n  let metrics = {\n    total: lastEvent.at - firstEvent.at\n  };\n  let totalNonCompute = 0;\n  firstEvent = ['start', 0];\n  if (traceInfo.events[0].data) {\n    firstEvent.push(traceInfo.events[0].data);\n  }\n  processedEvents.push(firstEvent);\n  let computeTime;\n  for (let lc = 1; lc < traceInfo.events.length - 1; lc += 1) {\n    let prevEvent = traceInfo.events[lc - 1];\n    let event = traceInfo.events[lc];\n    if (!event.endAt) {\n      console.error('Monti APM: no end event for type: ', event.type);\n      return null;\n    }\n    computeTime = event.at - prevEvent.endAt;\n    if (computeTime > 0) {\n      processedEvents.push(['compute', computeTime]);\n    }\n    let builtEvent = this.buildEvent(event, 0, traceInfo);\n    processedEvents.push(builtEvent);\n    metrics[event.type] = metrics[event.type] || 0;\n    metrics[event.type] += builtEvent[1];\n    totalNonCompute += builtEvent[1];\n  }\n  computeTime = lastEvent.at - traceInfo.events[traceInfo.events.length - 2].endAt;\n  if (computeTime > 0) {\n    processedEvents.push(['compute', computeTime]);\n  }\n  let lastEventData = [lastEvent.type, 0];\n  if (lastEvent.data) {\n    lastEventData.push(lastEvent.data);\n  }\n  processedEvents.push(lastEventData);\n  if (processedEvents.length > MAX_TRACE_EVENTS) {\n    const removeCount = processedEvents.length - MAX_TRACE_EVENTS;\n    processedEvents.splice(MAX_TRACE_EVENTS, removeCount);\n  }\n  metrics.compute = metrics.total - totalNonCompute;\n  traceInfo.metrics = metrics;\n  traceInfo.events = processedEvents;\n  traceInfo.isEventsProcessed = true;\n  return traceInfo;\n};\n\n/**\n * There are two formats for traces. While the method/publication is running, the trace is in the object format.\n * This is easier to work with, but takes more space to store. After the trace is complete (either finished or errored),\n * it is built which among other things converts the events to the array format.\n *\n * The key difference of `optimizeEvent` and `optimizeEvents` is that they do not mutate the original events.\n *\n * @param {Object} objectEvent Expanded object event.\n *\n * @returns {Array} Array notation of the event optimized for transport\n */\nTracer.prototype.optimizeEvent = function (objectEvent) {\n  let {\n    at,\n    endAt,\n    stack,\n    nested = [],\n    forcedEnd,\n    name,\n    type,\n    data\n  } = objectEvent;\n  if (!endAt) {\n    endAt = Ntp._now();\n    forcedEnd = true;\n  }\n  let duration = at && endAt ? endAt - at : 0;\n  const optimizedNestedEvents = this._hasUsefulNested(objectEvent) ? this.optimizeEvents(nested) : undefined;\n  const optimizedEvent = [type, duration, data || {}];\n  const extraInfo = {\n    stack,\n    forcedEnd,\n    name,\n    nested: optimizedNestedEvents\n  };\n  if (objectHasData(extraInfo)) {\n    optimizedEvent.push(extraInfo);\n  }\n  return optimizedEvent;\n};\nTracer.prototype.optimizeEvents = function (events) {\n  if (!events) {\n    return [];\n  }\n  const optimizedEvents = [];\n  let prevEvent = {};\n  events.forEach(event => {\n    if (prevEvent.endAt && event.at) {\n      const computeTime = event.at - prevEvent.endAt;\n      if (computeTime > 0) {\n        optimizedEvents.push(['compute', computeTime]);\n      }\n    }\n    optimizedEvents.push(this.optimizeEvent(event));\n    prevEvent = event;\n  });\n  return optimizedEvents;\n};\nTracer.prototype.addFilter = function (filterFn) {\n  this._filters.push(filterFn);\n};\nTracer.prototype.redactField = function (field) {\n  this._filterFields.push(field);\n};\nTracer.prototype._applyFilters = function (eventType, data, info) {\n  this._filters.forEach(function (filterFn) {\n    data = filterFn(eventType, _.clone(data), info);\n  });\n  return data;\n};\nTracer.prototype._applyObjectFilters = function (toFilter) {\n  const filterObject = obj => {\n    let cloned;\n    this._filterFields.forEach(function (field) {\n      if (field in obj) {\n        cloned = cloned || Object.assign({}, obj);\n        cloned[field] = 'Monti: redacted';\n      }\n    });\n    return cloned;\n  };\n  if (Array.isArray(toFilter)) {\n    let cloned;\n    // There could be thousands or more items in the array, and this usually runs\n    // before the data is validated. For performance reasons we limit how\n    // many to check\n    let length = Math.min(toFilter.length, this.maxArrayItemsToFilter);\n    for (let i = 0; i < length; i++) {\n      if (typeof toFilter[i] === 'object' && toFilter[i] !== null) {\n        let result = filterObject(toFilter[i]);\n        if (result) {\n          cloned = cloned || [...toFilter];\n          cloned[i] = result;\n        }\n      }\n    }\n    return cloned || toFilter;\n  }\n  return filterObject(toFilter) || toFilter;\n};\nKadira.tracer = new Tracer();\n// need to expose Tracer to provide default set of filters\nKadira.Tracer = Tracer;","map":{"version":3,"names":["module","export","Tracer","_","link","v","objectHasData","CreateUserStack","DefaultUniqueId","Ntp","eventLogger","Npm","require","REPETITIVE_EVENTS","db","http","email","wait","async","custom","fs","TRACE_TYPES","MAX_TRACE_EVENTS","_filters","_filterFields","maxArrayItemsToFilter","prototype","start","name","type","sessionId","msgId","userId","arguments","length","undefined","session","msg","id","method","indexOf","console","warn","concat","traceInfo","_id","get","events","event","data","metaData","lastEvent","getLastEvent","isEventsProcessed","at","_now","endAt","nested","info","pick","_applyFilters","Kadira","options","eventStackTrace","stack","error","dir","depth","lastNested","push","eventEnd","Object","assign","endLastEvent","forcedEnd","_hasUsefulNested","every","e","buildEvent","trace","elapsedTimeForEvent","builtEvent","prevEnd","i","nestedEvent","computeTime","buildTrace","firstEvent","processedEvents","errored","metrics","total","totalNonCompute","lc","prevEvent","lastEventData","removeCount","splice","compute","optimizeEvent","objectEvent","duration","optimizedNestedEvents","optimizeEvents","optimizedEvent","extraInfo","optimizedEvents","forEach","addFilter","filterFn","redactField","field","eventType","clone","_applyObjectFilters","toFilter","filterObject","obj","cloned","Array","isArray","Math","min","result","tracer"],"sources":["packages/montiapm:agent/lib/tracer/tracer.js"],"sourcesContent":["import { _ } from 'meteor/underscore';\nimport { objectHasData } from '../common/utils';\nimport { CreateUserStack, DefaultUniqueId } from '../utils';\nimport { Ntp } from '../ntp';\n\n\nlet eventLogger = Npm.require('debug')('kadira:tracer');\n\nlet REPETITIVE_EVENTS = {db: true, http: true, email: true, wait: true, async: true, custom: true, fs: true};\nlet TRACE_TYPES = ['sub', 'method', 'http'];\nlet MAX_TRACE_EVENTS = 1500;\n\n\nexport const Tracer = function () {\n  this._filters = [];\n  this._filterFields = ['password'];\n  this.maxArrayItemsToFilter = 20;\n};\n\n// In the future, we might wan't to track inner fiber events too.\n// Then we can't serialize the object with methods\n// That's why we use this method of returning the data\nTracer.prototype.start = function (name, type, {\n  sessionId,\n  msgId,\n  userId\n} = {}) {\n  // for backward compatibility\n  if (typeof name === 'object' && typeof type === 'object') {\n    let session = name;\n    let msg = type;\n    sessionId = session.id;\n    msgId = msg.id;\n    userId = session.userId;\n\n    if (msg.msg === 'method') {\n      type = 'method';\n      name = msg.method;\n    } else if (msg.msg === 'sub') {\n      type = 'sub';\n      name = msg.name;\n    } else {\n      return null;\n    }\n  }\n\n  if (TRACE_TYPES.indexOf(type) === -1) {\n    console.warn(`Monti APM: unknown trace type \"${type}\"`);\n    return null;\n  }\n\n  const traceInfo = {\n    _id: `${sessionId}::${msgId || DefaultUniqueId.get()}`,\n    type,\n    name,\n    session: sessionId,\n    id: msgId,\n    events: [],\n    userId,\n  };\n\n  return traceInfo;\n};\n\nTracer.prototype.event = function (traceInfo, type, data, metaData) {\n  // do not allow to proceed, if already completed or errored\n  let lastEvent = this.getLastEvent(traceInfo);\n\n  if (\n    // trace completed but has not been processed\n    lastEvent &&\n    ['complete', 'error'].indexOf(lastEvent.type) >= 0 ||\n    // trace completed and processed.\n    traceInfo.isEventsProcessed\n  ) {\n    return false;\n  }\n\n  let event = {\n    type,\n    at: Ntp._now(),\n    endAt: null,\n    nested: [],\n  };\n\n  // special handling for events that are not repetitive\n  if (!REPETITIVE_EVENTS[type]) {\n    event.endAt = event.at;\n  }\n\n  if (data) {\n    let info = _.pick(traceInfo, 'type', 'name');\n    event.data = this._applyFilters(type, data, info, 'start');\n  }\n\n  if (metaData && metaData.name) {\n    event.name = metaData.name;\n  }\n\n  if (Kadira.options.eventStackTrace) {\n    event.stack = CreateUserStack();\n  }\n\n  eventLogger('%s %s', type, traceInfo._id);\n\n  if (lastEvent && !lastEvent.endAt) {\n    if (!lastEvent.nested) {\n      console.error('Monti: invalid trace. Please share the trace below at');\n      console.error('Monti: https://github.com/monti-apm/monti-apm-agent/issues/14');\n      console.dir(traceInfo, { depth: 10 });\n    }\n    let lastNested = lastEvent.nested[lastEvent.nested.length - 1];\n\n    // Only nest one level\n    if (!lastNested || lastNested.endAt) {\n      lastEvent.nested.push(event);\n      return event;\n    }\n\n    return false;\n  }\n\n  traceInfo.events.push(event);\n\n  return event;\n};\n\nTracer.prototype.eventEnd = function (traceInfo, event, data) {\n  if (event.endAt) {\n    // Event already ended or is not a repititive event\n    return false;\n  }\n\n  event.endAt = Ntp._now();\n\n  if (data) {\n    let info = _.pick(traceInfo, 'type', 'name');\n    event.data = Object.assign(\n      event.data || {},\n      this._applyFilters(`${event.type}end`, data, info, 'end')\n    );\n  }\n  eventLogger('%s %s', `${event.type}end`, traceInfo._id);\n\n  return true;\n};\n\nTracer.prototype.getLastEvent = function (traceInfo) {\n  return traceInfo.events[traceInfo.events.length - 1];\n};\n\nTracer.prototype.endLastEvent = function (traceInfo) {\n  let lastEvent = this.getLastEvent(traceInfo);\n\n  if (!lastEvent.endAt) {\n    this.eventEnd(traceInfo, lastEvent);\n    lastEvent.forcedEnd = true;\n    return true;\n  }\n  return false;\n};\n\n// Most of the time, all the nested events are async\n// which is not helpful. This returns true if\n// there are nested events other than async.\nTracer.prototype._hasUsefulNested = function (event) {\n  return event.nested &&\n    event.nested.length &&\n    !event.nested.every(e => e.type === 'async');\n};\n\nTracer.prototype.buildEvent = function (event, depth = 0, trace) {\n  let elapsedTimeForEvent = event.endAt - event.at;\n  let builtEvent = [event.type];\n  let nested = [];\n\n  builtEvent.push(elapsedTimeForEvent);\n  builtEvent.push(event.data || {});\n\n  if (this._hasUsefulNested(event)) {\n    let prevEnd = event.at;\n    for (let i = 0; i < event.nested.length; i++) {\n      let nestedEvent = event.nested[i];\n      if (!nestedEvent.endAt) {\n        this.eventEnd(trace, nestedEvent);\n        nestedEvent.forcedEnd = true;\n      }\n\n      let computeTime = nestedEvent.at - prevEnd;\n      if (computeTime > 0) {\n        nested.push(['compute', computeTime]);\n      }\n\n      nested.push(this.buildEvent(nestedEvent, depth + 1, trace));\n      prevEnd = nestedEvent.endAt;\n    }\n  }\n\n\n  if (\n    nested.length ||\n    event.stack ||\n    event.forcedEnd ||\n    event.name\n  ) {\n    builtEvent.push({\n      stack: event.stack,\n      nested: nested.length ? nested : undefined,\n      forcedEnd: event.forcedEnd,\n      name: event.name\n    });\n  }\n\n  return builtEvent;\n};\n\nTracer.prototype.buildTrace = function (traceInfo) {\n  let firstEvent = traceInfo.events[0];\n  let lastEvent = traceInfo.events[traceInfo.events.length - 1];\n  let processedEvents = [];\n\n  if (firstEvent.type !== 'start') {\n    console.warn('Monti APM: trace has not started yet');\n    return null;\n  } else if (lastEvent.type !== 'complete' && lastEvent.type !== 'error') {\n    // trace is not completed or errored yet\n    console.warn('Monti APM: trace has not completed or errored yet');\n    return null;\n  }\n  // build the metrics\n  traceInfo.errored = lastEvent.type === 'error';\n  traceInfo.at = firstEvent.at;\n\n  let metrics = {\n    total: lastEvent.at - firstEvent.at,\n  };\n\n  let totalNonCompute = 0;\n\n  firstEvent = ['start', 0];\n  if (traceInfo.events[0].data) {\n    firstEvent.push(traceInfo.events[0].data);\n  }\n  processedEvents.push(firstEvent);\n\n  let computeTime;\n\n  for (let lc = 1; lc < traceInfo.events.length - 1; lc += 1) {\n    let prevEvent = traceInfo.events[lc - 1];\n    let event = traceInfo.events[lc];\n\n    if (!event.endAt) {\n      console.error('Monti APM: no end event for type: ', event.type);\n      return null;\n    }\n\n    computeTime = event.at - prevEvent.endAt;\n    if (computeTime > 0) {\n      processedEvents.push(['compute', computeTime]);\n    }\n    let builtEvent = this.buildEvent(event, 0, traceInfo);\n    processedEvents.push(builtEvent);\n\n    metrics[event.type] = metrics[event.type] || 0;\n    metrics[event.type] += builtEvent[1];\n    totalNonCompute += builtEvent[1];\n  }\n\n\n  computeTime = lastEvent.at - traceInfo.events[traceInfo.events.length - 2].endAt;\n\n  if (computeTime > 0) {\n    processedEvents.push(['compute', computeTime]);\n  }\n\n  let lastEventData = [lastEvent.type, 0];\n  if (lastEvent.data) {\n    lastEventData.push(lastEvent.data);\n  }\n  processedEvents.push(lastEventData);\n\n  if (processedEvents.length > MAX_TRACE_EVENTS) {\n    const removeCount = processedEvents.length - MAX_TRACE_EVENTS;\n    processedEvents.splice(MAX_TRACE_EVENTS, removeCount);\n  }\n\n  metrics.compute = metrics.total - totalNonCompute;\n  traceInfo.metrics = metrics;\n  traceInfo.events = processedEvents;\n  traceInfo.isEventsProcessed = true;\n  return traceInfo;\n};\n\n/**\n * There are two formats for traces. While the method/publication is running, the trace is in the object format.\n * This is easier to work with, but takes more space to store. After the trace is complete (either finished or errored),\n * it is built which among other things converts the events to the array format.\n *\n * The key difference of `optimizeEvent` and `optimizeEvents` is that they do not mutate the original events.\n *\n * @param {Object} objectEvent Expanded object event.\n *\n * @returns {Array} Array notation of the event optimized for transport\n */\nTracer.prototype.optimizeEvent = function (objectEvent) {\n  let {at, endAt, stack, nested = [], forcedEnd, name, type, data} = objectEvent;\n\n  if (!endAt) {\n    endAt = Ntp._now();\n    forcedEnd = true;\n  }\n\n  let duration = at && endAt ? endAt - at : 0;\n\n  const optimizedNestedEvents = this._hasUsefulNested(objectEvent) ? this.optimizeEvents(nested) : undefined;\n\n  const optimizedEvent = [type, duration, data || {}];\n\n  const extraInfo = {\n    stack,\n    forcedEnd,\n    name,\n    nested: optimizedNestedEvents\n  };\n\n  if (objectHasData(extraInfo)) {\n    optimizedEvent.push(extraInfo);\n  }\n\n  return optimizedEvent;\n};\n\nTracer.prototype.optimizeEvents = function (events) {\n  if (!events) {\n    return [];\n  }\n\n  const optimizedEvents = [];\n\n  let prevEvent = {};\n\n  events.forEach((event) => {\n    if (prevEvent.endAt && event.at) {\n      const computeTime = event.at - prevEvent.endAt;\n\n      if (computeTime > 0) {\n        optimizedEvents.push(['compute', computeTime]);\n      }\n    }\n\n    optimizedEvents.push(this.optimizeEvent(event));\n\n    prevEvent = event;\n  });\n\n  return optimizedEvents;\n};\n\nTracer.prototype.addFilter = function (filterFn) {\n  this._filters.push(filterFn);\n};\n\nTracer.prototype.redactField = function (field) {\n  this._filterFields.push(field);\n};\n\nTracer.prototype._applyFilters = function (eventType, data, info) {\n  this._filters.forEach(function (filterFn) {\n    data = filterFn(eventType, _.clone(data), info);\n  });\n\n  return data;\n};\n\nTracer.prototype._applyObjectFilters = function (toFilter) {\n  const filterObject = (obj) => {\n    let cloned;\n    this._filterFields.forEach(function (field) {\n      if (field in obj) {\n        cloned = cloned || Object.assign({}, obj);\n        cloned[field] = 'Monti: redacted';\n      }\n    });\n\n    return cloned;\n  };\n\n  if (Array.isArray(toFilter)) {\n    let cloned;\n    // There could be thousands or more items in the array, and this usually runs\n    // before the data is validated. For performance reasons we limit how\n    // many to check\n    let length = Math.min(toFilter.length, this.maxArrayItemsToFilter);\n    for (let i = 0; i < length; i++) {\n      if (typeof toFilter[i] === 'object' && toFilter[i] !== null) {\n        let result = filterObject(toFilter[i]);\n        if (result) {\n          cloned = cloned || [...toFilter];\n          cloned[i] = result;\n        }\n      }\n    }\n\n    return cloned || toFilter;\n  }\n\n  return filterObject(toFilter) || toFilter;\n};\n\nKadira.tracer = new Tracer();\n// need to expose Tracer to provide default set of filters\nKadira.Tracer = Tracer;\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"c5ce90e9e9ce1617a159285225833a08909ae23b"}
