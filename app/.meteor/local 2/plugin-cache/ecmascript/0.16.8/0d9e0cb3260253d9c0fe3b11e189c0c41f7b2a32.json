{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/models/pubsub.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/montiapm:agent/lib/models/pubsub.js","filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/models/pubsub.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/phatca/Documents/GitHub/professor-trading-card/app","root":"/Users/phatca/Documents/GitHub/professor-trading-card/app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/models/pubsub.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/montiapm:agent/lib/models/pubsub.js"}},"code":"module.export({\n  PubsubModel: () => PubsubModel\n});\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n}, 0);\nlet _;\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n}, 1);\nlet KadiraModel;\nmodule.link(\"./0model\", {\n  KadiraModel(v) {\n    KadiraModel = v;\n  }\n}, 2);\nlet TracerStore;\nmodule.link(\"../tracer/tracer_store\", {\n  TracerStore(v) {\n    TracerStore = v;\n  }\n}, 3);\nlet Ntp;\nmodule.link(\"../ntp\", {\n  Ntp(v) {\n    Ntp = v;\n  }\n}, 4);\nlet countKeys, getProperty, iterate;\nmodule.link(\"../utils\", {\n  countKeys(v) {\n    countKeys = v;\n  },\n  getProperty(v) {\n    getProperty = v;\n  },\n  iterate(v) {\n    iterate = v;\n  }\n}, 5);\nconst logger = Npm.require('debug')('kadira:pubsub');\nconst {\n  DDSketch\n} = require('monti-apm-sketches-js');\nfunction PubsubModel() {\n  this.metricsByMinute = Object.create(null);\n  this.subscriptions = Object.create(null);\n  this.tracerStore = new TracerStore({\n    // process traces every minute\n    interval: 1000 * 60,\n    // for 30 minutes\n    maxTotalPoints: 30,\n    // always trace for every 5 minutes\n    archiveEvery: 5\n  });\n  this.tracerStore.start();\n}\nPubsubModel.prototype._trackSub = function (session, msg) {\n  logger('SUB:', session.id, msg.id, msg.name, msg.params);\n  let publication = this._getPublicationName(msg.name);\n  let timestamp = Ntp._now();\n  let metrics = this._getMetrics(timestamp, publication);\n  metrics.subs++;\n  this.subscriptions[msg.id] = {\n    // We use localTime here, because when we used synedTime we might get\n    // minus or more than we've expected\n    //   (before serverTime diff changed overtime)\n    startTime: timestamp,\n    publication,\n    params: msg.params,\n    id: msg.id\n  };\n\n  // set session startedTime\n  session._startTime = session._startTime || timestamp;\n};\n_.extend(PubsubModel.prototype, KadiraModel.prototype);\nPubsubModel.prototype._trackUnsub = function (session, sub) {\n  logger('UNSUB:', session.id, sub._subscriptionId);\n  let publication = this._getPublicationName(sub._name);\n  let subscriptionId = sub._subscriptionId;\n  let subscriptionState = this.subscriptions[subscriptionId];\n  let startTime = null;\n  // sometime, we don't have these states\n  if (subscriptionState) {\n    startTime = subscriptionState.startTime;\n  } else {\n    // if this is null subscription, which is started automatically\n    // hence, we don't have a state\n    startTime = session._startTime;\n  }\n\n  // in case, we can't get the startTime\n  if (startTime) {\n    let timestamp = Ntp._now();\n    let metrics = this._getMetrics(timestamp, publication);\n    // track the count\n    if (sub._name !== null) {\n      // we can't track subs for `null` publications.\n      // so we should not track unsubs too\n      metrics.unsubs++;\n    }\n    // use the current date to get the lifeTime of the subscription\n    metrics.lifeTime += timestamp - startTime;\n    // this is place we can clean the subscriptionState if exists\n    delete this.subscriptions[subscriptionId];\n  }\n};\nPubsubModel.prototype._trackReady = function (session, sub, trace) {\n  logger('READY:', session.id, sub._subscriptionId);\n  // use the current time to track the response time\n  let publication = this._getPublicationName(sub._name);\n  let subscriptionId = sub._subscriptionId;\n  let timestamp = Ntp._now();\n  let metrics = this._getMetrics(timestamp, publication);\n  let subscriptionState = this.subscriptions[subscriptionId];\n  if (subscriptionState && !subscriptionState.readyTracked) {\n    let resTime = timestamp - subscriptionState.startTime;\n    metrics.resTime += resTime;\n    subscriptionState.readyTracked = true;\n    metrics.histogram.add(resTime);\n  }\n  if (trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\nPubsubModel.prototype._trackError = function (session, sub, trace) {\n  logger('ERROR:', session.id, sub._subscriptionId);\n  // use the current time to track the response time\n  let publication = this._getPublicationName(sub._name);\n  let timestamp = Ntp._now();\n  let metrics = this._getMetrics(timestamp, publication);\n  metrics.errors++;\n  if (trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\nPubsubModel.prototype._getMetrics = function (timestamp, publication) {\n  let dateId = this._getDateId(timestamp);\n  if (!this.metricsByMinute[dateId]) {\n    this.metricsByMinute[dateId] = {\n      // startTime needs to be convert to serverTime before sending to the server\n      startTime: timestamp,\n      pubs: Object.create(null)\n    };\n  }\n  if (!this.metricsByMinute[dateId].pubs[publication]) {\n    this.metricsByMinute[dateId].pubs[publication] = {\n      subs: 0,\n      unsubs: 0,\n      resTime: 0,\n      activeSubs: 0,\n      activeDocs: 0,\n      lifeTime: 0,\n      totalObservers: 0,\n      cachedObservers: 0,\n      createdObservers: 0,\n      deletedObservers: 0,\n      errors: 0,\n      observerLifetime: 0,\n      polledDocuments: 0,\n      oplogUpdatedDocuments: 0,\n      oplogInsertedDocuments: 0,\n      oplogDeletedDocuments: 0,\n      initiallyAddedDocuments: 0,\n      liveAddedDocuments: 0,\n      liveChangedDocuments: 0,\n      liveRemovedDocuments: 0,\n      polledDocSize: 0,\n      fetchedDocSize: 0,\n      initiallyFetchedDocSize: 0,\n      liveFetchedDocSize: 0,\n      initiallySentMsgSize: 0,\n      liveSentMsgSize: 0,\n      histogram: new DDSketch({\n        alpha: 0.02\n      })\n    };\n  }\n  return this.metricsByMinute[dateId].pubs[publication];\n};\nPubsubModel.prototype._getPublicationName = function (name) {\n  return name || 'null(autopublish)';\n};\nPubsubModel.prototype._getSubscriptionInfo = function () {\n  let self = this;\n  let activeSubs = Object.create(null);\n  let activeDocs = Object.create(null);\n  let totalObservers = Object.create(null);\n  let cachedObservers = Object.create(null);\n  iterate(Meteor.server.sessions, session => {\n    iterate(session._namedSubs, countSubData);\n    iterate(session._universalSubs, countSubData);\n  });\n  let avgObserverReuse = Object.create(null);\n  _.each(totalObservers, function (value, publication) {\n    avgObserverReuse[publication] = cachedObservers[publication] / totalObservers[publication];\n  });\n  return {\n    activeSubs,\n    activeDocs,\n    avgObserverReuse\n  };\n  function countSubData(sub) {\n    let publication = self._getPublicationName(sub._name);\n    countSubscriptions(sub, publication);\n    countDocuments(sub, publication);\n    countObservers(sub, publication);\n  }\n  function countSubscriptions(sub, publication) {\n    activeSubs[publication] = activeSubs[publication] || 0;\n    activeSubs[publication]++;\n  }\n  function countDocuments(sub, publication) {\n    activeDocs[publication] = activeDocs[publication] || 0;\n    iterate(sub._documents, collection => {\n      activeDocs[publication] += countKeys(collection);\n    });\n  }\n  function countObservers(sub, publication) {\n    totalObservers[publication] = totalObservers[publication] || 0;\n    cachedObservers[publication] = cachedObservers[publication] || 0;\n    totalObservers[publication] += sub._totalObservers;\n    cachedObservers[publication] += sub._cachedObservers;\n  }\n};\nPubsubModel.prototype.buildPayload = function () {\n  let metricsByMinute = this.metricsByMinute;\n  this.metricsByMinute = Object.create(null);\n  let payload = {\n    pubMetrics: []\n  };\n  let subscriptionData = this._getSubscriptionInfo();\n  let activeSubs = subscriptionData.activeSubs;\n  let activeDocs = subscriptionData.activeDocs;\n  let avgObserverReuse = subscriptionData.avgObserverReuse;\n\n  // to the averaging\n  for (let dateId in metricsByMinute) {\n    let dateMetrics = metricsByMinute[dateId];\n    // We need to convert startTime into actual serverTime\n    dateMetrics.startTime = Kadira.syncedDate.syncTime(dateMetrics.startTime);\n    for (let publication in metricsByMinute[dateId].pubs) {\n      let singlePubMetrics = metricsByMinute[dateId].pubs[publication];\n      // We only calculate resTime for new subscriptions\n      singlePubMetrics.resTime /= singlePubMetrics.subs;\n      singlePubMetrics.resTime = singlePubMetrics.resTime || 0;\n      // We only track lifeTime in the unsubs\n      singlePubMetrics.lifeTime /= singlePubMetrics.unsubs;\n      singlePubMetrics.lifeTime = singlePubMetrics.lifeTime || 0;\n\n      // Count the average for observer lifetime\n      if (singlePubMetrics.deletedObservers > 0) {\n        singlePubMetrics.observerLifetime /= singlePubMetrics.deletedObservers;\n      }\n\n      // If there are two or more dateIds, we will be using the currentCount for all of them.\n      // We can come up with a better solution later on.\n      singlePubMetrics.activeSubs = activeSubs[publication] || 0;\n      singlePubMetrics.activeDocs = activeDocs[publication] || 0;\n      singlePubMetrics.avgObserverReuse = avgObserverReuse[publication] || 0;\n    }\n    payload.pubMetrics.push(metricsByMinute[dateId]);\n  }\n\n  // collect traces and send them with the payload\n  payload.pubRequests = this.tracerStore.collectTraces();\n  return payload;\n};\nPubsubModel.prototype.incrementHandleCount = function (trace, isCached) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(trace.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  let session = getProperty(Meteor.server.sessions, trace.session);\n  let sub;\n  if (session) {\n    sub = getProperty(session._namedSubs, trace.id);\n    if (sub) {\n      sub._totalObservers = sub._totalObservers || 0;\n      sub._cachedObservers = sub._cachedObservers || 0;\n    }\n  }\n  // not sure, we need to do this? But I don't need to break the however\n  sub = sub || {\n    _totalObservers: 0,\n    _cachedObservers: 0\n  };\n  publication.totalObservers++;\n  sub._totalObservers++;\n  if (isCached) {\n    publication.cachedObservers++;\n    sub._cachedObservers++;\n  }\n};\nPubsubModel.prototype.trackCreatedObserver = function (info) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  publication.createdObservers++;\n};\nPubsubModel.prototype.trackDeletedObserver = function (info) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  publication.deletedObservers++;\n  publication.observerLifetime += new Date().getTime() - info.startTime;\n};\nPubsubModel.prototype.trackDocumentChanges = function (info, op) {\n  // It's possibel that info to be null\n  // Specially when getting changes at the very begining.\n  // This may be false, but nice to have a check\n  if (!info) {\n    return;\n  }\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  if (op.op === 'd') {\n    publication.oplogDeletedDocuments++;\n  } else if (op.op === 'i') {\n    publication.oplogInsertedDocuments++;\n  } else if (op.op === 'u') {\n    publication.oplogUpdatedDocuments++;\n  }\n};\nPubsubModel.prototype.trackPolledDocuments = function (info, count) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  publication.polledDocuments += count;\n};\nPubsubModel.prototype.trackLiveUpdates = function (info, type, count) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  if (type === '_addPublished') {\n    publication.liveAddedDocuments += count;\n  } else if (type === '_removePublished') {\n    publication.liveRemovedDocuments += count;\n  } else if (type === '_changePublished') {\n    publication.liveChangedDocuments += count;\n  } else if (type === '_initialAdds') {\n    publication.initiallyAddedDocuments += count;\n  } else {\n    throw new Error('Kadira: Unknown live update type');\n  }\n};\nPubsubModel.prototype.trackDocSize = function (name, type, size) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  if (type === 'polledFetches') {\n    publication.polledDocSize += size;\n  } else if (type === 'liveFetches') {\n    publication.liveFetchedDocSize += size;\n  } else if (type === 'cursorFetches') {\n    publication.fetchedDocSize += size;\n  } else if (type === 'initialFetches') {\n    publication.initiallyFetchedDocSize += size;\n  } else {\n    throw new Error('Kadira: Unknown docs fetched type');\n  }\n};\nPubsubModel.prototype.trackMsgSize = function (name, type, size) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  if (type === 'liveSent') {\n    publication.liveSentMsgSize += size;\n  } else if (type === 'initialSent') {\n    publication.initiallySentMsgSize += size;\n  } else {\n    throw new Error('Kadira: Unknown docs fetched type');\n  }\n};","map":{"version":3,"names":["module","export","PubsubModel","Meteor","link","v","_","KadiraModel","TracerStore","Ntp","countKeys","getProperty","iterate","logger","Npm","require","DDSketch","metricsByMinute","Object","create","subscriptions","tracerStore","interval","maxTotalPoints","archiveEvery","start","prototype","_trackSub","session","msg","id","name","params","publication","_getPublicationName","timestamp","_now","metrics","_getMetrics","subs","startTime","_startTime","extend","_trackUnsub","sub","_subscriptionId","_name","subscriptionId","subscriptionState","unsubs","lifeTime","_trackReady","trace","readyTracked","resTime","histogram","add","addTrace","_trackError","errors","dateId","_getDateId","pubs","activeSubs","activeDocs","totalObservers","cachedObservers","createdObservers","deletedObservers","observerLifetime","polledDocuments","oplogUpdatedDocuments","oplogInsertedDocuments","oplogDeletedDocuments","initiallyAddedDocuments","liveAddedDocuments","liveChangedDocuments","liveRemovedDocuments","polledDocSize","fetchedDocSize","initiallyFetchedDocSize","liveFetchedDocSize","initiallySentMsgSize","liveSentMsgSize","alpha","_getSubscriptionInfo","self","server","sessions","_namedSubs","countSubData","_universalSubs","avgObserverReuse","each","value","countSubscriptions","countDocuments","countObservers","_documents","collection","_totalObservers","_cachedObservers","buildPayload","payload","pubMetrics","subscriptionData","dateMetrics","Kadira","syncedDate","syncTime","singlePubMetrics","push","pubRequests","collectTraces","incrementHandleCount","isCached","publicationName","trackCreatedObserver","info","trackDeletedObserver","Date","getTime","trackDocumentChanges","op","trackPolledDocuments","count","trackLiveUpdates","type","Error","trackDocSize","size","trackMsgSize"],"sources":["packages/montiapm:agent/lib/models/pubsub.js"],"sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { _ } from 'meteor/underscore';\nconst logger = Npm.require('debug')('kadira:pubsub');\nconst { DDSketch } = require('monti-apm-sketches-js');\nimport { KadiraModel } from './0model';\nimport { TracerStore } from '../tracer/tracer_store';\nimport { Ntp } from '../ntp';\nimport {countKeys, getProperty, iterate} from '../utils';\n\nexport function PubsubModel () {\n  this.metricsByMinute = Object.create(null);\n  this.subscriptions = Object.create(null);\n\n  this.tracerStore = new TracerStore({\n    // process traces every minute\n    interval: 1000 * 60,\n    // for 30 minutes\n    maxTotalPoints: 30,\n    // always trace for every 5 minutes\n    archiveEvery: 5\n  });\n\n  this.tracerStore.start();\n}\n\nPubsubModel.prototype._trackSub = function (session, msg) {\n  logger('SUB:', session.id, msg.id, msg.name, msg.params);\n  let publication = this._getPublicationName(msg.name);\n  let timestamp = Ntp._now();\n  let metrics = this._getMetrics(timestamp, publication);\n\n  metrics.subs++;\n  this.subscriptions[msg.id] = {\n    // We use localTime here, because when we used synedTime we might get\n    // minus or more than we've expected\n    //   (before serverTime diff changed overtime)\n    startTime: timestamp,\n    publication,\n    params: msg.params,\n    id: msg.id\n  };\n\n  // set session startedTime\n  session._startTime = session._startTime || timestamp;\n};\n\n_.extend(PubsubModel.prototype, KadiraModel.prototype);\n\nPubsubModel.prototype._trackUnsub = function (session, sub) {\n  logger('UNSUB:', session.id, sub._subscriptionId);\n  let publication = this._getPublicationName(sub._name);\n  let subscriptionId = sub._subscriptionId;\n  let subscriptionState = this.subscriptions[subscriptionId];\n\n  let startTime = null;\n  // sometime, we don't have these states\n  if (subscriptionState) {\n    startTime = subscriptionState.startTime;\n  } else {\n    // if this is null subscription, which is started automatically\n    // hence, we don't have a state\n    startTime = session._startTime;\n  }\n\n  // in case, we can't get the startTime\n  if (startTime) {\n    let timestamp = Ntp._now();\n    let metrics = this._getMetrics(timestamp, publication);\n    // track the count\n    if (sub._name !== null) {\n      // we can't track subs for `null` publications.\n      // so we should not track unsubs too\n      metrics.unsubs++;\n    }\n    // use the current date to get the lifeTime of the subscription\n    metrics.lifeTime += timestamp - startTime;\n    // this is place we can clean the subscriptionState if exists\n    delete this.subscriptions[subscriptionId];\n  }\n};\n\nPubsubModel.prototype._trackReady = function (session, sub, trace) {\n  logger('READY:', session.id, sub._subscriptionId);\n  // use the current time to track the response time\n  let publication = this._getPublicationName(sub._name);\n  let subscriptionId = sub._subscriptionId;\n  let timestamp = Ntp._now();\n  let metrics = this._getMetrics(timestamp, publication);\n\n  let subscriptionState = this.subscriptions[subscriptionId];\n  if (subscriptionState && !subscriptionState.readyTracked) {\n    let resTime = timestamp - subscriptionState.startTime;\n    metrics.resTime += resTime;\n    subscriptionState.readyTracked = true;\n    metrics.histogram.add(resTime);\n  }\n\n  if (trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._trackError = function (session, sub, trace) {\n  logger('ERROR:', session.id, sub._subscriptionId);\n  // use the current time to track the response time\n  let publication = this._getPublicationName(sub._name);\n  let timestamp = Ntp._now();\n  let metrics = this._getMetrics(timestamp, publication);\n\n  metrics.errors++;\n\n  if (trace) {\n    this.tracerStore.addTrace(trace);\n  }\n};\n\nPubsubModel.prototype._getMetrics = function (timestamp, publication) {\n  let dateId = this._getDateId(timestamp);\n\n  if (!this.metricsByMinute[dateId]) {\n    this.metricsByMinute[dateId] = {\n      // startTime needs to be convert to serverTime before sending to the server\n      startTime: timestamp,\n      pubs: Object.create(null)\n    };\n  }\n\n  if (!this.metricsByMinute[dateId].pubs[publication]) {\n    this.metricsByMinute[dateId].pubs[publication] = {\n      subs: 0,\n      unsubs: 0,\n      resTime: 0,\n      activeSubs: 0,\n      activeDocs: 0,\n      lifeTime: 0,\n      totalObservers: 0,\n      cachedObservers: 0,\n      createdObservers: 0,\n      deletedObservers: 0,\n      errors: 0,\n      observerLifetime: 0,\n      polledDocuments: 0,\n      oplogUpdatedDocuments: 0,\n      oplogInsertedDocuments: 0,\n      oplogDeletedDocuments: 0,\n      initiallyAddedDocuments: 0,\n      liveAddedDocuments: 0,\n      liveChangedDocuments: 0,\n      liveRemovedDocuments: 0,\n      polledDocSize: 0,\n      fetchedDocSize: 0,\n      initiallyFetchedDocSize: 0,\n      liveFetchedDocSize: 0,\n      initiallySentMsgSize: 0,\n      liveSentMsgSize: 0,\n      histogram: new DDSketch({\n        alpha: 0.02\n      })\n    };\n  }\n\n  return this.metricsByMinute[dateId].pubs[publication];\n};\n\nPubsubModel.prototype._getPublicationName = function (name) {\n  return name || 'null(autopublish)';\n};\n\nPubsubModel.prototype._getSubscriptionInfo = function () {\n  let self = this;\n  let activeSubs = Object.create(null);\n  let activeDocs = Object.create(null);\n  let totalObservers = Object.create(null);\n  let cachedObservers = Object.create(null);\n\n  iterate(Meteor.server.sessions, session => {\n    iterate(session._namedSubs, countSubData);\n    iterate(session._universalSubs, countSubData);\n  });\n\n  let avgObserverReuse = Object.create(null);\n  _.each(totalObservers, function (value, publication) {\n    avgObserverReuse[publication] = cachedObservers[publication] / totalObservers[publication];\n  });\n\n  return {\n    activeSubs,\n    activeDocs,\n    avgObserverReuse\n  };\n\n  function countSubData (sub) {\n    let publication = self._getPublicationName(sub._name);\n    countSubscriptions(sub, publication);\n    countDocuments(sub, publication);\n    countObservers(sub, publication);\n  }\n\n  function countSubscriptions (sub, publication) {\n    activeSubs[publication] = activeSubs[publication] || 0;\n    activeSubs[publication]++;\n  }\n\n  function countDocuments (sub, publication) {\n    activeDocs[publication] = activeDocs[publication] || 0;\n    iterate(sub._documents, collection => {\n      activeDocs[publication] += countKeys(collection);\n    });\n  }\n\n  function countObservers (sub, publication) {\n    totalObservers[publication] = totalObservers[publication] || 0;\n    cachedObservers[publication] = cachedObservers[publication] || 0;\n\n    totalObservers[publication] += sub._totalObservers;\n    cachedObservers[publication] += sub._cachedObservers;\n  }\n};\n\nPubsubModel.prototype.buildPayload = function () {\n  let metricsByMinute = this.metricsByMinute;\n  this.metricsByMinute = Object.create(null);\n\n  let payload = {\n    pubMetrics: []\n  };\n\n  let subscriptionData = this._getSubscriptionInfo();\n  let activeSubs = subscriptionData.activeSubs;\n  let activeDocs = subscriptionData.activeDocs;\n  let avgObserverReuse = subscriptionData.avgObserverReuse;\n\n  // to the averaging\n  for (let dateId in metricsByMinute) {\n    let dateMetrics = metricsByMinute[dateId];\n    // We need to convert startTime into actual serverTime\n    dateMetrics.startTime = Kadira.syncedDate.syncTime(dateMetrics.startTime);\n\n    for (let publication in metricsByMinute[dateId].pubs) {\n      let singlePubMetrics = metricsByMinute[dateId].pubs[publication];\n      // We only calculate resTime for new subscriptions\n      singlePubMetrics.resTime /= singlePubMetrics.subs;\n      singlePubMetrics.resTime = singlePubMetrics.resTime || 0;\n      // We only track lifeTime in the unsubs\n      singlePubMetrics.lifeTime /= singlePubMetrics.unsubs;\n      singlePubMetrics.lifeTime = singlePubMetrics.lifeTime || 0;\n\n      // Count the average for observer lifetime\n      if (singlePubMetrics.deletedObservers > 0) {\n        singlePubMetrics.observerLifetime /= singlePubMetrics.deletedObservers;\n      }\n\n      // If there are two or more dateIds, we will be using the currentCount for all of them.\n      // We can come up with a better solution later on.\n      singlePubMetrics.activeSubs = activeSubs[publication] || 0;\n      singlePubMetrics.activeDocs = activeDocs[publication] || 0;\n      singlePubMetrics.avgObserverReuse = avgObserverReuse[publication] || 0;\n    }\n\n    payload.pubMetrics.push(metricsByMinute[dateId]);\n  }\n\n  // collect traces and send them with the payload\n  payload.pubRequests = this.tracerStore.collectTraces();\n\n  return payload;\n};\n\nPubsubModel.prototype.incrementHandleCount = function (trace, isCached) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(trace.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n\n  let session = getProperty(Meteor.server.sessions, trace.session);\n\n  let sub;\n\n  if (session) {\n    sub = getProperty(session._namedSubs, trace.id);\n    if (sub) {\n      sub._totalObservers = sub._totalObservers || 0;\n      sub._cachedObservers = sub._cachedObservers || 0;\n    }\n  }\n  // not sure, we need to do this? But I don't need to break the however\n  sub = sub || {_totalObservers: 0 , _cachedObservers: 0};\n\n  publication.totalObservers++;\n  sub._totalObservers++;\n  if (isCached) {\n    publication.cachedObservers++;\n    sub._cachedObservers++;\n  }\n};\n\nPubsubModel.prototype.trackCreatedObserver = function (info) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  publication.createdObservers++;\n};\n\nPubsubModel.prototype.trackDeletedObserver = function (info) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  publication.deletedObservers++;\n  publication.observerLifetime += new Date().getTime() - info.startTime;\n};\n\nPubsubModel.prototype.trackDocumentChanges = function (info, op) {\n  // It's possibel that info to be null\n  // Specially when getting changes at the very begining.\n  // This may be false, but nice to have a check\n  if (!info) {\n    return;\n  }\n\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  if (op.op === 'd') {\n    publication.oplogDeletedDocuments++;\n  } else if (op.op === 'i') {\n    publication.oplogInsertedDocuments++;\n  } else if (op.op === 'u') {\n    publication.oplogUpdatedDocuments++;\n  }\n};\n\nPubsubModel.prototype.trackPolledDocuments = function (info, count) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n  publication.polledDocuments += count;\n};\n\nPubsubModel.prototype.trackLiveUpdates = function (info, type, count) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(info.name);\n  let publication = this._getMetrics(timestamp, publicationName);\n\n  if (type === '_addPublished') {\n    publication.liveAddedDocuments += count;\n  } else if (type === '_removePublished') {\n    publication.liveRemovedDocuments += count;\n  } else if (type === '_changePublished') {\n    publication.liveChangedDocuments += count;\n  } else if (type === '_initialAdds') {\n    publication.initiallyAddedDocuments += count;\n  } else {\n    throw new Error('Kadira: Unknown live update type');\n  }\n};\n\nPubsubModel.prototype.trackDocSize = function (name, type, size) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(name);\n  let publication = this._getMetrics(timestamp, publicationName);\n\n  if (type === 'polledFetches') {\n    publication.polledDocSize += size;\n  } else if (type === 'liveFetches') {\n    publication.liveFetchedDocSize += size;\n  } else if (type === 'cursorFetches') {\n    publication.fetchedDocSize += size;\n  } else if (type === 'initialFetches') {\n    publication.initiallyFetchedDocSize += size;\n  } else {\n    throw new Error('Kadira: Unknown docs fetched type');\n  }\n};\n\nPubsubModel.prototype.trackMsgSize = function (name, type, size) {\n  let timestamp = Ntp._now();\n  let publicationName = this._getPublicationName(name);\n  let publication = this._getMetrics(timestamp, publicationName);\n\n  if (type === 'liveSent') {\n    publication.liveSentMsgSize += size;\n  } else if (type === 'initialSent') {\n    publication.initiallySentMsgSize += size;\n  } else {\n    throw new Error('Kadira: Unknown docs fetched type');\n  }\n};\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"0d9e0cb3260253d9c0fe3b11e189c0c41f7b2a32"}
