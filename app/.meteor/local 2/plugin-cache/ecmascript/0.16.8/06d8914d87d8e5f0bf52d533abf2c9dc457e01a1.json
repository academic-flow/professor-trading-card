{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/hijack/wrap_session.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/montiapm:agent/lib/hijack/wrap_session.js","filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/hijack/wrap_session.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/phatca/Documents/GitHub/professor-trading-card/app","root":"/Users/phatca/Documents/GitHub/professor-trading-card/app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/montiapm:agent/lib/hijack/wrap_session.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/montiapm:agent/lib/hijack/wrap_session.js"}},"code":"module.export({\n  wrapSession: () => wrapSession\n});\nlet Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n}, 0);\nlet _;\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n}, 1);\nlet MeteorDebugIgnore;\nmodule.link(\"./error\", {\n  MeteorDebugIgnore(v) {\n    MeteorDebugIgnore = v;\n  }\n}, 2);\nlet TimeoutManager;\nmodule.link(\"./timeout_manager\", {\n  TimeoutManager(v) {\n    TimeoutManager = v;\n  }\n}, 3);\nconst MAX_PARAMS_LENGTH = 4000;\nfunction wrapSession(sessionProto) {\n  let originalProcessMessage = sessionProto.processMessage;\n  sessionProto.processMessage = function (msg) {\n    let kadiraInfo = {\n      session: this.id,\n      userId: this.userId\n    };\n    if (msg.msg === 'method' || msg.msg === 'sub') {\n      kadiraInfo.trace = Kadira.tracer.start(this, msg);\n      Kadira.waitTimeBuilder.register(this, msg.id);\n      let params = Kadira.tracer._applyObjectFilters(msg.params || []);\n      // use JSON instead of EJSON to save the CPU\n      let stringifiedParams = JSON.stringify(params);\n\n      // The params could be several mb or larger.\n      // Truncate if it is large\n      if (stringifiedParams.length > MAX_PARAMS_LENGTH) {\n        stringifiedParams = \"Monti APM: params are too big. First \".concat(MAX_PARAMS_LENGTH, \" characters: \").concat(stringifiedParams.slice(0, MAX_PARAMS_LENGTH));\n      }\n      let startData = {\n        userId: this.userId,\n        params: stringifiedParams\n      };\n      Kadira.tracer.event(kadiraInfo.trace, 'start', startData);\n      msg._waitEventId = Kadira.tracer.event(kadiraInfo.trace, 'wait', {}, kadiraInfo);\n      msg.__kadiraInfo = kadiraInfo;\n      if (msg.msg === 'sub') {\n        // start tracking inside processMessage allows us to indicate\n        // wait time as well\n        Kadira.EventBus.emit('pubsub', 'subReceived', this, msg);\n        Kadira.models.pubsub._trackSub(this, msg);\n      }\n    }\n    Kadira.EventBus.emit('system', 'ddpMessageReceived', this, msg);\n    Kadira.models.system.handleSessionActivity(msg, this);\n    return originalProcessMessage.call(this, msg);\n  };\n\n  // adding the method context to the current fiber\n  let originalMethodHandler = sessionProto.protocol_handlers.method;\n  sessionProto.protocol_handlers.method = function (msg, unblock) {\n    let self = this;\n    // add context\n    let kadiraInfo = msg.__kadiraInfo;\n    let response;\n    if (kadiraInfo) {\n      Kadira._setInfo(kadiraInfo);\n      TimeoutManager.trackTimeout({\n        kadiraInfo,\n        msg\n      });\n\n      // end wait event\n      let waitList = Kadira.waitTimeBuilder.build(this, msg.id);\n      Kadira.tracer.eventEnd(kadiraInfo.trace, msg._waitEventId, {\n        waitOn: waitList\n      });\n      unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n      response = Kadira.env.kadiraInfo.withValue(kadiraInfo, function () {\n        return originalMethodHandler.call(self, msg, unblock);\n      });\n      unblock();\n    } else {\n      response = originalMethodHandler.call(self, msg, unblock);\n    }\n    return response;\n  };\n\n  // to capture the currently processing message\n  let orginalSubHandler = sessionProto.protocol_handlers.sub;\n  sessionProto.protocol_handlers.sub = function (msg, unblock) {\n    let self = this;\n    // add context\n    let kadiraInfo = msg.__kadiraInfo;\n    let response;\n    if (kadiraInfo) {\n      Kadira._setInfo(kadiraInfo);\n      TimeoutManager.trackTimeout({\n        kadiraInfo,\n        msg\n      });\n\n      // end wait event\n      let waitList = Kadira.waitTimeBuilder.build(this, msg.id);\n      Kadira.tracer.eventEnd(kadiraInfo.trace, msg._waitEventId, {\n        waitOn: waitList\n      });\n      unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n      response = Kadira.env.kadiraInfo.withValue(kadiraInfo, function () {\n        return orginalSubHandler.call(self, msg, unblock);\n      });\n      unblock();\n    } else {\n      response = orginalSubHandler.call(self, msg, unblock);\n    }\n    return response;\n  };\n\n  // to capture the currently processing message\n  let orginalUnSubHandler = sessionProto.protocol_handlers.unsub;\n  sessionProto.protocol_handlers.unsub = function (msg, unblock) {\n    unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n    let response = orginalUnSubHandler.call(this, msg, unblock);\n    unblock();\n    return response;\n  };\n\n  // track method ending (to get the result of error)\n  let originalSend = sessionProto.send;\n  sessionProto.send = function (msg) {\n    if (msg.msg === 'result') {\n      let kadiraInfo = Kadira._getInfo();\n      if (kadiraInfo) {\n        TimeoutManager.clearTimeout({\n          kadiraInfo\n        });\n        let error;\n        if (msg.error) {\n          error = _.pick(msg.error, ['message', 'stack', 'details']);\n\n          // pick the error from the wrapped method handler\n          if (kadiraInfo && kadiraInfo.currentError) {\n            // the error stack is wrapped so Meteor._debug can identify\n            // this as a method error.\n            error = _.pick(kadiraInfo.currentError, ['message', 'stack', 'details']);\n            // see wrapMethodHanderForErrors() method def for more info\n            if (error.stack && error.stack.stack) {\n              error.stack = error.stack.stack;\n            }\n          }\n          Kadira.tracer.endLastEvent(kadiraInfo.trace);\n          Kadira.tracer.event(kadiraInfo.trace, 'error', {\n            error\n          });\n        } else {\n          Kadira.tracer.endLastEvent(kadiraInfo.trace);\n          Kadira.tracer.event(kadiraInfo.trace, 'complete');\n        }\n\n        // processing the message\n        let trace = Kadira.tracer.buildTrace(kadiraInfo.trace);\n        Kadira.EventBus.emit('method', 'methodCompleted', trace, this);\n        Kadira.models.methods.processMethod(trace);\n\n        // error may or may not exist and error tracking can be disabled\n        if (error && Kadira.options.enableErrorTracking) {\n          Kadira.models.error.trackError(error, trace);\n        }\n\n        // clean and make sure, fiber is clean\n        // not sure we need to do this, but a preventive measure\n        Kadira._setInfo(null);\n      }\n    }\n    return originalSend.call(this, msg);\n  };\n}\n// wrap existing method handlers for capturing errors\n_.each(Meteor.server.method_handlers, function (handler, name) {\n  wrapMethodHanderForErrors(name, handler, Meteor.server.method_handlers);\n});\n\n// wrap future method handlers for capturing errors\nlet originalMeteorMethods = Meteor.methods;\nMeteor.methods = function (methodMap) {\n  _.each(methodMap, function (handler, name) {\n    wrapMethodHanderForErrors(name, handler, methodMap);\n  });\n  originalMeteorMethods(methodMap);\n};\nfunction wrapMethodHanderForErrors(name, originalHandler, methodMap) {\n  methodMap[name] = function () {\n    try {\n      return originalHandler.apply(this, arguments);\n    } catch (ex) {\n      if (ex && Kadira._getInfo()) {\n        // sometimes error may be just a string or a primitive\n        // in that case, we need to make it a psuedo error\n        if (typeof ex !== 'object') {\n          // eslint-disable-next-line no-ex-assign\n          ex = {\n            message: ex,\n            stack: ex\n          };\n        }\n        // Now we are marking this error to get tracked via methods\n        // But, this also triggers a Meteor.debug call, and\n        // it only gets the stack\n        // We also track Meteor.debug errors and want to stop\n        // tracking this error. That's why we do this\n        // See Meteor.debug error tracking code for more\n        // If error tracking is disabled, we do not modify the stack since\n        // it would be shown as an object in the logs\n        if (Kadira.options.enableErrorTracking) {\n          ex.stack = {\n            stack: ex.stack,\n            source: 'method',\n            [MeteorDebugIgnore]: true\n          };\n          Kadira._getInfo().currentError = ex;\n        }\n      }\n      throw ex;\n    }\n  };\n}","map":{"version":3,"names":["module","export","wrapSession","Meteor","link","v","_","MeteorDebugIgnore","TimeoutManager","MAX_PARAMS_LENGTH","sessionProto","originalProcessMessage","processMessage","msg","kadiraInfo","session","id","userId","trace","Kadira","tracer","start","waitTimeBuilder","register","params","_applyObjectFilters","stringifiedParams","JSON","stringify","length","concat","slice","startData","event","_waitEventId","__kadiraInfo","EventBus","emit","models","pubsub","_trackSub","system","handleSessionActivity","call","originalMethodHandler","protocol_handlers","method","unblock","self","response","_setInfo","trackTimeout","waitList","build","eventEnd","waitOn","trackWaitTime","env","withValue","orginalSubHandler","sub","orginalUnSubHandler","unsub","originalSend","send","_getInfo","clearTimeout","error","pick","currentError","stack","endLastEvent","buildTrace","methods","processMethod","options","enableErrorTracking","trackError","each","server","method_handlers","handler","name","wrapMethodHanderForErrors","originalMeteorMethods","methodMap","originalHandler","apply","arguments","ex","message","source"],"sources":["packages/montiapm:agent/lib/hijack/wrap_session.js"],"sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { _ } from 'meteor/underscore';\nimport { MeteorDebugIgnore } from './error';\nimport { TimeoutManager } from './timeout_manager';\n\nconst MAX_PARAMS_LENGTH = 4000;\n\nexport function wrapSession (sessionProto) {\n  let originalProcessMessage = sessionProto.processMessage;\n  sessionProto.processMessage = function (msg) {\n    let kadiraInfo = {\n      session: this.id,\n      userId: this.userId\n    };\n    if (msg.msg === 'method' || msg.msg === 'sub') {\n      kadiraInfo.trace = Kadira.tracer.start(this, msg);\n\n      Kadira.waitTimeBuilder.register(this, msg.id);\n\n      let params = Kadira.tracer._applyObjectFilters(msg.params || []);\n      // use JSON instead of EJSON to save the CPU\n      let stringifiedParams = JSON.stringify(params);\n\n      // The params could be several mb or larger.\n      // Truncate if it is large\n      if (stringifiedParams.length > MAX_PARAMS_LENGTH) {\n        stringifiedParams = `Monti APM: params are too big. First ${MAX_PARAMS_LENGTH} characters: ${stringifiedParams.slice(0, MAX_PARAMS_LENGTH)}`;\n      }\n\n      let startData = { userId: this.userId, params: stringifiedParams };\n      Kadira.tracer.event(kadiraInfo.trace, 'start', startData);\n      msg._waitEventId = Kadira.tracer.event(kadiraInfo.trace, 'wait', {}, kadiraInfo);\n      msg.__kadiraInfo = kadiraInfo;\n\n      if (msg.msg === 'sub') {\n        // start tracking inside processMessage allows us to indicate\n        // wait time as well\n        Kadira.EventBus.emit('pubsub', 'subReceived', this, msg);\n        Kadira.models.pubsub._trackSub(this, msg);\n      }\n    }\n    Kadira.EventBus.emit('system', 'ddpMessageReceived', this, msg);\n    Kadira.models.system.handleSessionActivity(msg, this);\n\n    return originalProcessMessage.call(this, msg);\n  };\n\n  // adding the method context to the current fiber\n  let originalMethodHandler = sessionProto.protocol_handlers.method;\n  sessionProto.protocol_handlers.method = function (msg, unblock) {\n    let self = this;\n    // add context\n    let kadiraInfo = msg.__kadiraInfo;\n\n    let response;\n\n    if (kadiraInfo) {\n      Kadira._setInfo(kadiraInfo);\n\n      TimeoutManager.trackTimeout({\n        kadiraInfo,\n        msg,\n      });\n\n      // end wait event\n      let waitList = Kadira.waitTimeBuilder.build(this, msg.id);\n      Kadira.tracer.eventEnd(kadiraInfo.trace, msg._waitEventId, {waitOn: waitList});\n\n      unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n      response = Kadira.env.kadiraInfo.withValue(kadiraInfo, function () {\n        return originalMethodHandler.call(self, msg, unblock);\n      });\n      unblock();\n    } else {\n      response = originalMethodHandler.call(self, msg, unblock);\n    }\n\n    return response;\n  };\n\n  // to capture the currently processing message\n  let orginalSubHandler = sessionProto.protocol_handlers.sub;\n  sessionProto.protocol_handlers.sub = function (msg, unblock) {\n    let self = this;\n    // add context\n    let kadiraInfo = msg.__kadiraInfo;\n    let response;\n    if (kadiraInfo) {\n      Kadira._setInfo(kadiraInfo);\n\n      TimeoutManager.trackTimeout({\n        kadiraInfo,\n        msg,\n      });\n\n      // end wait event\n      let waitList = Kadira.waitTimeBuilder.build(this, msg.id);\n      Kadira.tracer.eventEnd(kadiraInfo.trace, msg._waitEventId, {waitOn: waitList});\n\n      unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n      response = Kadira.env.kadiraInfo.withValue(kadiraInfo, function () {\n        return orginalSubHandler.call(self, msg, unblock);\n      });\n      unblock();\n    } else {\n      response = orginalSubHandler.call(self, msg, unblock);\n    }\n\n    return response;\n  };\n\n  // to capture the currently processing message\n  let orginalUnSubHandler = sessionProto.protocol_handlers.unsub;\n  sessionProto.protocol_handlers.unsub = function (msg, unblock) {\n    unblock = Kadira.waitTimeBuilder.trackWaitTime(this, msg, unblock);\n    let response = orginalUnSubHandler.call(this, msg, unblock);\n    unblock();\n    return response;\n  };\n\n  // track method ending (to get the result of error)\n  let originalSend = sessionProto.send;\n  sessionProto.send = function (msg) {\n    if (msg.msg === 'result') {\n      let kadiraInfo = Kadira._getInfo();\n      if (kadiraInfo) {\n        TimeoutManager.clearTimeout({ kadiraInfo });\n\n        let error;\n\n        if (msg.error) {\n          error = _.pick(msg.error, ['message', 'stack', 'details']);\n\n          // pick the error from the wrapped method handler\n          if (kadiraInfo && kadiraInfo.currentError) {\n            // the error stack is wrapped so Meteor._debug can identify\n            // this as a method error.\n            error = _.pick(kadiraInfo.currentError, ['message', 'stack', 'details']);\n            // see wrapMethodHanderForErrors() method def for more info\n            if (error.stack && error.stack.stack) {\n              error.stack = error.stack.stack;\n            }\n          }\n\n          Kadira.tracer.endLastEvent(kadiraInfo.trace);\n          Kadira.tracer.event(kadiraInfo.trace, 'error', {error});\n        } else {\n          Kadira.tracer.endLastEvent(kadiraInfo.trace);\n          Kadira.tracer.event(kadiraInfo.trace, 'complete');\n        }\n\n        // processing the message\n        let trace = Kadira.tracer.buildTrace(kadiraInfo.trace);\n        Kadira.EventBus.emit('method', 'methodCompleted', trace, this);\n        Kadira.models.methods.processMethod(trace);\n\n        // error may or may not exist and error tracking can be disabled\n        if (error && Kadira.options.enableErrorTracking) {\n          Kadira.models.error.trackError(error, trace);\n        }\n\n        // clean and make sure, fiber is clean\n        // not sure we need to do this, but a preventive measure\n        Kadira._setInfo(null);\n      }\n    }\n\n    return originalSend.call(this, msg);\n  };\n}\n\n// wrap existing method handlers for capturing errors\n_.each(Meteor.server.method_handlers, function (handler, name) {\n  wrapMethodHanderForErrors(name, handler, Meteor.server.method_handlers);\n});\n\n// wrap future method handlers for capturing errors\nlet originalMeteorMethods = Meteor.methods;\nMeteor.methods = function (methodMap) {\n  _.each(methodMap, function (handler, name) {\n    wrapMethodHanderForErrors(name, handler, methodMap);\n  });\n  originalMeteorMethods(methodMap);\n};\n\n\nfunction wrapMethodHanderForErrors (name, originalHandler, methodMap) {\n  methodMap[name] = function () {\n    try {\n      return originalHandler.apply(this, arguments);\n    } catch (ex) {\n      if (ex && Kadira._getInfo()) {\n        // sometimes error may be just a string or a primitive\n        // in that case, we need to make it a psuedo error\n        if (typeof ex !== 'object') {\n          // eslint-disable-next-line no-ex-assign\n          ex = {message: ex, stack: ex};\n        }\n        // Now we are marking this error to get tracked via methods\n        // But, this also triggers a Meteor.debug call, and\n        // it only gets the stack\n        // We also track Meteor.debug errors and want to stop\n        // tracking this error. That's why we do this\n        // See Meteor.debug error tracking code for more\n        // If error tracking is disabled, we do not modify the stack since\n        // it would be shown as an object in the logs\n        if (Kadira.options.enableErrorTracking) {\n          ex.stack = {stack: ex.stack, source: 'method', [MeteorDebugIgnore]: true};\n          Kadira._getInfo().currentError = ex;\n        }\n      }\n      throw ex;\n    }\n  };\n}\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"06d8914d87d8e5f0bf52d533abf2c9dc457e01a1"}
