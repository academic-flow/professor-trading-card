[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\nvar verifyErrors = Package['modules-runtime'].verifyErrors;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modules\":{\"server.js\":function module(require){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/server.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nrequire(\"./install-packages.js\");\nrequire(\"./process.js\");\nrequire(\"./reify.js\");\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"install-packages.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/install-packages.js                                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nfunction install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (typeof mainModule === \"string\") {\n    // Set up an alias from /node_modules/meteor/<package>.js to the main\n    // module, e.g. meteor/<package>/index.js.\n    meteorDir[name + \".js\"] = mainModule;\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"npm-mongo\");\ninstall(\"ecmascript-runtime\");\ninstall(\"modules-runtime\");\ninstall(\"modules-runtime-hot\");\ninstall(\"modules\", \"meteor/modules/server.js\");\ninstall(\"modern-browsers\", \"meteor/modern-browsers/modern.js\");\ninstall(\"es5-shim\");\ninstall(\"promise\", \"meteor/promise/server.js\");\ninstall(\"ecmascript-runtime-client\", \"meteor/ecmascript-runtime-client/versions.js\");\ninstall(\"ecmascript-runtime-server\", \"meteor/ecmascript-runtime-server/runtime.js\");\ninstall(\"babel-compiler\");\ninstall(\"hot-module-replacement\");\ninstall(\"react-fast-refresh\");\ninstall(\"ecmascript\");\ninstall(\"babel-runtime\", \"meteor/babel-runtime/babel-runtime.js\");\ninstall(\"fetch\", \"meteor/fetch/server.js\");\ninstall(\"inter-process-messaging\", \"meteor/inter-process-messaging/inter-process-messaging.js\");\ninstall(\"dynamic-import\", \"meteor/dynamic-import/server.js\");\ninstall(\"base64\", \"meteor/base64/base64.js\");\ninstall(\"ejson\", \"meteor/ejson/ejson.js\");\ninstall(\"diff-sequence\", \"meteor/diff-sequence/diff.js\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"id-map\", \"meteor/id-map/id-map.js\");\ninstall(\"random\", \"meteor/random/main_server.js\");\ninstall(\"mongo-id\", \"meteor/mongo-id/id.js\");\ninstall(\"ordered-dict\", \"meteor/ordered-dict/ordered_dict.js\");\ninstall(\"tracker\");\ninstall(\"mongo-decimal\", \"meteor/mongo-decimal/decimal.js\");\ninstall(\"minimongo\", \"meteor/minimongo/minimongo_server.js\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\", \"meteor/retry/retry.js\");\ninstall(\"callback-hook\", \"meteor/callback-hook/hook.js\");\ninstall(\"ddp-common\");\ninstall(\"reload\");\ninstall(\"socket-stream-client\", \"meteor/socket-stream-client/node.js\");\ninstall(\"ddp-client\", \"meteor/ddp-client/server/server.js\");\ninstall(\"underscore\");\ninstall(\"rate-limit\", \"meteor/rate-limit/rate-limit.js\");\ninstall(\"ddp-rate-limiter\", \"meteor/ddp-rate-limiter/ddp-rate-limiter.js\");\ninstall(\"typescript\");\ninstall(\"logging\", \"meteor/logging/logging.js\");\ninstall(\"routepolicy\", \"meteor/routepolicy/main.js\");\ninstall(\"boilerplate-generator\", \"meteor/boilerplate-generator/generator.js\");\ninstall(\"webapp-hashing\");\ninstall(\"webapp\", \"meteor/webapp/webapp_server.js\");\ninstall(\"ddp-server\");\ninstall(\"ddp\");\ninstall(\"allow-deny\");\ninstall(\"mongo-dev-server\", \"meteor/mongo-dev-server/server.js\");\ninstall(\"binary-heap\", \"meteor/binary-heap/binary-heap.js\");\ninstall(\"insecure\");\ninstall(\"mongo\");\ninstall(\"reactive-var\");\ninstall(\"minifier-css\", \"meteor/minifier-css/minifier.js\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"shell-server\", \"meteor/shell-server/main.js\");\ninstall(\"static-html\");\ninstall(\"react-meteor-data\", \"meteor/react-meteor-data/index.js\");\ninstall(\"url\", \"meteor/url/server.js\");\ninstall(\"accounts-base\", \"meteor/accounts-base/server_main.js\");\ninstall(\"sha\");\ninstall(\"email\", \"meteor/email/email.js\");\ninstall(\"accounts-password\");\ninstall(\"zodern:types\");\ninstall(\"alanning:roles\");\ninstall(\"raix:eventemitter\");\ninstall(\"tmeasday:check-npm-versions\", \"meteor/tmeasday:check-npm-versions/check-npm-versions.ts\");\ninstall(\"aldeed:collection2\", \"meteor/aldeed:collection2/collection2.js\");\ninstall(\"aldeed:schema-index\", \"meteor/aldeed:schema-index/server.js\");\ninstall(\"montiapm:meteorx\");\ninstall(\"zodern:meteor-package-versions\");\ninstall(\"montiapm:agent\");\ninstall(\"dev-error-overlay\");\ninstall(\"hot-code-push\");\ninstall(\"launch-screen\");\ninstall(\"autoupdate\", \"meteor/autoupdate/autoupdate_server.js\");\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"process.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/process.js                                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nif (! global.process) {\n  try {\n    // The application can run `npm install process` to provide its own\n    // process stub; otherwise this module will provide a partial stub.\n    global.process = require(\"process\");\n  } catch (missing) {\n    global.process = {};\n  }\n}\n\nvar proc = global.process;\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = proc;\n      }\n    }\n  });\n} else {\n  proc.platform = \"browser\";\n  proc.nextTick = proc.nextTick || Meteor._setImmediate;\n}\n\nif (typeof proc.env !== \"object\") {\n  proc.env = {};\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nfor (var key in meteorEnv) {\n  if (hasOwn.call(meteorEnv, key)) {\n    proc.env[key] = meteorEnv[key];\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"reify.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/modules/reify.js                                                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nrequire(\"@meteorjs/reify/lib/runtime\").enable(\n  module.constructor.prototype\n);\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"@meteorjs\":{\"reify\":{\"lib\":{\"runtime\":{\"index.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/modules/node_modules/@meteorjs/reify/lib/runtime/index.js                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nmeteorInstall({\"node_modules\":{\"simpl-schema\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/package.json                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"simpl-schema\",\n  \"version\": \"3.4.6\",\n  \"main\": \"./dist/cjs/main.js\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"dist\":{\"cjs\":{\"main.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/main.js                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidationContext = exports.toJsonSchema = exports.schemaDefinitionOptions = void 0;\nrequire(\"./clean.js\");\nconst SimpleSchema_js_1 = require(\"./SimpleSchema.js\");\nObject.defineProperty(exports, \"schemaDefinitionOptions\", { enumerable: true, get: function () { return SimpleSchema_js_1.schemaDefinitionOptions; } });\nObject.defineProperty(exports, \"ValidationContext\", { enumerable: true, get: function () { return SimpleSchema_js_1.ValidationContext; } });\nconst toJsonSchema_js_1 = require(\"./toJsonSchema.js\");\nObject.defineProperty(exports, \"toJsonSchema\", { enumerable: true, get: function () { return toJsonSchema_js_1.toJsonSchema; } });\nSimpleSchema_js_1.SimpleSchema.ValidationContext = SimpleSchema_js_1.ValidationContext;\nexports.default = SimpleSchema_js_1.SimpleSchema;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"clean.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean.js                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst clone_1 = __importDefault(require(\"clone\"));\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\nconst convertToProperType_js_1 = __importDefault(require(\"./clean/convertToProperType.js\"));\nconst setAutoValues_js_1 = __importDefault(require(\"./clean/setAutoValues.js\"));\nconst SimpleSchema_js_1 = require(\"./SimpleSchema.js\");\nconst index_js_1 = require(\"./utility/index.js\");\nconst index_js_2 = require(\"./validation/typeValidator/index.js\");\nconst operatorsToIgnoreValue = ['$unset', '$currentDate'];\nfunction log(message) {\n    if (SimpleSchema_js_1.SimpleSchema.debug === true) {\n        console.debug(message);\n    }\n}\n/**\n * Cleans a document or modifier object. By default, will filter, automatically\n * type convert where possible, and inject automatic/default values. Use the options\n * to skip one or more of these.\n *\n * @param ss A SimpleSchema instance\n * @param doc Document or modifier to clean. Referenced object will be modified in place.\n * @param options Clean options\n * @returns The modified doc.\n */\nfunction clean(ss, doc, options = {}) {\n    var _a;\n    // By default, doc will be filtered and auto-converted\n    const cleanOptions = Object.assign(Object.assign({ isModifier: (0, index_js_1.looksLikeModifier)(doc), isUpsert: false }, ss._cleanOptions), options);\n    Object.getOwnPropertyNames(cleanOptions).forEach((opt) => {\n        if (!SimpleSchema_js_1.SimpleSchema.supportedCleanOptions.has(opt)) {\n            console.warn(`Unsupported \"${opt}\" option passed to SimpleSchema clean`);\n        }\n    });\n    // Clone so we do not mutate\n    const cleanDoc = cleanOptions.mutate === true ? doc : (0, clone_1.default)(doc);\n    const mongoObject = (_a = cleanOptions.mongoObject) !== null && _a !== void 0 ? _a : new mongo_object_1.default(cleanDoc, ss.blackboxKeys());\n    // Clean loop\n    if (cleanOptions.filter === true ||\n        cleanOptions.autoConvert === true ||\n        cleanOptions.removeEmptyStrings === true ||\n        cleanOptions.trimStrings === true) {\n        const removedPositions = []; // For removing now-empty objects after\n        mongoObject.forEachNode(function eachNode() {\n            // The value of a $unset is irrelevant, so no point in cleaning it.\n            // Also we do not care if fields not in the schema are unset.\n            // Other operators also have values that we wouldn't want to clean.\n            if (operatorsToIgnoreValue.includes(this.operator))\n                return;\n            const gKey = this.genericKey;\n            if (gKey == null)\n                return;\n            let val = this.value;\n            if (val === undefined)\n                return;\n            let p;\n            // Filter out props if necessary\n            if ((cleanOptions.filter === true && !ss.allowsKey(gKey)) ||\n                (cleanOptions.removeNullsFromArrays === true && this.isArrayItem && val === null)) {\n                // XXX Special handling for $each; maybe this could be made nicer\n                if (this.position.slice(-7) === '[$each]') {\n                    mongoObject.removeValueForPosition(this.position.slice(0, -7));\n                    removedPositions.push(this.position.slice(0, -7));\n                }\n                else {\n                    this.remove();\n                    removedPositions.push(this.position);\n                }\n                log(`SimpleSchema.clean: filtered out value that would have affected key \"${gKey}\", which is not allowed by the schema`);\n                return; // no reason to do more\n            }\n            const outerDef = ss.schema(gKey);\n            const defs = outerDef === null || outerDef === void 0 ? void 0 : outerDef.type.definitions;\n            const def = defs === null || defs === void 0 ? void 0 : defs[0];\n            // Auto-convert values if requested and if possible\n            if (cleanOptions.autoConvert === true && defs !== undefined && def != null && !(0, index_js_2.isValueTypeValid)(defs, val, this.operator)) {\n                const newVal = (0, convertToProperType_js_1.default)(val, def.type);\n                if (newVal !== undefined && newVal !== val) {\n                    log(`SimpleSchema.clean: auto-converted value ${String(val)} from ${typeof val} to ${typeof newVal} for ${gKey}`);\n                    val = newVal;\n                    this.updateValue(newVal);\n                }\n            }\n            // Clean string values\n            if (typeof val === 'string') {\n                // Trim strings if\n                // 1. The trimStrings option is `true` AND\n                // 2. The field is not in the schema OR is in the schema with `trim` !== `false`\n                if (cleanOptions.trimStrings === true &&\n                    (def === null || def === void 0 ? void 0 : def.trim) !== false) {\n                    val = val.trim();\n                    this.updateValue(val);\n                }\n                // Remove empty strings if\n                // 1. The removeEmptyStrings option is `true` AND\n                // 2. The value is in a normal object or in the $set part of a modifier\n                // 3. The value is an empty string.\n                if (cleanOptions.removeEmptyStrings === true &&\n                    (this.operator == null || this.operator === '$set') &&\n                    val.length === 0) {\n                    // For a document, we remove any fields that are being set to an empty string\n                    this.remove();\n                    // For a modifier, we $unset any fields that are being set to an empty string.\n                    // But only if we're not already within an entire object that is being set.\n                    if (this.operator === '$set') {\n                        const matches = this.position.match(/\\[/g);\n                        if (matches !== null && matches.length < 2) {\n                            p = this.position.replace('$set', '$unset');\n                            mongoObject.setValueForPosition(p, '');\n                        }\n                    }\n                }\n            }\n        }, { endPointsOnly: false });\n        // Remove any objects that are now empty after filtering\n        removedPositions.forEach((removedPosition) => {\n            const lastBrace = removedPosition.lastIndexOf('[');\n            if (lastBrace !== -1) {\n                const removedPositionParent = removedPosition.slice(0, lastBrace);\n                const value = mongoObject.getValueForPosition(removedPositionParent);\n                if ((0, index_js_1.isEmptyObject)(value)) {\n                    mongoObject.removeValueForPosition(removedPositionParent);\n                }\n            }\n        });\n        mongoObject.removeArrayItems();\n    }\n    // Set automatic values\n    if (cleanOptions.getAutoValues === true) {\n        (0, setAutoValues_js_1.default)(ss.autoValueFunctions(), mongoObject, cleanOptions.isModifier || false, cleanOptions.isUpsert || false, cleanOptions.extendAutoValueContext);\n    }\n    // Ensure we don't have any operators set to an empty object\n    // since MongoDB 2.6+ will throw errors.\n    if (cleanOptions.isModifier) {\n        Object.keys(cleanDoc !== null && cleanDoc !== void 0 ? cleanDoc : {}).forEach((op) => {\n            const operatorValue = cleanDoc[op];\n            if (typeof operatorValue === 'object' &&\n                operatorValue !== null &&\n                (0, index_js_1.isEmptyObject)(operatorValue)) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete cleanDoc[op];\n            }\n        });\n    }\n    return cleanDoc;\n}\nexports.default = clean;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"clean\":{\"convertToProperType.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean/convertToProperType.js                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SimpleSchema_js_1 = require(\"../SimpleSchema.js\");\n/**\n * Converts value to proper type\n *\n * @param value Value to try to convert\n * @param type A type\n * @returns Value converted to type.\n */\nfunction convertToProperType(value, type) {\n    // Can't and shouldn't convert arrays or objects or null\n    if (value === null)\n        return value;\n    if (value === undefined)\n        return value;\n    if (Array.isArray(value))\n        return value;\n    if (value !== undefined &&\n        (typeof value === 'function' || typeof value === 'object') &&\n        !(value instanceof Date))\n        return value;\n    // Convert to String type\n    if (type === String)\n        return value.toString();\n    // Convert to Number type\n    if (type === Number || type === SimpleSchema_js_1.SimpleSchema.Integer) {\n        if (typeof value === 'string' && value.length > 0) {\n            // Try to convert numeric strings to numbers\n            const numberVal = Number(value);\n            if (!isNaN(numberVal))\n                return numberVal;\n        }\n        // Leave it; will fail validation\n        return value;\n    }\n    // If target type is a Date we can safely convert from either a\n    // number (Integer value representing the number of milliseconds\n    // since 1 January 1970 00:00:00 UTC) or a string that can be parsed\n    // by Date.\n    if (type === Date) {\n        if (typeof value === 'string') {\n            const parsedDate = Date.parse(value);\n            if (!isNaN(parsedDate))\n                return new Date(parsedDate);\n        }\n        if (typeof value === 'number')\n            return new Date(value);\n    }\n    // Convert to Boolean type\n    if (type === Boolean) {\n        if (typeof value === 'string') {\n            // Convert exact string 'true' and 'false' to true and false respectively\n            if (value.toLowerCase() === 'true')\n                return true;\n            if (value.toLowerCase() === 'false')\n                return false;\n        }\n        else if (typeof value === 'number' && !isNaN(value)) {\n            // NaN can be error, so skipping it\n            return Boolean(value);\n        }\n    }\n    // If an array is what you want, I'll give you an array\n    if (type === Array)\n        return [value];\n    // Could not convert\n    return value;\n}\nexports.default = convertToProperType;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"setAutoValues.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean/setAutoValues.js                                                           //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sortAutoValueFunctions = void 0;\nconst AutoValueRunner_js_1 = __importDefault(require(\"./AutoValueRunner.js\"));\nconst getPositionsForAutoValue_js_1 = __importDefault(require(\"./getPositionsForAutoValue.js\"));\n/**\n * @method sortAutoValueFunctions\n * @private\n * @param autoValueFunctions - Array of objects to be sorted\n * @returns Sorted array\n *\n * Stable sort of the autoValueFunctions (preserves order at the same field depth).\n */\nfunction sortAutoValueFunctions(autoValueFunctions) {\n    const defaultFieldOrder = autoValueFunctions.reduce((acc, { fieldName }, index) => {\n        acc[fieldName] = index;\n        return acc;\n    }, {});\n    // Sort by how many dots each field name has, asc, such that we can auto-create\n    // objects and arrays before we run the autoValues for properties within them.\n    // Fields of the same level (same number of dots) preserve should order from the original array.\n    return autoValueFunctions.sort((a, b) => {\n        const depthDiff = a.fieldName.split('.').length - b.fieldName.split('.').length;\n        return depthDiff === 0\n            ? defaultFieldOrder[a.fieldName] - defaultFieldOrder[b.fieldName]\n            : depthDiff;\n    });\n}\nexports.sortAutoValueFunctions = sortAutoValueFunctions;\n/**\n * @method setAutoValues\n * @private\n * @param autoValueFunctions - An array of objects with func, fieldName, and closestSubschemaFieldName props\n * @param mongoObject\n * @param [isModifier=false] - Is it a modifier doc?\n * @param [extendedAutoValueContext] - Object that will be added to the context when calling each autoValue function\n *\n * Updates doc with automatic values from autoValue functions or default\n * values from defaultValue. Modifies the referenced object in place.\n */\nfunction setAutoValues(autoValueFunctions, mongoObject, isModifier, isUpsert, extendedAutoValueContext) {\n    const sortedAutoValueFunctions = sortAutoValueFunctions(autoValueFunctions);\n    sortedAutoValueFunctions.forEach(({ func, fieldName, closestSubschemaFieldName }) => {\n        const avRunner = new AutoValueRunner_js_1.default({\n            closestSubschemaFieldName,\n            extendedAutoValueContext,\n            func,\n            isModifier,\n            isUpsert,\n            mongoObject\n        });\n        const positions = (0, getPositionsForAutoValue_js_1.default)({\n            fieldName,\n            isModifier,\n            isUpsert,\n            mongoObject\n        });\n        // Run the autoValue function once for each place in the object that\n        // has a value or that potentially should.\n        // @ts-expect-error\n        positions.forEach(avRunner.runForPosition.bind(avRunner));\n    });\n}\nexports.default = setAutoValues;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"AutoValueRunner.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean/AutoValueRunner.js                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst clone_1 = __importDefault(require(\"clone\"));\nconst index_js_1 = require(\"../utility/index.js\");\nfunction getFieldInfo(mongoObject, key) {\n    var _a;\n    const keyInfo = (_a = mongoObject.getInfoForKey(key)) !== null && _a !== void 0 ? _a : {\n        operator: null,\n        value: undefined\n    };\n    return Object.assign(Object.assign({}, keyInfo), { isSet: keyInfo.value !== undefined });\n}\nclass AutoValueRunner {\n    constructor(options) {\n        this.doneKeys = [];\n        this.options = options;\n    }\n    runForPosition({ key: affectedKey, operator, position, value }) {\n        const { closestSubschemaFieldName, extendedAutoValueContext, func, isModifier, isUpsert, mongoObject } = this.options;\n        // If already called for this key, skip it\n        if (this.doneKeys.includes(affectedKey))\n            return;\n        const fieldParentName = (0, index_js_1.getParentOfKey)(affectedKey, true);\n        const parentFieldInfo = getFieldInfo(mongoObject, fieldParentName.slice(0, -1));\n        let doUnset = false;\n        if (Array.isArray(parentFieldInfo.value)) {\n            const innerKey = affectedKey.split('.').slice(-1).pop();\n            if (innerKey === undefined || isNaN(Number(innerKey))) {\n                // parent is an array, but the key to be set is not an integer (see issue #80)\n                return;\n            }\n        }\n        const autoValueContext = Object.assign({ closestSubschemaFieldName: closestSubschemaFieldName.length > 0\n                ? closestSubschemaFieldName\n                : null, field(fName) {\n                return getFieldInfo(mongoObject, closestSubschemaFieldName + fName);\n            },\n            isModifier,\n            isUpsert, isSet: value !== undefined, key: affectedKey, operator,\n            parentField() {\n                return parentFieldInfo;\n            },\n            siblingField(fName) {\n                return getFieldInfo(mongoObject, fieldParentName + fName);\n            },\n            unset() {\n                doUnset = true;\n            },\n            value }, (extendedAutoValueContext !== null && extendedAutoValueContext !== void 0 ? extendedAutoValueContext : {}));\n        const autoValue = func.call(autoValueContext, mongoObject.getObject());\n        // Update tracking of which keys we've run autovalue for\n        this.doneKeys.push(affectedKey);\n        if (doUnset && position != null)\n            mongoObject.removeValueForPosition(position);\n        if (autoValue === undefined)\n            return;\n        // If the user's auto value is of the pseudo-modifier format, parse it\n        // into operator and value.\n        if (isModifier) {\n            let op;\n            let newValue;\n            if (autoValue != null && typeof autoValue === 'object') {\n                const avOperator = Object.keys(autoValue).find((avProp) => avProp.substring(0, 1) === '$');\n                if (avOperator !== undefined) {\n                    op = avOperator;\n                    newValue = autoValue[avOperator];\n                }\n            }\n            // Add $set for updates and upserts if necessary. Keep this\n            // above the \"if (op)\" block below since we might change op\n            // in this line.\n            if (op == null && position.slice(0, 1) !== '$') {\n                op = '$set';\n                newValue = autoValue;\n            }\n            if (op != null) {\n                // Update/change value\n                mongoObject.removeValueForPosition(position);\n                mongoObject.setValueForPosition(`${op}[${affectedKey}]`, (0, clone_1.default)(newValue));\n                return;\n            }\n        }\n        // Update/change value. Cloning is necessary in case it's an object, because\n        // if we later set some keys within it, they'd be set on the original object, too.\n        mongoObject.setValueForPosition(position, (0, clone_1.default)(autoValue));\n    }\n}\nexports.default = AutoValueRunner;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"getPositionsForAutoValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/clean/getPositionsForAutoValue.js                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\nconst index_js_1 = require(\"../utility/index.js\");\n/**\n * A position is a place in the object where this field exists.\n * If no arrays are involved, then every field/key has at most 1 position.\n * If arrays are involved, then a field could have potentially unlimited positions.\n *\n * For example, the key 'a.b.$.c` would have these positions:\n *   `a[b][0][c]`\n *   `a[b][1][c]`\n *   `a[b][2][c]`\n *\n * For this object:\n * {\n *   a: {\n *     b: [\n *       { c: 1 },\n *       { c: 1 },\n *       { c: 1 },\n *     ],\n *   },\n * }\n *\n * To make matters more complicated, we want to include not only the existing positions\n * but also the positions that might exist due to their parent object existing or their\n * parent object being auto-created by a MongoDB modifier that implies it.\n */\nfunction getPositionsForAutoValue({ fieldName, isModifier, isUpsert, mongoObject }) {\n    // Positions for this field\n    const positions = mongoObject.getPositionsInfoForGenericKey(fieldName);\n    // If the field is an object and will be created by MongoDB,\n    // we don't need (and can't have) a value for it\n    if (isModifier === true &&\n        mongoObject.getPositionsThatCreateGenericKey(fieldName).length > 0) {\n        return positions;\n    }\n    // For simple top-level fields, just add an undefined would-be position\n    // if there isn't a real position.\n    if (!fieldName.includes('.') && positions.length === 0) {\n        positions.push({\n            key: fieldName,\n            // @ts-expect-error incorrect type in mongo-object package\n            value: undefined,\n            operator: isModifier === true ? '$set' : null,\n            position: isModifier === true ? `$set[${fieldName}]` : fieldName\n        });\n        return positions;\n    }\n    const parentPath = (0, index_js_1.getParentOfKey)(fieldName);\n    const lastPart = (0, index_js_1.getLastPartOfKey)(fieldName, parentPath);\n    const lastPartWithBraces = lastPart.replace(/\\./g, '][');\n    const parentPositions = mongoObject.getPositionsInfoForGenericKey(parentPath);\n    if (parentPositions.length > 0) {\n        parentPositions.forEach((info) => {\n            const childPosition = `${info.position}[${lastPartWithBraces}]`;\n            if (positions.find((i) => i.position === childPosition) == null) {\n                positions.push({\n                    key: `${info.key}.${lastPart}`,\n                    // @ts-expect-error incorrect type in mongo-object package\n                    value: undefined,\n                    operator: info.operator,\n                    position: childPosition\n                });\n            }\n        });\n    }\n    else if (parentPath.slice(-2) !== '.$') {\n        // positions that will create parentPath\n        mongoObject.getPositionsThatCreateGenericKey(parentPath).forEach((info) => {\n            const { operator, position } = info;\n            let wouldBePosition;\n            if (operator != null) {\n                const next = position.slice(position.indexOf('[') + 1, position.indexOf(']'));\n                const nextPieces = next.split('.');\n                const newPieces = [];\n                let newKey = '';\n                while ((nextPieces.length > 0) && newKey !== parentPath) {\n                    newPieces.push(nextPieces.shift());\n                    newKey = newPieces.join('.');\n                }\n                newKey = `${newKey}.${fieldName.slice(newKey.length + 1)}`;\n                wouldBePosition = `$set[${newKey}]`;\n            }\n            else {\n                const lastPart2 = (0, index_js_1.getLastPartOfKey)(fieldName, parentPath);\n                const lastPartWithBraces2 = lastPart2.replace(/\\./g, '][');\n                wouldBePosition = `${position.slice(0, position.lastIndexOf('['))}[${lastPartWithBraces2}]`;\n            }\n            if (positions.find((item) => item.position === wouldBePosition) == null) {\n                const key = mongo_object_1.default._positionToKey(wouldBePosition);\n                if (key != null) {\n                    positions.push({\n                        key,\n                        // @ts-expect-error incorrect type in mongo-object package\n                        value: undefined,\n                        operator: operator == null ? null : '$set',\n                        position: wouldBePosition\n                    });\n                }\n            }\n        });\n    }\n    // If we made it this far, we still want to call the autoValue\n    // function once for the field, so we'll add a would-be position for it.\n    if (positions.length === 0 && isModifier === true && isUpsert !== true) {\n        positions.push({\n            key: fieldName,\n            // @ts-expect-error incorrect type in mongo-object package\n            value: undefined,\n            operator: '$set',\n            position: `$set[${fieldName}]`\n        });\n    }\n    return positions;\n}\nexports.default = getPositionsForAutoValue;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"SimpleSchema.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/SimpleSchema.js                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValidationContext = exports.SimpleSchema = exports.schemaDefinitionOptions = void 0;\n/* eslint-disable no-undef */\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\nconst clean_js_1 = __importDefault(require(\"./clean.js\"));\nconst defaultMessages_js_1 = require(\"./defaultMessages.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst expandShorthand_js_1 = __importDefault(require(\"./expandShorthand.js\"));\nconst SimpleSchemaGroup_js_1 = __importDefault(require(\"./SimpleSchemaGroup.js\"));\nconst index_js_1 = require(\"./utility/index.js\");\nconst ValidationContext_js_1 = __importDefault(require(\"./ValidationContext.js\"));\nexports.ValidationContext = ValidationContext_js_1.default;\nexports.schemaDefinitionOptions = [\n    'autoValue',\n    'defaultValue',\n    'label',\n    'optional',\n    'required',\n    'type'\n];\nconst oneOfProps = [\n    'allowedValues',\n    'blackbox',\n    'custom',\n    'exclusiveMax',\n    'exclusiveMin',\n    'max',\n    'maxCount',\n    'min',\n    'minCount',\n    'regEx',\n    'skipRegExCheckForEmptyStrings',\n    'trim',\n    'type'\n];\nconst propsThatCanBeFunction = [\n    'allowedValues',\n    'exclusiveMax',\n    'exclusiveMin',\n    'label',\n    'max',\n    'maxCount',\n    'min',\n    'minCount',\n    'optional',\n    'regEx',\n    'skipRegExCheckForEmptyStrings'\n];\nclass SimpleSchema {\n    constructor(schema = {}, options = {}) {\n        var _a;\n        this._autoValues = [];\n        this._blackboxKeys = new Set();\n        this._cleanOptions = {};\n        this._constructorOptions = {};\n        this._docValidators = [];\n        this._firstLevelSchemaKeys = [];\n        this._rawDefinition = null;\n        this._schema = {};\n        this._schemaKeys = [];\n        // Named validation contexts\n        this._validationContexts = {};\n        this._validators = [];\n        /**\n         * @method SimpleSchema#pick\n         * @param {[fields]} The list of fields to pick to instantiate the subschema\n         * @returns {SimpleSchema} The subschema\n         */\n        this.pick = getPickOrOmit('pick');\n        /**\n         * @method SimpleSchema#omit\n         * @param {[fields]} The list of fields to omit to instantiate the subschema\n         * @returns {SimpleSchema} The subschema\n         */\n        this.omit = getPickOrOmit('omit');\n        // Stash the options object\n        this._constructorOptions = Object.assign(Object.assign({}, SimpleSchema._constructorOptionDefaults), options);\n        delete this._constructorOptions.clean; // stored separately below\n        Object.getOwnPropertyNames(this._constructorOptions).forEach((opt) => {\n            if (!SimpleSchema.supportedConstructorOptions.has(opt)) {\n                console.warn(`Unsupported \"${opt}\" option passed to SimpleSchema constructor`);\n            }\n        });\n        // Schema-level defaults for cleaning\n        this._cleanOptions = Object.assign(Object.assign({}, SimpleSchema._constructorOptionDefaults.clean), ((_a = options.clean) !== null && _a !== void 0 ? _a : {}));\n        // Custom validators for this instance\n        this._docValidators = [];\n        // Clone, expanding shorthand, and store the schema object in this._schema\n        this.extend(schema);\n        // Clone raw definition and save if keepRawDefinition is active\n        if (this._constructorOptions.keepRawDefinition === true) {\n            this._rawDefinition = schema;\n        }\n        this.version = SimpleSchema.version;\n    }\n    /**\n    /* @returns The entire raw schema definition passed in the constructor\n    */\n    get rawDefinition() {\n        return this._rawDefinition;\n    }\n    forEachAncestorSimpleSchema(key, func) {\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\n        if (genericKey == null)\n            return;\n        (0, index_js_1.forEachKeyAncestor)(genericKey, (ancestor) => {\n            const def = this._schema[ancestor];\n            if (def == null)\n                return;\n            def.type.definitions.forEach((typeDef) => {\n                if (SimpleSchema.isSimpleSchema(typeDef.type)) {\n                    func(typeDef.type, ancestor, genericKey.slice(ancestor.length + 1));\n                }\n            });\n        });\n    }\n    /**\n     * Returns whether the obj is a SimpleSchema object.\n     * @param [obj] An object to test\n     * @returns True if the given object appears to be a SimpleSchema instance\n     */\n    static isSimpleSchema(obj) {\n        if (obj == null)\n            return false;\n        return obj instanceof SimpleSchema || Object.prototype.hasOwnProperty.call(obj, '_schema');\n    }\n    /**\n     * @param key One specific or generic key for which to get the schema.\n     * @returns Returns a 2-tuple.\n     *\n     *   First item: The SimpleSchema instance that actually defines the given key.\n     *\n     *   For example, if you have several nested objects, each their own SimpleSchema\n     *   instance, and you pass in 'outerObj.innerObj.innermostObj.name' as the key, you'll\n     *   get back the SimpleSchema instance for `outerObj.innerObj.innermostObj` key.\n     *\n     *   But if you pass in 'outerObj.innerObj.innermostObj.name' as the key and that key is\n     *   defined in the main schema without use of subschemas, then you'll get back the main schema.\n     *\n     *   Second item: The part of the key that is in the found schema.\n     *\n     *   Always returns a tuple (array) but the values may be `null`.\n     */\n    nearestSimpleSchemaInstance(key) {\n        if (key == null)\n            return [null, null];\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\n        if (genericKey == null)\n            return [null, null];\n        if (this._schema[genericKey] !== undefined)\n            return [this, genericKey];\n        // If not defined in this schema, see if it's defined in a sub-schema\n        let innerKey;\n        let nearestSimpleSchemaInstance = null;\n        this.forEachAncestorSimpleSchema(key, (simpleSchema, ancestor, subSchemaKey) => {\n            if ((nearestSimpleSchemaInstance == null) &&\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                simpleSchema._schema[subSchemaKey]) {\n                nearestSimpleSchemaInstance = simpleSchema;\n                innerKey = subSchemaKey;\n            }\n        });\n        return innerKey != null ? [nearestSimpleSchemaInstance, innerKey] : [null, null];\n    }\n    schema(key) {\n        if (key == null)\n            return this._schema;\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\n        let keySchema = genericKey == null ? null : this._schema[genericKey];\n        // If not defined in this schema, see if it's defined in a subschema\n        if (keySchema == null) {\n            let found = false;\n            this.forEachAncestorSimpleSchema(key, (simpleSchema, ancestor, subSchemaKey) => {\n                if (!found)\n                    keySchema = simpleSchema.schema(subSchemaKey);\n                if (keySchema != null)\n                    found = true;\n            });\n        }\n        return keySchema;\n    }\n    /**\n     * @param key One specific or generic key for which to get all possible schemas.\n     * @returns An potentially empty array of possible definitions for one key\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n    schemas(key) {\n        const schemas = [];\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\n        const keySchema = genericKey == null ? null : this._schema[genericKey];\n        if (keySchema != null)\n            schemas.push(keySchema);\n        // See if it's defined in any subschema\n        this.forEachAncestorSimpleSchema(key, (simpleSchema, ancestor, subSchemaKey) => {\n            const keyDef = simpleSchema.schema(subSchemaKey);\n            if (keyDef != null)\n                schemas.push(keyDef);\n        });\n        return schemas;\n    }\n    /**\n     * @returns {Object} The entire schema object with subschemas merged. This is the\n     * equivalent of what schema() returned in SimpleSchema < 2.0\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n    mergedSchema() {\n        const mergedSchema = {};\n        this._schemaKeys.forEach((key) => {\n            const keySchema = this._schema[key];\n            mergedSchema[key] = keySchema;\n            keySchema.type.definitions.forEach((typeDef) => {\n                if (!SimpleSchema.isSimpleSchema(typeDef.type))\n                    return;\n                const childSchema = typeDef.type.mergedSchema();\n                Object.keys(childSchema).forEach((subKey) => {\n                    mergedSchema[`${key}.${subKey}`] = childSchema[subKey];\n                });\n            });\n        });\n        return mergedSchema;\n    }\n    /**\n     * Returns the evaluated definition for one key in the schema\n     *\n     * @param key Generic or specific schema key\n     * @param [propList] Array of schema properties you need; performance optimization\n     * @param [functionContext] The context to use when evaluating schema options that are functions\n     * @returns The schema definition for the requested key\n     */\n    getDefinition(key, propList, functionContext = {}) {\n        const schemaKeyDefinition = this.schema(key);\n        if (schemaKeyDefinition == null)\n            return;\n        return this.resolveDefinitionForSchema(key, schemaKeyDefinition, propList, functionContext);\n    }\n    /**\n     * Returns the evaluated definition for one key in the schema\n     *\n     * @param key Generic or specific schema key\n     * @param [propList] Array of schema properties you need; performance optimization\n     * @param [functionContext] The context to use when evaluating schema options that are functions\n     * @returns The schema definition for the requested key\n     */\n    getDefinitions(key, propList, functionContext = {}) {\n        const schemaKeyDefinitions = this.schemas(key);\n        return schemaKeyDefinitions.map((def) => {\n            return this.resolveDefinitionForSchema(key, def, propList, functionContext);\n        });\n    }\n    /**\n     * Resolves the definition for one key in the schema\n     *\n     * @param key Generic or specific schema key\n     * @param schemaKeyDefinition Unresolved definition as returned from simpleSchema.schema()\n     * @param [propList] Array of schema properties you need; performance optimization\n     * @param [functionContext] The context to use when evaluating schema options that are functions\n     * @returns The schema definition for the requested key\n     */\n    resolveDefinitionForSchema(key, schemaKeyDefinition, propList, functionContext = {}) {\n        var _a;\n        const getPropIterator = (obj, newObj) => {\n            return (prop) => {\n                if (Array.isArray(propList) && !propList.includes(prop))\n                    return;\n                const val = obj[prop];\n                // For any options that support specifying a function, evaluate the functions\n                if (propsThatCanBeFunction.includes(prop) &&\n                    typeof val === 'function') {\n                    newObj[prop] = val.call(Object.assign({ key }, functionContext));\n                    // Inflect label if undefined\n                    if (prop === 'label' && typeof newObj.label !== 'string') {\n                        newObj.label = inflectedLabel(key, this._constructorOptions.humanizeAutoLabels);\n                    }\n                }\n                else {\n                    newObj[prop] = val;\n                }\n            };\n        };\n        const result = {\n            type: []\n        };\n        Object.keys(schemaKeyDefinition).forEach(getPropIterator(schemaKeyDefinition, result));\n        // Resolve all the types and convert to a normal array to make it easier to use.\n        if (Array.isArray((_a = schemaKeyDefinition.type) === null || _a === void 0 ? void 0 : _a.definitions)) {\n            result.type = schemaKeyDefinition.type.definitions.map((typeDef) => {\n                const newTypeDef = {\n                    type: String // will be overwritten\n                };\n                Object.keys(typeDef).forEach(getPropIterator(typeDef, newTypeDef));\n                return newTypeDef;\n            });\n        }\n        return result;\n    }\n    /**\n     * Returns a string identifying the best guess data type for a key. For keys\n     * that allow multiple types, the first type is used. This can be useful for\n     * building forms.\n     *\n     * @param key Generic or specific schema key\n     * @returns A type string. One of:\n     *  string, number, boolean, date, object, stringArray, numberArray, booleanArray,\n     *  dateArray, objectArray\n     */\n    getQuickTypeForKey(key) {\n        let type;\n        const fieldSchema = this.schema(key);\n        if (fieldSchema == null)\n            return;\n        const fieldType = (fieldSchema.type).singleType;\n        if (fieldType === String) {\n            type = 'string';\n        }\n        else if (fieldType === Number || fieldType === SimpleSchema.Integer) {\n            type = 'number';\n        }\n        else if (fieldType === Boolean) {\n            type = 'boolean';\n        }\n        else if (fieldType === Date) {\n            type = 'date';\n        }\n        else if (fieldType === Array) {\n            const arrayItemFieldSchema = this.schema(`${key}.$`);\n            if (arrayItemFieldSchema == null)\n                return;\n            const arrayItemFieldType = (arrayItemFieldSchema.type).singleType;\n            if (arrayItemFieldType === String) {\n                type = 'stringArray';\n            }\n            else if (arrayItemFieldType === Number ||\n                arrayItemFieldType === SimpleSchema.Integer) {\n                type = 'numberArray';\n            }\n            else if (arrayItemFieldType === Boolean) {\n                type = 'booleanArray';\n            }\n            else if (arrayItemFieldType === Date) {\n                type = 'dateArray';\n            }\n            else if (arrayItemFieldType === Object ||\n                SimpleSchema.isSimpleSchema(arrayItemFieldType)) {\n                type = 'objectArray';\n            }\n        }\n        else if (fieldType === Object) {\n            type = 'object';\n        }\n        return type;\n    }\n    /**\n     * Given a key that is an Object, returns a new SimpleSchema instance scoped to that object.\n     *\n     * @param key Generic or specific schema key\n     */\n    getObjectSchema(key) {\n        const newSchemaDef = {};\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\n        if (genericKey == null)\n            throw new Error(`Unable to make a generic key for ${key}`);\n        const searchString = `${genericKey}.`;\n        const mergedSchema = this.mergedSchema();\n        Object.keys(mergedSchema).forEach((k) => {\n            if (k.indexOf(searchString) === 0) {\n                newSchemaDef[k.slice(searchString.length)] = mergedSchema[k];\n            }\n        });\n        return this._copyWithSchema(newSchemaDef);\n    }\n    // Returns an array of all the autovalue functions, including those in subschemas all the\n    // way down the schema tree\n    autoValueFunctions() {\n        const result = [...this._autoValues];\n        this._schemaKeys.forEach((key) => {\n            this._schema[key].type.definitions.forEach((typeDef) => {\n                if (!SimpleSchema.isSimpleSchema(typeDef.type))\n                    return;\n                result.push(...typeDef.type\n                    .autoValueFunctions()\n                    .map(({ func, fieldName, closestSubschemaFieldName }) => {\n                    return {\n                        func,\n                        fieldName: `${key}.${fieldName}`,\n                        closestSubschemaFieldName: closestSubschemaFieldName.length > 0\n                            ? `${key}.${closestSubschemaFieldName}`\n                            : key\n                    };\n                }));\n            });\n        });\n        return result;\n    }\n    // Returns an array of all the blackbox keys, including those in subschemas\n    blackboxKeys() {\n        const blackboxKeys = new Set(this._blackboxKeys);\n        this._schemaKeys.forEach((key) => {\n            this._schema[key].type.definitions.forEach((typeDef) => {\n                if (!SimpleSchema.isSimpleSchema(typeDef.type))\n                    return;\n                typeDef.type.blackboxKeys().forEach((blackboxKey) => {\n                    blackboxKeys.add(`${key}.${blackboxKey}`);\n                });\n            });\n        });\n        return Array.from(blackboxKeys);\n    }\n    /**\n     * Check if the key is a nested dot-syntax key inside of a blackbox object\n     * @param key Key to check\n     * @returns True if key is in a black box object\n     */\n    keyIsInBlackBox(key) {\n        const genericKey = mongo_object_1.default.makeKeyGeneric(key);\n        if (genericKey == null)\n            return false;\n        let isInBlackBox = false;\n        (0, index_js_1.forEachKeyAncestor)(genericKey, (ancestor, remainder) => {\n            if (this._blackboxKeys.has(ancestor)) {\n                isInBlackBox = true;\n            }\n            else {\n                const testKeySchema = this.schema(ancestor);\n                if (testKeySchema != null) {\n                    testKeySchema.type.definitions.forEach((typeDef) => {\n                        if (!SimpleSchema.isSimpleSchema(typeDef.type))\n                            return;\n                        if (typeDef.type.keyIsInBlackBox(remainder))\n                            isInBlackBox = true;\n                    });\n                }\n            }\n        });\n        return isInBlackBox;\n    }\n    // Returns true if key is explicitly allowed by the schema or implied\n    // by other explicitly allowed keys.\n    // The key string should have $ in place of any numeric array positions.\n    allowsKey(key) {\n        // Loop through all keys in the schema\n        return this._schemaKeys.some((loopKey) => {\n            var _a;\n            // If the schema key is the test key, it's allowed.\n            if (loopKey === key)\n                return true;\n            const compare1 = key.slice(0, loopKey.length + 2);\n            const compare2 = compare1.slice(0, -1);\n            // Blackbox and subschema checks are needed only if key starts with\n            // loopKey + a dot\n            if (compare2 !== `${loopKey}.`)\n                return false;\n            // Black box handling\n            if (this._blackboxKeys.has(loopKey)) {\n                // If the test key is the black box key + \".$\", then the test\n                // key is NOT allowed because black box keys are by definition\n                // only for objects, and not for arrays.\n                return compare1 !== `${loopKey}.$`;\n            }\n            // Subschemas\n            let allowed = false;\n            const subKey = key.slice(loopKey.length + 1);\n            (_a = this.schema(loopKey)) === null || _a === void 0 ? void 0 : _a.type.definitions.forEach((typeDef) => {\n                if (!SimpleSchema.isSimpleSchema(typeDef.type))\n                    return;\n                if (typeDef.type.allowsKey(subKey))\n                    allowed = true;\n            });\n            return allowed;\n        });\n    }\n    /**\n     * Returns all the child keys for the object identified by the generic prefix,\n     * or all the top level keys if no prefix is supplied.\n     *\n     * @param [keyPrefix] The Object-type generic key for which to get child keys. Omit for\n     *   top-level Object-type keys\n     * @returns Array of child keys for the given object key\n     */\n    objectKeys(keyPrefix) {\n        var _a;\n        if (keyPrefix == null)\n            return this._firstLevelSchemaKeys;\n        const objectKeys = {};\n        const setObjectKeys = (curSchema, schemaParentKey) => {\n            Object.keys(curSchema).forEach((fieldName) => {\n                var _a;\n                const definition = curSchema[fieldName];\n                fieldName = schemaParentKey != null ? `${schemaParentKey}.${fieldName}` : fieldName;\n                if (fieldName.includes('.') && fieldName.slice(-2) !== '.$') {\n                    const parentKey = fieldName.slice(0, fieldName.lastIndexOf('.'));\n                    const parentKeyWithDot = `${parentKey}.`;\n                    objectKeys[parentKeyWithDot] = (_a = objectKeys[parentKeyWithDot]) !== null && _a !== void 0 ? _a : [];\n                    objectKeys[parentKeyWithDot].push(fieldName.slice(fieldName.lastIndexOf('.') + 1));\n                }\n                // If the current field is a nested SimpleSchema,\n                // iterate over the child fields and cache their properties as well\n                definition.type.definitions.forEach(({ type }) => {\n                    if (SimpleSchema.isSimpleSchema(type)) {\n                        setObjectKeys(type._schema, fieldName);\n                    }\n                });\n            });\n        };\n        setObjectKeys(this._schema);\n        return (_a = objectKeys[`${keyPrefix}.`]) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Copies this schema into a new instance with the same validators, messages,\n     * and options, but with different keys as defined in `schema` argument\n     *\n     * @param schema\n     * @returns The new SimpleSchema instance (chainable)\n     */\n    _copyWithSchema(schema) {\n        const cl = new SimpleSchema(schema, Object.assign({}, this._constructorOptions));\n        cl._cleanOptions = this._cleanOptions;\n        return cl;\n    }\n    /**\n     * Clones this schema into a new instance with the same schema keys, validators,\n     * and options.\n     *\n     * @returns The new SimpleSchema instance (chainable)\n     */\n    clone() {\n        return this._copyWithSchema(this._schema);\n    }\n    /**\n     * Extends (mutates) this schema with another schema, key by key.\n     *\n     * @param schema The schema or schema definition to extend onto this one\n     * @returns The SimpleSchema instance (chainable)\n     */\n    extend(schema = {}) {\n        if (Array.isArray(schema)) {\n            throw new Error('You may not pass an array of schemas to the SimpleSchema constructor or to extend()');\n        }\n        let schemaObj;\n        if (SimpleSchema.isSimpleSchema(schema)) {\n            schemaObj = schema._schema;\n            this._validators = this._validators.concat(schema._validators);\n            this._docValidators = this._docValidators.concat(schema._docValidators);\n            Object.assign(this._cleanOptions, schema._cleanOptions);\n            Object.assign(this._constructorOptions, schema._constructorOptions);\n        }\n        else {\n            schemaObj = (0, expandShorthand_js_1.default)(schema);\n        }\n        const schemaKeys = Object.keys(schemaObj);\n        const combinedKeys = new Set([...Object.keys(this._schema), ...schemaKeys]);\n        // Update all of the information cached on the instance\n        schemaKeys.forEach((fieldName) => {\n            const definition = standardizeDefinition(schemaObj[fieldName]);\n            // Merge/extend with any existing definition\n            if (this._schema[fieldName] != null) {\n                if (!Object.prototype.hasOwnProperty.call(this._schema, fieldName)) {\n                    // fieldName is actually a method from Object itself!\n                    throw new Error(`${fieldName} key is actually the name of a method on Object, please rename it`);\n                }\n                const { type } = definition, definitionWithoutType = __rest(definition, [\"type\"]); // eslint-disable-line no-unused-vars\n                this._schema[fieldName] = Object.assign(Object.assign({}, this._schema[fieldName]), definitionWithoutType);\n                if (definition.type != null) {\n                    this._schema[fieldName].type.extend(definition.type);\n                }\n            }\n            else {\n                this._schema[fieldName] = definition;\n            }\n            checkAndScrubDefinition(fieldName, this._schema[fieldName], this._constructorOptions, combinedKeys);\n        });\n        checkSchemaOverlap(this._schema);\n        // Set/Reset all of these\n        this._schemaKeys = Object.keys(this._schema);\n        this._autoValues = [];\n        this._blackboxKeys = new Set();\n        this._firstLevelSchemaKeys = [];\n        // Update all of the information cached on the instance\n        this._schemaKeys.forEach((fieldName) => {\n            // Make sure parent has a definition in the schema. No implied objects!\n            if (fieldName.includes('.')) {\n                const parentFieldName = fieldName.slice(0, fieldName.lastIndexOf('.'));\n                if (!Object.prototype.hasOwnProperty.call(this._schema, parentFieldName)) {\n                    throw new Error(`\"${fieldName}\" is in the schema but \"${parentFieldName}\" is not`);\n                }\n            }\n            const definition = this._schema[fieldName];\n            // Keep list of all top level keys\n            if (!fieldName.includes('.')) {\n                this._firstLevelSchemaKeys.push(fieldName);\n            }\n            // Keep list of all blackbox keys for passing to MongoObject constructor\n            // XXX For now if any oneOf type is blackbox, then the whole field is.\n            /* eslint-disable no-restricted-syntax */\n            for (const oneOfDef of definition.type.definitions) {\n                // XXX If the type is SS.Any, also consider it a blackbox\n                if (oneOfDef.blackbox === true || oneOfDef.type === SimpleSchema.Any) {\n                    this._blackboxKeys.add(fieldName);\n                    break;\n                }\n            }\n            /* eslint-enable no-restricted-syntax */\n            // Keep list of autoValue functions\n            if (typeof definition.autoValue === 'function') {\n                this._autoValues.push({\n                    closestSubschemaFieldName: '',\n                    fieldName,\n                    func: definition.autoValue\n                });\n            }\n        });\n        return this;\n    }\n    getAllowedValuesForKey(key) {\n        // For array fields, `allowedValues` is on the array item definition\n        if (this.allowsKey(`${key}.$`)) {\n            key = `${key}.$`;\n        }\n        const allowedValues = this.get(key, 'allowedValues');\n        if (Array.isArray(allowedValues) || allowedValues instanceof Set) {\n            return [...allowedValues];\n        }\n        return null;\n    }\n    newContext() {\n        return new ValidationContext_js_1.default(this);\n    }\n    namedContext(name) {\n        if (typeof name !== 'string')\n            name = 'default';\n        if (this._validationContexts[name] == null) {\n            this._validationContexts[name] = new ValidationContext_js_1.default(this, name);\n        }\n        return this._validationContexts[name];\n    }\n    addValidator(func) {\n        this._validators.push(func);\n    }\n    addDocValidator(func) {\n        this._docValidators.push(func);\n    }\n    /**\n     * @param obj Object or array of objects to validate.\n     * @param options Same options object that ValidationContext#validate takes\n     *\n     * Throws an Error with name `ClientError` and `details` property containing the errors.\n     */\n    validate(obj, options = {}) {\n        // obj can be an array, in which case we validate each object in it and\n        // throw as soon as one has an error\n        const objects = Array.isArray(obj) ? obj : [obj];\n        objects.forEach((oneObj) => {\n            const validationContext = this.newContext();\n            const isValid = validationContext.validate(oneObj, options);\n            if (isValid)\n                return;\n            const errors = validationContext.validationErrors();\n            // In order for the message at the top of the stack trace to be useful,\n            // we set it to the first validation error message.\n            const message = this.messageForError(errors[0]);\n            const error = new errors_js_1.ClientError(message, 'validation-error');\n            // Add meaningful error messages for each validation error.\n            // Useful for display messages when using 'mdg:validated-method'.\n            error.details = errors.map((errorDetail) => (Object.assign(Object.assign({}, errorDetail), { message: this.messageForError(errorDetail) })));\n            // The primary use for the validationErrorTransform is to convert the\n            // vanilla Error into a Meteor.Error until DDP is able to pass\n            // vanilla errors back to the client.\n            if (typeof SimpleSchema.validationErrorTransform === 'function') {\n                throw SimpleSchema.validationErrorTransform(error);\n            }\n            else {\n                throw error;\n            }\n        });\n    }\n    /**\n     * @param obj Object to validate.\n     * @param options Same options object that ValidationContext#validate takes\n     *\n     * Returns a Promise that resolves with the errors\n     */\n    validateAndReturnErrorsPromise(obj, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const validationContext = this.newContext();\n            const isValid = validationContext.validate(obj, options);\n            if (isValid)\n                return [];\n            // Add the `message` prop\n            return validationContext.validationErrors().map((errorDetail) => {\n                return Object.assign(Object.assign({}, errorDetail), { message: this.messageForError(errorDetail) });\n            });\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n    validator(options = {}) {\n        return (obj) => {\n            const { clean, returnErrorsPromise } = options, validationOptions = __rest(options\n            // Do this here and pass into both functions for better performance\n            , [\"clean\", \"returnErrorsPromise\"]);\n            // Do this here and pass into both functions for better performance\n            const mongoObject = new mongo_object_1.default(obj, this.blackboxKeys());\n            if (clean === true) {\n                this.clean(obj, { mongoObject });\n            }\n            return returnErrorsPromise === true ? this.validateAndReturnErrorsPromise(obj, Object.assign(Object.assign({}, validationOptions), { mongoObject })) : this.validate(obj, Object.assign(Object.assign({}, validationOptions), { mongoObject }));\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n    getFormValidator(options = {}) {\n        return this.validator(Object.assign(Object.assign({}, options), { returnErrorsPromise: true }));\n    }\n    clean(doc, options = {}) {\n        return (0, clean_js_1.default)(this, doc, options);\n    }\n    /**\n     * Change schema labels on the fly. Useful when the user changes the language.\n     *\n     * @param labels A dictionary of all the new label values, by schema key.\n     */\n    labels(labels) {\n        for (const [key, label] of Object.entries(labels)) {\n            if (typeof label !== 'string' && typeof label !== 'function')\n                continue;\n            // Support setting labels that were actually originally defined in a sub-schema\n            const [schemaInstance, innerKey] = this.nearestSimpleSchemaInstance(key);\n            if (schemaInstance == null || innerKey == null)\n                continue;\n            schemaInstance._schema[innerKey].label = label;\n        }\n    }\n    label(key) {\n        // Get all labels\n        if (key === null || key === undefined) {\n            const result = {};\n            this._schemaKeys.forEach((schemaKey) => {\n                result[schemaKey] = this.label(schemaKey);\n            });\n            return result;\n        }\n        // Get label for one field\n        const label = this.get(key, 'label');\n        return label !== null && label !== void 0 ? label : null;\n    }\n    /**\n     * Gets a field's property\n     *\n     * @param key The schema key, specific or generic.\n     * @param prop Name of the property to get for that schema key\n     * @param functionContext The `this` context to use if prop is a function\n     * @returns The property value\n     */\n    get(key, prop, functionContext) {\n        const def = this.getDefinition(key, ['type', prop], functionContext);\n        if (def == null)\n            return undefined;\n        if (exports.schemaDefinitionOptions.includes(prop)) {\n            return def[prop];\n        }\n        const oneType = def.type[0];\n        if (oneType === SimpleSchema.Any)\n            return undefined;\n        return oneType === null || oneType === void 0 ? void 0 : oneType[prop];\n    }\n    // shorthand for getting defaultValue\n    defaultValue(key) {\n        return this.get(key, 'defaultValue');\n    }\n    // Returns a string message for the given error type and key.\n    // Defers to a user-provided getErrorMessage function, which\n    // can do custom messages and translations, or falls back to\n    // built-in English defaults.\n    messageForError(errorInfo) {\n        var _a, _b;\n        const { name } = errorInfo;\n        const label = this.label(name);\n        let message;\n        if (this._constructorOptions.getErrorMessage !== undefined) {\n            message = this._constructorOptions.getErrorMessage(errorInfo, label);\n            if (message !== undefined)\n                return message;\n        }\n        if (((_a = globalThis.simpleSchemaGlobalConfig) === null || _a === void 0 ? void 0 : _a.getErrorMessage) !== undefined) {\n            message = (_b = globalThis.simpleSchemaGlobalConfig) === null || _b === void 0 ? void 0 : _b.getErrorMessage(errorInfo, label);\n            if (message !== undefined)\n                return message;\n        }\n        return (0, defaultMessages_js_1.getDefaultErrorMessage)(errorInfo, label);\n    }\n    /**\n     * If you need to allow properties other than those listed above, call this from your app or package\n     * @param options Additional allowed options\n     */\n    static extendOptions(options) {\n        exports.schemaDefinitionOptions.push(...options);\n    }\n    static defineValidationErrorTransform(transform) {\n        if (typeof transform !== 'function') {\n            throw new Error('SimpleSchema.defineValidationErrorTransform must be passed a function that accepts an Error and returns an Error');\n        }\n        SimpleSchema.validationErrorTransform = transform;\n    }\n    static validate(obj, schema, options) {\n        // Allow passing just the schema object\n        if (!SimpleSchema.isSimpleSchema(schema)) {\n            schema = new SimpleSchema(schema);\n        }\n        return schema.validate(obj, options);\n    }\n    static oneOf(...definitions) {\n        return new SimpleSchemaGroup_js_1.default(...definitions);\n    }\n    static addValidator(func) {\n        SimpleSchema._validators.push(func);\n    }\n    static addDocValidator(func) {\n        SimpleSchema._docValidators.push(func);\n    }\n    /**\n     * @summary Get/set default values for SimpleSchema constructor options\n     */\n    static constructorOptionDefaults(options) {\n        var _a;\n        if (options == null)\n            return SimpleSchema._constructorOptionDefaults;\n        SimpleSchema._constructorOptionDefaults = Object.assign(Object.assign(Object.assign({}, SimpleSchema._constructorOptionDefaults), options), { clean: Object.assign(Object.assign({}, SimpleSchema._constructorOptionDefaults.clean), ((_a = options.clean) !== null && _a !== void 0 ? _a : {})) });\n    }\n}\nexports.SimpleSchema = SimpleSchema;\n/**\n * Packages that want to allow and check additional options\n * should add the option names to this set.\n */\nSimpleSchema.supportedConstructorOptions = new Set([\n    'clean',\n    'getErrorMessage',\n    'humanizeAutoLabels',\n    'keepRawDefinition',\n    'requiredByDefault',\n    'defaultLabel'\n]);\n/**\n * Packages that want to allow and check additional options\n * should add the option names to this set.\n */\nSimpleSchema.supportedCleanOptions = new Set([\n    'autoConvert',\n    'extendAutoValueContext',\n    'filter',\n    'getAutoValues',\n    'isModifier',\n    'isUpsert',\n    'mongoObject',\n    'mutate',\n    'removeEmptyStrings',\n    'removeNullsFromArrays',\n    'trimStrings'\n]);\nSimpleSchema.version = 2;\n// Global constructor options\nSimpleSchema._constructorOptionDefaults = {\n    clean: {\n        autoConvert: true,\n        extendAutoValueContext: {},\n        filter: true,\n        getAutoValues: true,\n        removeEmptyStrings: true,\n        removeNullsFromArrays: false,\n        trimStrings: true\n    },\n    humanizeAutoLabels: true,\n    requiredByDefault: true\n};\nSimpleSchema._docValidators = [];\nSimpleSchema._validators = [];\nSimpleSchema.Any = '___Any___';\nSimpleSchema.ErrorTypes = {\n    REQUIRED: 'required',\n    MIN_STRING: 'minString',\n    MAX_STRING: 'maxString',\n    MIN_NUMBER: 'minNumber',\n    MAX_NUMBER: 'maxNumber',\n    MIN_NUMBER_EXCLUSIVE: 'minNumberExclusive',\n    MAX_NUMBER_EXCLUSIVE: 'maxNumberExclusive',\n    MIN_DATE: 'minDate',\n    MAX_DATE: 'maxDate',\n    BAD_DATE: 'badDate',\n    MIN_COUNT: 'minCount',\n    MAX_COUNT: 'maxCount',\n    MUST_BE_INTEGER: 'noDecimal',\n    VALUE_NOT_ALLOWED: 'notAllowed',\n    EXPECTED_TYPE: 'expectedType',\n    FAILED_REGULAR_EXPRESSION: 'regEx',\n    KEY_NOT_IN_SCHEMA: 'keyNotInSchema'\n};\nSimpleSchema.Integer = 'SimpleSchema.Integer';\nSimpleSchema.ValidationContext = ValidationContext_js_1.default;\n/*\n * PRIVATE\n */\n// Throws an error if any fields are `type` SimpleSchema but then also\n// have subfields defined outside of that.\nfunction checkSchemaOverlap(schema) {\n    Object.keys(schema).forEach((key) => {\n        const val = schema[key];\n        if (val.type == null)\n            throw new Error(`${key} key is missing \"type\"`);\n        val.type.definitions.forEach((def) => {\n            if (!SimpleSchema.isSimpleSchema(def.type))\n                return;\n            // @ts-expect-error\n            Object.keys(def.type._schema).forEach((subKey) => {\n                const newKey = `${key}.${subKey}`;\n                if (Object.prototype.hasOwnProperty.call(schema, newKey)) {\n                    throw new Error(`The type for \"${key}\" is set to a SimpleSchema instance that defines \"${key}.${subKey}\", but the parent SimpleSchema instance also tries to define \"${key}.${subKey}\"`);\n                }\n            });\n        });\n    });\n}\n/**\n * @param fieldName The full generic schema key\n * @param shouldHumanize Humanize it\n * @returns A label based on the key\n */\nfunction inflectedLabel(fieldName, shouldHumanize = false) {\n    const pieces = fieldName.split('.');\n    let label;\n    do {\n        label = pieces.pop();\n    } while (label === '$' && (pieces.length > 0));\n    return (label != null && shouldHumanize) ? (0, index_js_1.humanize)(label) : (label !== null && label !== void 0 ? label : '');\n}\nfunction getDefaultAutoValueFunction(defaultValue) {\n    return function defaultAutoValueFunction() {\n        if (this.isSet)\n            return;\n        if (this.operator === null)\n            return defaultValue;\n        // Handle the case when pulling an object from an array the object contains a field\n        // which has a defaultValue. We don't want the default value to be returned in this case\n        if (this.operator === '$pull')\n            return;\n        // Handle the case where we are $pushing an object into an array of objects and we\n        // want any fields missing from that object to be added if they have default values\n        if (this.operator === '$push')\n            return defaultValue;\n        // If parent is set, we should update this position instead of $setOnInsert\n        if (this.parentField().isSet)\n            return defaultValue;\n        // Make sure the default value is added on upsert insert\n        if (this.isUpsert)\n            return { $setOnInsert: defaultValue };\n    };\n}\n// Mutates def into standardized object with SimpleSchemaGroup type\nfunction standardizeDefinition(def) {\n    const standardizedDef = {};\n    for (const prop of Object.keys(def)) {\n        if (!oneOfProps.includes(prop)) {\n            // @ts-expect-error Copying properties\n            standardizedDef[prop] = def[prop];\n        }\n    }\n    // Internally, all definition types are stored as groups for simplicity of access.\n    // If we are extending, there may not actually be def.type, but it's okay because\n    // it will be added later when the two SimpleSchemaGroups are merged.\n    if (def.type instanceof SimpleSchemaGroup_js_1.default) {\n        standardizedDef.type = def.type.clone();\n    }\n    else {\n        const groupProps = {};\n        for (const prop of Object.keys(def)) {\n            if (oneOfProps.includes(prop)) {\n                // @ts-expect-error Copying properties\n                groupProps[prop] = def[prop];\n            }\n        }\n        standardizedDef.type = new SimpleSchemaGroup_js_1.default(groupProps);\n    }\n    return standardizedDef;\n}\n/**\n * @summary Checks and mutates definition. Clone it first.\n *   Throws errors if any problems are found.\n * @param fieldName Name of field / key\n * @param definition Field definition\n * @param options Options\n * @param allKeys Set of all field names / keys in entire schema\n */\nfunction checkAndScrubDefinition(fieldName, definition, options, allKeys) {\n    var _a;\n    if (definition.type == null)\n        throw new Error(`${fieldName} key is missing \"type\"`);\n    // Validate the field definition\n    Object.keys(definition).forEach((key) => {\n        if (!exports.schemaDefinitionOptions.includes(key)) {\n            throw new Error(`Invalid definition for ${fieldName} field: \"${key}\" is not a supported property`);\n        }\n    });\n    // Make sure the `type`s are OK\n    let couldBeArray = false;\n    definition.type.definitions.forEach(({ type }) => {\n        if (type == null) {\n            throw new Error(`Invalid definition for ${fieldName} field: \"type\" option is required`);\n        }\n        if (Array.isArray(type)) {\n            throw new Error(`Invalid definition for ${fieldName} field: \"type\" may not be an array. Change it to Array.`);\n        }\n        if (type.constructor === Object && (0, index_js_1.isEmptyObject)(type)) {\n            throw new Error(`Invalid definition for ${fieldName} field: \"type\" may not be an object. Change it to Object`);\n        }\n        if (type === Array)\n            couldBeArray = true;\n        if (SimpleSchema.isSimpleSchema(type)) {\n            // @ts-expect-error\n            Object.keys(type._schema).forEach((subKey) => {\n                const newKey = `${fieldName}.${subKey}`;\n                if (allKeys.has(newKey)) {\n                    throw new Error(`The type for \"${fieldName}\" is set to a SimpleSchema instance that defines \"${newKey}\", but the parent SimpleSchema instance also tries to define \"${newKey}\"`);\n                }\n            });\n        }\n    });\n    // If at least one of the possible types is Array, then make sure we have a\n    // definition for the array items, too.\n    if (couldBeArray && !allKeys.has(`${fieldName}.$`)) {\n        throw new Error(`\"${fieldName}\" is Array type but the schema does not include a \"${fieldName}.$\" definition for the array items\"`);\n    }\n    // defaultValue -> autoValue\n    // We support defaultValue shortcut by converting it immediately into an\n    // autoValue.\n    if ('defaultValue' in definition) {\n        if ('autoValue' in definition && ((_a = definition.autoValue) === null || _a === void 0 ? void 0 : _a.isDefault) !== true) {\n            console.warn(`SimpleSchema: Found both autoValue and defaultValue options for \"${fieldName}\". Ignoring defaultValue.`);\n        }\n        else {\n            if (fieldName.endsWith('.$')) {\n                throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\n            }\n            definition.autoValue = getDefaultAutoValueFunction(definition.defaultValue);\n            definition.autoValue.isDefault = true;\n        }\n    }\n    // REQUIREDNESS\n    if (fieldName.endsWith('.$')) {\n        definition.optional = true;\n    }\n    else if (!Object.prototype.hasOwnProperty.call(definition, 'optional')) {\n        if (Object.prototype.hasOwnProperty.call(definition, 'required')) {\n            if (typeof definition.required === 'function') {\n                // Save a reference to the `required` fn because\n                // we are going to delete it from `definition` below\n                const requiredFn = definition.required;\n                definition.optional = function optional(...args) {\n                    return !requiredFn.apply(this, args);\n                };\n            }\n            else {\n                definition.optional = definition.required !== true;\n            }\n        }\n        else {\n            definition.optional = options.requiredByDefault === false;\n        }\n    }\n    delete definition.required;\n    // LABELS\n    if (!Object.prototype.hasOwnProperty.call(definition, 'label')) {\n        if (options.defaultLabel != null) {\n            definition.label = options.defaultLabel;\n        }\n        else if (SimpleSchema.defaultLabel != null) {\n            definition.label = SimpleSchema.defaultLabel;\n        }\n        else {\n            definition.label = inflectedLabel(fieldName, options.humanizeAutoLabels);\n        }\n    }\n}\nfunction getPickOrOmit(type) {\n    return function pickOrOmit(...args) {\n        // If they are picking/omitting an object or array field, we need to also include everything under it\n        const newSchema = {};\n        // @ts-expect-error\n        this._schemaKeys.forEach((key) => {\n            // Pick/omit it if it IS in the array of keys they want OR if it\n            // STARTS WITH something that is in the array plus a period\n            const includeIt = args.some((wantedField) => key === wantedField || key.indexOf(`${wantedField}.`) === 0);\n            if ((includeIt && type === 'pick') || (!includeIt && type === 'omit')) {\n                // @ts-expect-error\n                newSchema[key] = this._schema[key];\n            }\n        });\n        return this._copyWithSchema(newSchema);\n    };\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"defaultMessages.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/defaultMessages.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDefaultErrorMessage = void 0;\nconst defaultMessages = {\n    badDate: (_, label) => `${String(label)} is not a valid date`,\n    expectedType: ({ dataType }, label) => `${String(label)} must be of type ${String(dataType)}`,\n    keyNotInSchema: ({ name }) => `${name} is not allowed by the schema`,\n    maxCount: ({ maxCount }) => `You cannot specify more than ${String(maxCount)} values`,\n    maxDate: ({ max }, label) => `${String(label)} cannot be after ${String(max)}`,\n    maxNumber: ({ max }, label) => `${String(label)} cannot exceed ${String(max)}`,\n    maxNumberExclusive: ({ max }, label) => `${String(label)} must be less than ${String(max)}`,\n    maxString: ({ max }, label) => `${String(label)} cannot exceed ${String(max)} characters`,\n    minCount: ({ minCount }) => `You must specify at least ${String(minCount)} values`,\n    minDate: ({ min }, label) => `${String(label)} must be on or after ${String(min)}`,\n    minNumber: ({ min }, label) => `${String(label)} must be at least ${String(min)}`,\n    minNumberExclusive: ({ min }, label) => `${String(label)} must be greater than ${String(min)}`,\n    minString: ({ min }, label) => `${String(label)} must be at least ${String(min)} characters`,\n    noDecimal: (_, label) => `${String(label)} must be an integer`,\n    notAllowed: ({ value }) => `${String(value)} is not an allowed value`,\n    regEx: (_, label) => `${String(label)} failed regular expression validation`,\n    required: (_, label) => `${String(label)} is required`\n};\nfunction getDefaultErrorMessage(errorInfo, label) {\n    const msgFn = defaultMessages[errorInfo.type];\n    return typeof msgFn === 'function' ? msgFn(errorInfo, label) : `${errorInfo.type} ${errorInfo.name}`;\n}\nexports.getDefaultErrorMessage = getDefaultErrorMessage;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"errors.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/errors.js                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientError = void 0;\nclass ClientError extends Error {\n    constructor(message, error) {\n        super(message);\n        this.errorType = 'ClientError';\n        this.name = 'ClientError';\n        this.error = error;\n    }\n}\nexports.ClientError = ClientError;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"expandShorthand.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/expandShorthand.js                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\n/**\n * Clones a schema object, expanding shorthand as it does it.\n */\nfunction expandShorthand(schema) {\n    const schemaClone = {};\n    Object.keys(schema).forEach((key) => {\n        const definition = schema[key];\n        // CASE 1: Not shorthand. Just clone\n        if (mongo_object_1.default.isBasicObject(definition)) {\n            // @ts-expect-error We're pretty sure it's correct\n            schemaClone[key] = Object.assign({}, definition);\n            return;\n        }\n        // CASE 2: The definition is an array of some type\n        if (Array.isArray(definition)) {\n            if (Array.isArray(definition[0])) {\n                throw new Error(`Array shorthand may only be used to one level of depth (${key})`);\n            }\n            const type = definition[0];\n            schemaClone[key] = { type: Array };\n            // Also add the item key definition\n            const itemKey = `${key}.$`;\n            if (schema[itemKey] !== undefined) {\n                throw new Error(`Array shorthand used for ${key} field but ${key}.$ key is already in the schema`);\n            }\n            if (type instanceof RegExp) {\n                schemaClone[itemKey] = { type: String, regEx: type };\n            }\n            else {\n                schemaClone[itemKey] = { type };\n            }\n            return;\n        }\n        // CASE 3: The definition is a regular expression\n        if (definition instanceof RegExp) {\n            schemaClone[key] = {\n                type: String,\n                regEx: definition\n            };\n            return;\n        }\n        // CASE 4: The definition is something, a type\n        schemaClone[key] = { type: definition };\n    });\n    return schemaClone;\n}\nexports.default = expandShorthand;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"SimpleSchemaGroup.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/SimpleSchemaGroup.js                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\nclass SimpleSchemaGroup {\n    constructor(...definitions) {\n        this.definitions = [];\n        this.definitions = definitions.map((definition) => {\n            if (mongo_object_1.default.isBasicObject(definition)) {\n                return Object.assign({}, definition);\n            }\n            if (definition instanceof RegExp) {\n                return {\n                    type: String,\n                    regEx: definition\n                };\n            }\n            return { type: definition };\n        });\n    }\n    get singleType() {\n        return this.definitions[0].type;\n    }\n    clone() {\n        return new SimpleSchemaGroup(...this.definitions);\n    }\n    extend(otherGroup) {\n        // We extend based on index being the same. No better way I can think of at the moment.\n        this.definitions = this.definitions.map((def, index) => {\n            const otherDef = otherGroup.definitions[index];\n            if (otherDef === undefined)\n                return def;\n            return Object.assign(Object.assign({}, def), otherDef);\n        });\n    }\n}\nexports.default = SimpleSchemaGroup;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"utility\":{\"index.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/utility/index.js                                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.humanize = exports.looksLikeModifier = exports.isObjectWeShouldTraverse = exports.isEmptyObject = exports.getParentOfKey = exports.getLastPartOfKey = exports.getKeysWithValueInObj = exports.forEachKeyAncestor = exports.dateToDateString = exports.appendAffectedKey = void 0;\nfunction appendAffectedKey(affectedKey, key) {\n    if (key === '$each')\n        return affectedKey;\n    return affectedKey == null ? key : `${affectedKey}.${key}`;\n}\nexports.appendAffectedKey = appendAffectedKey;\n/**\n * Given a Date instance, returns a date string of the format YYYY-MM-DD\n */\nfunction dateToDateString(date) {\n    let month = date.getUTCMonth() + 1;\n    if (month < 10)\n        month = `0${month}`;\n    let day = date.getUTCDate();\n    if (day < 10)\n        day = `0${day}`;\n    return `${date.getUTCFullYear()}-${month}-${day}`;\n}\nexports.dateToDateString = dateToDateString;\n/**\n * Run loopFunc for each ancestor key in a dot-delimited key. For example,\n * if key is \"a.b.c\", loopFunc will be called first with ('a.b', 'c') and then with ('a', 'b.c')\n */\nfunction forEachKeyAncestor(key, loopFunc) {\n    let lastDot;\n    // Iterate the dot-syntax hierarchy\n    let ancestor = key;\n    do {\n        lastDot = ancestor.lastIndexOf('.');\n        if (lastDot !== -1) {\n            ancestor = ancestor.slice(0, lastDot);\n            const remainder = key.slice(ancestor.length + 1);\n            loopFunc(ancestor, remainder); // Remove last path component\n        }\n    } while (lastDot !== -1);\n}\nexports.forEachKeyAncestor = forEachKeyAncestor;\n/**\n * Returns an array of keys that are in obj, have a value\n * other than null or undefined, and start with matchKey\n * plus a dot.\n */\nfunction getKeysWithValueInObj(obj, matchKey) {\n    const keysWithValue = [];\n    const keyAdjust = (key) => key.slice(0, matchKey.length + 1);\n    const matchKeyPlusDot = `${matchKey}.`;\n    Object.keys(obj !== null && obj !== void 0 ? obj : {}).forEach((key) => {\n        const val = obj[key];\n        if (val === undefined || val === null)\n            return;\n        if (keyAdjust(key) === matchKeyPlusDot) {\n            keysWithValue.push(key);\n        }\n    });\n    return keysWithValue;\n}\nexports.getKeysWithValueInObj = getKeysWithValueInObj;\n/**\n * Returns the ending of key, after stripping out the beginning\n * ancestorKey and any array placeholders\n *\n * getLastPartOfKey('a.b.c', 'a') returns 'b.c'\n * getLastPartOfKey('a.b.$.c', 'a.b') returns 'c'\n */\nfunction getLastPartOfKey(key, ancestorKey) {\n    let lastPart = '';\n    const startString = `${ancestorKey}.`;\n    if (key.indexOf(startString) === 0) {\n        lastPart = key.replace(startString, '');\n        if (lastPart.startsWith('$.'))\n            lastPart = lastPart.slice(2);\n    }\n    return lastPart;\n}\nexports.getLastPartOfKey = getLastPartOfKey;\n/**\n * Returns the parent of a key. For example, returns 'a.b' when passed 'a.b.c'.\n * If no parent, returns an empty string. If withEndDot is true, the return\n * value will have a dot appended when it isn't an empty string.\n */\nfunction getParentOfKey(key, withEndDot = false) {\n    const lastDot = key.lastIndexOf('.');\n    return lastDot === -1 ? '' : key.slice(0, lastDot + Number(withEndDot));\n}\nexports.getParentOfKey = getParentOfKey;\n/**\n * @summary Determines whether the object has any \"own\" properties\n * @param {Object} obj Object to test\n * @return {Boolean} True if it has no \"own\" properties\n */\nfunction isEmptyObject(obj) {\n    /* eslint-disable no-restricted-syntax */\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    /* eslint-enable no-restricted-syntax */\n    return true;\n}\nexports.isEmptyObject = isEmptyObject;\nfunction isObjectWeShouldTraverse(val) {\n    // Some of these types don't exist in old browsers so we'll catch and return false in those cases\n    try {\n        if (val !== Object(val))\n            return false;\n        // There are some object types that we know we shouldn't traverse because\n        // they will often result in overflows and it makes no sense to validate them.\n        if (val instanceof Date)\n            return false;\n        if (val instanceof Int8Array)\n            return false;\n        if (val instanceof Uint8Array)\n            return false;\n        if (val instanceof Uint8ClampedArray)\n            return false;\n        if (val instanceof Int16Array)\n            return false;\n        if (val instanceof Uint16Array)\n            return false;\n        if (val instanceof Int32Array)\n            return false;\n        if (val instanceof Uint32Array)\n            return false;\n        if (val instanceof Float32Array)\n            return false;\n        if (val instanceof Float64Array)\n            return false;\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.isObjectWeShouldTraverse = isObjectWeShouldTraverse;\n/**\n * Returns true if any of the keys of obj start with a $\n */\nfunction looksLikeModifier(obj) {\n    return Object.keys(obj !== null && obj !== void 0 ? obj : {}).some((key) => key.substring(0, 1) === '$');\n}\nexports.looksLikeModifier = looksLikeModifier;\nvar humanize_js_1 = require(\"./humanize.js\");\nObject.defineProperty(exports, \"humanize\", { enumerable: true, get: function () { return humanize_js_1.humanize; } });\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"humanize.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/utility/humanize.js                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\n/*\n  Code source:\n    https://github.com/jxson/string-humanize\n    https://github.com/jxson/string-capitalize\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.humanize = exports.extname = exports.underscore = exports.capitalize = void 0;\nfunction capitalize(text) {\n    text = text !== null && text !== void 0 ? text : '';\n    text = text.trim();\n    if (text[0] !== undefined) {\n        text = text[0].toUpperCase() + text.substr(1).toLowerCase();\n    }\n    // Do \"ID\" instead of \"id\" or \"Id\"\n    text = text.replace(/\\bid\\b/g, 'ID');\n    text = text.replace(/\\bId\\b/g, 'ID');\n    return text;\n}\nexports.capitalize = capitalize;\nfunction underscore(text) {\n    text = text !== null && text !== void 0 ? text : '';\n    text = text.toString(); // might be a number\n    text = text.trim();\n    text = text.replace(/([a-z\\d])([A-Z]+)/g, '$1_$2');\n    text = text.replace(/[-\\s]+/g, '_').toLowerCase();\n    return text;\n}\nexports.underscore = underscore;\nfunction extname(text) {\n    const index = text.lastIndexOf('.');\n    const ext = text.substring(index, text.length);\n    return (index === -1) ? '' : ext;\n}\nexports.extname = extname;\nfunction humanize(text) {\n    text = text !== null && text !== void 0 ? text : '';\n    text = text.toString(); // might be a number\n    text = text.trim();\n    text = text.replace(extname(text), '');\n    text = underscore(text);\n    text = text.replace(/[\\W_]+/g, ' ');\n    return capitalize(text);\n}\nexports.humanize = humanize;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"ValidationContext.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/ValidationContext.js                                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\nconst doValidation_js_1 = __importDefault(require(\"./doValidation.js\"));\nconst index_js_1 = require(\"./utility/index.js\");\nclass ValidationContext {\n    /**\n     * @param schema SimpleSchema instance to use for validation\n     * @param name Optional context name, accessible on context.name.\n     */\n    constructor(schema, name) {\n        this._validationErrors = [];\n        this.name = name;\n        this._simpleSchema = schema;\n        this._schema = schema.schema();\n        this._schemaKeys = Object.keys(this._schema);\n    }\n    setValidationErrors(errors) {\n        this._validationErrors = errors;\n    }\n    addValidationErrors(errors) {\n        errors.forEach((error) => this._validationErrors.push(error));\n    }\n    /**\n     * Reset the validationErrors array\n     */\n    reset() {\n        this.setValidationErrors([]);\n    }\n    /**\n     * @param key The key to get an error for\n     * @param genericKey The generic version of this key, if already known\n     * @returns The first validation error for this key, if any\n     */\n    getErrorForKey(key, genericKey = mongo_object_1.default.makeKeyGeneric(key)) {\n        const errors = this._validationErrors;\n        const errorForKey = errors.find((error) => error.name === key);\n        if (errorForKey != null)\n            return errorForKey;\n        return errors.find((error) => error.name === genericKey);\n    }\n    /**\n     * @param key The key to check validity for\n     * @param genericKey The generic version of this key, if already known\n     * @returns True if this key is currently invalid; otherwise false.\n     */\n    keyIsInvalid(key, genericKey = mongo_object_1.default.makeKeyGeneric(key)) {\n        return this.getErrorForKey(key, genericKey) != null;\n    }\n    /**\n     * @param key The key get the first error message for\n     * @param genericKey The generic version of this key, if already known\n     * @returns The message for the first error for this key, or an empty string\n     */\n    keyErrorMessage(key, genericKey = mongo_object_1.default.makeKeyGeneric(key)) {\n        const errorObj = this.getErrorForKey(key, genericKey);\n        if (errorObj == null)\n            return '';\n        return this._simpleSchema.messageForError(errorObj);\n    }\n    /**\n     * Validates the object against the SimpleSchema and sets an array of error objects\n     * @param obj Object to be validated\n     * @param options Validation options\n     * @returns True if valid; otherwise false\n     */\n    validate(obj, { extendedCustomContext = {}, ignore: ignoreTypes = [], keys: keysToValidate, modifier: isModifier = false, mongoObject, upsert: isUpsert = false } = {}) {\n        // First do some basic checks of the object, and throw errors if necessary\n        if (obj == null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n            throw new Error('The first argument of validate() must be an object');\n        }\n        if (!isModifier && (0, index_js_1.looksLikeModifier)(obj)) {\n            throw new Error('When the validation object contains mongo operators, you must set the modifier option to true');\n        }\n        const validationErrors = (0, doValidation_js_1.default)({\n            extendedCustomContext,\n            ignoreTypes,\n            isModifier,\n            isUpsert,\n            keysToValidate,\n            mongoObject,\n            obj,\n            schema: this._simpleSchema,\n            validationContext: this\n        });\n        if (keysToValidate != null) {\n            // We have only revalidated the listed keys, so if there\n            // are any other existing errors that are NOT in the keys list,\n            // we should keep these errors.\n            for (const error of this._validationErrors) {\n                const wasValidated = keysToValidate.some((key) => key === error.name || error.name.startsWith(`${key}.`));\n                if (!wasValidated)\n                    validationErrors.push(error);\n            }\n        }\n        this.setValidationErrors(validationErrors);\n        // Return true if it was valid; otherwise, return false\n        return validationErrors.length === 0;\n    }\n    isValid() {\n        return this._validationErrors.length === 0;\n    }\n    validationErrors() {\n        return this._validationErrors;\n    }\n    clean(doc, options = {}) {\n        return this._simpleSchema.clean(doc, options);\n    }\n}\nexports.default = ValidationContext;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"doValidation.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/doValidation.js                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validateDocument_js_1 = __importDefault(require(\"./validation/validateDocument.js\"));\nconst validateField_js_1 = __importDefault(require(\"./validation/validateField.js\"));\nfunction shouldCheck(operator) {\n    if (operator === '$pushAll') {\n        throw new Error('$pushAll is not supported; use $push + $each');\n    }\n    return !['$pull', '$pullAll', '$pop', '$slice'].includes(operator);\n}\nfunction doValidation({ extendedCustomContext, ignoreTypes, isModifier, isUpsert, keysToValidate, mongoObject, obj, schema, validationContext }) {\n    const validationErrors = [];\n    // Kick off the validation\n    if (isModifier) {\n        // Loop through operators\n        for (const [op, opObj] of Object.entries(obj)) {\n            // If non-operators are mixed in, throw error\n            if (op.slice(0, 1) !== '$') {\n                throw new Error(`Expected '${op}' to be a modifier operator like '$set'`);\n            }\n            if (!shouldCheck(op))\n                continue;\n            const presentKeys = Object.keys(opObj);\n            const fields = presentKeys.map((opKey) => {\n                let value = opObj[opKey];\n                if (op === '$push' || op === '$addToSet') {\n                    if (typeof value === 'object' && '$each' in value) {\n                        value = value.$each;\n                    }\n                    else {\n                        opKey = `${opKey}.0`;\n                    }\n                }\n                return { key: opKey, value };\n            });\n            // For an upsert, missing props would not be set if an insert is performed,\n            // so we check them all with undefined value to force any 'required' checks to fail\n            if (isUpsert && (op === '$set' || op === '$setOnInsert')) {\n                for (const key of schema.objectKeys()) {\n                    if (!presentKeys.includes(key)) {\n                        fields.push({ key, value: undefined });\n                    }\n                }\n            }\n            for (const field of fields) {\n                const fieldErrors = (0, validateField_js_1.default)({\n                    affectedKey: field.key,\n                    keysToValidate,\n                    obj,\n                    op,\n                    schema,\n                    val: field.value,\n                    validationContext\n                });\n                if (fieldErrors.length > 0) {\n                    validationErrors.push(...fieldErrors);\n                }\n            }\n        }\n    }\n    else {\n        const fieldErrors = (0, validateField_js_1.default)({\n            keysToValidate,\n            obj,\n            schema,\n            val: obj,\n            validationContext\n        });\n        if (fieldErrors.length > 0) {\n            validationErrors.push(...fieldErrors);\n        }\n    }\n    const wholeDocumentErrors = (0, validateDocument_js_1.default)({\n        extendedCustomContext,\n        ignoreTypes,\n        isModifier,\n        isUpsert,\n        keysToValidate,\n        mongoObject,\n        obj,\n        schema,\n        validationContext\n    });\n    if (wholeDocumentErrors.length > 0) {\n        validationErrors.push(...wholeDocumentErrors);\n    }\n    const addedFieldNames = new Set();\n    return validationErrors.filter((errObj) => {\n        // Remove error types the user doesn't care about\n        if ((ignoreTypes === null || ignoreTypes === void 0 ? void 0 : ignoreTypes.includes(errObj.type)) === true)\n            return false;\n        // Make sure there is only one error per fieldName\n        if (addedFieldNames.has(errObj.name))\n            return false;\n        addedFieldNames.add(errObj.name);\n        return true;\n    });\n}\nexports.default = doValidation;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"validation\":{\"validateDocument.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/validateDocument.js                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SimpleSchema_js_1 = require(\"../SimpleSchema.js\");\nfunction validateDocument({ extendedCustomContext, ignoreTypes, isModifier, isUpsert, keysToValidate, mongoObject, obj, schema, validationContext }) {\n    // @ts-expect-error\n    const docValidators = schema._docValidators.concat(\n    // @ts-expect-error\n    SimpleSchema_js_1.SimpleSchema._docValidators);\n    const docValidatorContext = Object.assign({ ignoreTypes,\n        isModifier,\n        isUpsert,\n        keysToValidate,\n        mongoObject,\n        obj,\n        schema,\n        validationContext }, (extendedCustomContext !== null && extendedCustomContext !== void 0 ? extendedCustomContext : {}));\n    const validationErrors = [];\n    for (const docValidator of docValidators) {\n        const errors = docValidator.call(docValidatorContext, obj);\n        if (!Array.isArray(errors)) {\n            throw new Error('Custom doc validator must return an array of error objects');\n        }\n        if (errors.length > 0) {\n            validationErrors.push(...errors);\n        }\n    }\n    return validationErrors;\n}\nexports.default = validateDocument;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"validateField.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/validateField.js                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mongo_object_1 = __importDefault(require(\"mongo-object\"));\nconst SimpleSchema_js_1 = require(\"../SimpleSchema.js\");\nconst index_js_1 = require(\"../utility/index.js\");\nconst allowedValuesValidator_js_1 = __importDefault(require(\"./allowedValuesValidator.js\"));\nconst requiredValidator_js_1 = __importDefault(require(\"./requiredValidator.js\"));\nconst index_js_2 = __importDefault(require(\"./typeValidator/index.js\"));\nfunction shouldValidateKey({ affectedKey, affectedKeyGeneric, keysToValidate }) {\n    if (keysToValidate == null)\n        return true;\n    return keysToValidate.some((keyToValidate) => {\n        var _a, _b;\n        return keyToValidate === affectedKey ||\n            keyToValidate === affectedKeyGeneric ||\n            ((_a = affectedKey === null || affectedKey === void 0 ? void 0 : affectedKey.startsWith(`${keyToValidate}.`)) !== null && _a !== void 0 ? _a : false) ||\n            ((_b = affectedKeyGeneric === null || affectedKeyGeneric === void 0 ? void 0 : affectedKeyGeneric.startsWith(`${keyToValidate}.`)) !== null && _b !== void 0 ? _b : false);\n    });\n}\nfunction shouldCheckValue({ affectedKeyGeneric, isOptional, op, val }) {\n    if (op === '$unset')\n        return false;\n    if (op === '$rename')\n        return false;\n    if (val === undefined || val === null) {\n        return (affectedKeyGeneric === null || affectedKeyGeneric === void 0 ? void 0 : affectedKeyGeneric.slice(-2)) === '.$' &&\n            val === null &&\n            isOptional !== true;\n    }\n    return true;\n}\nfunction makeGenericKeyOrThrow(key) {\n    const genericKey = mongo_object_1.default.makeKeyGeneric(key);\n    if (genericKey == null)\n        throw new Error(`Failed to get generic key for key \"${key}\"`);\n    return genericKey;\n}\n/**\n * Validate a single field within an object being validated\n * @returns Array of all validation errors\n */\nfunction validateField(props) {\n    const { affectedKey, extendedCustomContext, isInArrayItemObject = false, isInSubObject = false, keysToValidate, obj, op = null, schema, validationContext } = props;\n    let { val } = props;\n    let affectedKeyGeneric;\n    let def;\n    const fieldValidationErrors = [];\n    let mongoObject;\n    function getFieldInfo(key) {\n        var _a;\n        // Create mongoObject if necessary, cache for speed\n        if (mongoObject === undefined)\n            mongoObject = new mongo_object_1.default(obj, schema.blackboxKeys());\n        const keyInfo = (_a = mongoObject.getInfoForKey(key)) !== null && _a !== void 0 ? _a : {\n            operator: null,\n            value: undefined\n        };\n        return Object.assign(Object.assign({}, keyInfo), { isSet: keyInfo.value !== undefined });\n    }\n    if (affectedKey !== undefined) {\n        // When we hit a blackbox key, we don't progress any further\n        if (schema.keyIsInBlackBox(affectedKey))\n            return [];\n        affectedKeyGeneric = makeGenericKeyOrThrow(affectedKey);\n        // Prepare the context object for the rule functions\n        const fieldParentNameWithEndDot = (0, index_js_1.getParentOfKey)(affectedKey, true);\n        const fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\n        const functionsContext = Object.assign({ field(fName) {\n                return getFieldInfo(fName);\n            }, genericKey: affectedKeyGeneric, isInArrayItemObject,\n            isInSubObject, isModifier: op != null, isSet: val !== undefined, key: affectedKey, obj, operator: op, parentField() {\n                return getFieldInfo(fieldParentName);\n            },\n            siblingField(fName) {\n                return getFieldInfo(fieldParentNameWithEndDot + fName);\n            },\n            validationContext, value: val }, (extendedCustomContext !== null && extendedCustomContext !== void 0 ? extendedCustomContext : {}));\n        if (shouldValidateKey({\n            affectedKey,\n            affectedKeyGeneric: affectedKeyGeneric !== null && affectedKeyGeneric !== void 0 ? affectedKeyGeneric : undefined,\n            keysToValidate\n        })) {\n            // Perform validation for this key\n            for (const currentDef of schema.getDefinitions(affectedKey, null, functionsContext)) {\n                def = currentDef;\n                // Whenever we try a new possible schema, clear any field errors from the previous tried schema\n                fieldValidationErrors.length = 0;\n                const validatorContext = Object.assign(Object.assign({}, functionsContext), { addValidationErrors(errors) {\n                        errors.forEach((error) => fieldValidationErrors.push(error));\n                    }, \n                    // Value checks are not necessary for null or undefined values, except\n                    // for non-optional null array items, or for $unset or $rename values\n                    valueShouldBeChecked: shouldCheckValue({\n                        affectedKeyGeneric: affectedKeyGeneric !== null && affectedKeyGeneric !== void 0 ? affectedKeyGeneric : undefined,\n                        isOptional: currentDef.optional,\n                        op,\n                        val\n                    }) });\n                // Loop through each of the definitions in the SimpleSchemaGroup.\n                // If the value matches any, we are valid and can stop checking the rest.\n                for (const [typeIndex, typeDef] of currentDef.type.entries()) {\n                    // If the type is SimpleSchema.Any, then it is valid\n                    if (typeDef === SimpleSchema_js_1.SimpleSchema.Any)\n                        break;\n                    const nonAnyTypeDefinition = typeDef;\n                    const { type } = currentDef, definitionWithoutType = __rest(currentDef\n                    // @ts-expect-error\n                    , [\"type\"]);\n                    // @ts-expect-error\n                    const finalValidatorContext = Object.assign(Object.assign({}, validatorContext), { \n                        // Take outer definition props like \"optional\" and \"label\"\n                        // and add them to inner props like \"type\" and \"min\"\n                        definition: Object.assign(Object.assign({}, definitionWithoutType), nonAnyTypeDefinition) });\n                    // Order of these validators is important\n                    const customFieldValidator = nonAnyTypeDefinition.custom;\n                    const fieldValidators = [\n                        requiredValidator_js_1.default,\n                        index_js_2.default,\n                        allowedValuesValidator_js_1.default,\n                        ...(customFieldValidator == null ? [] : [customFieldValidator]),\n                        // @ts-expect-error It's fine to access private method from here\n                        ...schema._validators,\n                        // @ts-expect-error It's fine to access private method from here\n                        ...SimpleSchema_js_1.SimpleSchema._validators\n                    ];\n                    const fieldValidationErrorsForThisType = [];\n                    for (const fieldValidator of fieldValidators) {\n                        const result = fieldValidator.call(finalValidatorContext);\n                        // If the validator returns a string, assume it is the error type.\n                        if (typeof result === 'string') {\n                            fieldValidationErrorsForThisType.push({\n                                name: affectedKey,\n                                type: result,\n                                value: val\n                            });\n                        }\n                        // If the validator returns an object, assume it is an error object.\n                        if (typeof result === 'object' && result !== null) {\n                            fieldValidationErrorsForThisType.push(Object.assign({ name: affectedKey, value: val }, result));\n                        }\n                    }\n                    if (val !== undefined && SimpleSchema_js_1.SimpleSchema.isSimpleSchema(nonAnyTypeDefinition.type)) {\n                        const itemErrors = validateField({\n                            extendedCustomContext,\n                            keysToValidate,\n                            obj: val,\n                            op,\n                            schema: nonAnyTypeDefinition.type,\n                            val,\n                            validationContext\n                        });\n                        if (itemErrors.length > 0) {\n                            fieldValidationErrorsForThisType.push(...itemErrors.map((error) => (Object.assign(Object.assign({}, error), { name: `${affectedKey}.${error.name}` }))));\n                        }\n                    }\n                    // As soon as we find a type for which the value is valid, stop checking more\n                    if (fieldValidationErrorsForThisType.length === 0) {\n                        // One we have chosen a valid schema, there is no need to validate the\n                        // properties of this object because we validated all the way down\n                        if (SimpleSchema_js_1.SimpleSchema.isSimpleSchema(nonAnyTypeDefinition.type)) {\n                            return fieldValidationErrors;\n                        }\n                        break;\n                    }\n                    if (typeIndex === currentDef.type.length - 1) {\n                        fieldValidationErrors.push(...fieldValidationErrorsForThisType);\n                    }\n                }\n                // If it's valid with this schema, we don't need to try any more\n                if (fieldValidationErrors.length === 0)\n                    break;\n            }\n            // Mark invalid if not found in schema\n            if (def == null) {\n                // We don't need KEY_NOT_IN_SCHEMA error for $unset and we also don't need to continue\n                if (op === '$unset' ||\n                    (op === '$currentDate' && affectedKey.endsWith('.$type'))) {\n                    return [];\n                }\n                return [\n                    {\n                        name: affectedKey,\n                        type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n                        value: val\n                    }\n                ];\n            }\n            // For $rename, make sure that the new name is allowed by the schema\n            if (op === '$rename' && !schema.allowsKey(val)) {\n                return [\n                    {\n                        name: val,\n                        type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n                        value: null\n                    }\n                ];\n            }\n        }\n        // Loop through arrays\n        if (Array.isArray(val)) {\n            for (const [index, itemValue] of val.entries()) {\n                const itemErrors = validateField(Object.assign(Object.assign({}, props), { affectedKey: `${affectedKey}.${index}`, val: itemValue }));\n                if (itemErrors.length > 0) {\n                    fieldValidationErrors.push(...itemErrors);\n                }\n            }\n            return fieldValidationErrors;\n        }\n    }\n    // If affectedKeyGeneric is undefined due to this being the first run of this\n    // function, objectKeys will return the top-level keys.\n    const childKeys = schema.objectKeys(affectedKeyGeneric !== null && affectedKeyGeneric !== void 0 ? affectedKeyGeneric : undefined);\n    // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n    if ((val === undefined || val === null) &&\n        ((def == null) || (def.optional !== true && childKeys.length > 0))) {\n        val = {};\n    }\n    // Loop through object keys\n    if ((0, index_js_1.isObjectWeShouldTraverse)(val) &&\n        // @ts-expect-error\n        ((def == null) || !schema._blackboxKeys.has(affectedKey !== null && affectedKey !== void 0 ? affectedKey : ''))) {\n        // Check all present keys plus all keys defined by the schema.\n        // This allows us to detect extra keys not allowed by the schema plus\n        // any missing required keys, and to run any custom functions for other keys.\n        for (const key of new Set([...Object.keys(val), ...childKeys])) {\n            const childFieldErrors = validateField(Object.assign(Object.assign({}, props), { affectedKey: (0, index_js_1.appendAffectedKey)(affectedKey, key), \n                // If this object is within an array, make sure we check for required as if it's not a modifier\n                isInArrayItemObject: (affectedKeyGeneric === null || affectedKeyGeneric === void 0 ? void 0 : affectedKeyGeneric.slice(-2)) === '.$', isInSubObject: true, val: val[key] }));\n            if (childFieldErrors.length > 0) {\n                fieldValidationErrors.push(...childFieldErrors);\n            }\n        }\n    }\n    return fieldValidationErrors;\n}\nexports.default = validateField;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"allowedValuesValidator.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/allowedValuesValidator.js                                             //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SimpleSchema_js_1 = require(\"../SimpleSchema.js\");\nfunction allowedValuesValidator() {\n    if (!this.valueShouldBeChecked)\n        return;\n    const { allowedValues } = this.definition;\n    if (allowedValues == null)\n        return;\n    let isAllowed;\n    // set defined in scope and allowedValues is its instance\n    if (typeof Set === 'function' && allowedValues instanceof Set) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        isAllowed = allowedValues.has(this.value);\n    }\n    else {\n        isAllowed = allowedValues.includes(this.value);\n    }\n    return isAllowed ? true : SimpleSchema_js_1.SimpleSchema.ErrorTypes.VALUE_NOT_ALLOWED;\n}\nexports.default = allowedValuesValidator;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"requiredValidator.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/requiredValidator.js                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SimpleSchema_js_1 = require(\"../SimpleSchema.js\");\nconst index_js_1 = require(\"../utility/index.js\");\n// Check for missing required values. The general logic is this:\n// * If the operator is $unset or $rename, it's invalid.\n// * If the value is null, it's invalid.\n// * If the value is undefined and one of the following are true, it's invalid:\n//     * We're validating a key of a sub-object.\n//     * We're validating a key of an object that is an array item.\n//     * We're validating a document (as opposed to a modifier).\n//     * We're validating a key under the $set operator in a modifier, and it's an upsert.\nfunction requiredValidator() {\n    const { definition, isInArrayItemObject, isInSubObject, key, obj, operator, value } = this;\n    const { optional } = definition;\n    if (optional === true)\n        return;\n    // If value is null, no matter what, we add required\n    if (value === null)\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\n    // If operator would remove, we add required\n    if (operator === '$unset' || operator === '$rename') {\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\n    }\n    // The rest of these apply only if the value is undefined\n    if (value !== undefined)\n        return;\n    // At this point, if it's a normal, non-modifier object, then a missing value is an error\n    if (operator == null)\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\n    // Everything beyond this point deals with modifier objects only\n    // We can skip the required check for keys that are ancestors of those in $set or\n    // $setOnInsert because they will be created by MongoDB while setting.\n    const keysWithValueInSet = (0, index_js_1.getKeysWithValueInObj)(obj.$set, key);\n    if (keysWithValueInSet.length > 0)\n        return;\n    const keysWithValueInSetOnInsert = (0, index_js_1.getKeysWithValueInObj)(obj.$setOnInsert, key);\n    if (keysWithValueInSetOnInsert.length > 0)\n        return;\n    // In the case of $set and $setOnInsert, the value may be undefined here\n    // but it is set in another operator. So check that first.\n    const fieldInfo = this.field(key);\n    if (fieldInfo.isSet && fieldInfo.value !== null)\n        return;\n    // Required if in an array or sub object\n    if (isInArrayItemObject || isInSubObject) {\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\n    }\n    // If we've got this far with an undefined $set or $setOnInsert value, it's a required error.\n    if (operator === '$set' || operator === '$setOnInsert') {\n        return SimpleSchema_js_1.SimpleSchema.ErrorTypes.REQUIRED;\n    }\n}\nexports.default = requiredValidator;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"typeValidator\":{\"index.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/index.js                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValueTypeValid = exports.checkValueType = void 0;\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\nconst checkArrayValue_js_1 = __importDefault(require(\"./checkArrayValue.js\"));\nconst checkDateValue_js_1 = __importDefault(require(\"./checkDateValue.js\"));\nconst checkNumberValue_js_1 = __importDefault(require(\"./checkNumberValue.js\"));\nconst checkStringValue_js_1 = __importDefault(require(\"./checkStringValue.js\"));\nfunction checkValueType(info) {\n    const { definition: def, operator: op, value, valueShouldBeChecked } = info;\n    if (!valueShouldBeChecked)\n        return;\n    const expectedType = def.type;\n    if (expectedType === String)\n        return (0, checkStringValue_js_1.default)(def, value);\n    if (expectedType === Number)\n        return (0, checkNumberValue_js_1.default)(def, value, op, false);\n    if (expectedType === SimpleSchema_js_1.SimpleSchema.Integer)\n        return (0, checkNumberValue_js_1.default)(def, value, op, true);\n    if (expectedType === Boolean) {\n        // Is it a boolean?\n        if (typeof value === 'boolean')\n            return;\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE, dataType: 'Boolean' };\n    }\n    if (expectedType === Object || SimpleSchema_js_1.SimpleSchema.isSimpleSchema(expectedType)) {\n        // Is it an object?\n        if (value === Object(value) &&\n            typeof value[Symbol.iterator] !== 'function' &&\n            !(value instanceof Date)) {\n            return;\n        }\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE, dataType: 'Object' };\n    }\n    if (expectedType === Array)\n        return (0, checkArrayValue_js_1.default)(def, value);\n    if (expectedType instanceof Function) {\n        // Generic constructor checks\n        if (!(value instanceof expectedType)) {\n            // https://docs.mongodb.com/manual/reference/operator/update/currentDate/\n            const dateTypeIsOkay = expectedType === Date &&\n                op === '$currentDate' &&\n                (value === true || JSON.stringify(value) === '{\"$type\":\"date\"}');\n            if (expectedType !== Date || !dateTypeIsOkay) {\n                return {\n                    type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE,\n                    dataType: expectedType.name\n                };\n            }\n        }\n        // Date checks\n        if (expectedType === Date) {\n            // https://docs.mongodb.com/manual/reference/operator/update/currentDate/\n            if (op === '$currentDate') {\n                return (0, checkDateValue_js_1.default)(def, new Date());\n            }\n            return (0, checkDateValue_js_1.default)(def, value);\n        }\n    }\n}\nexports.checkValueType = checkValueType;\nfunction isValueTypeValid(typeDefinitions, value, operator) {\n    return typeDefinitions.some((definition) => {\n        const typeValidationError = checkValueType({\n            valueShouldBeChecked: true,\n            definition,\n            value,\n            operator\n        });\n        return typeValidationError === undefined;\n    });\n}\nexports.isValueTypeValid = isValueTypeValid;\nfunction typeValidator() {\n    return checkValueType(this);\n}\nexports.default = typeValidator;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"checkArrayValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/checkArrayValue.js                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\nfunction checkArrayValue(def, value) {\n    // Is it an array?\n    if (!Array.isArray(value)) {\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE, dataType: 'Array' };\n    }\n    // Are there fewer than the minimum number of items in the array?\n    if (def.minCount != null && value.length < def.minCount) {\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_COUNT, minCount: def.minCount };\n    }\n    // Are there more than the maximum number of items in the array?\n    if (def.maxCount != null && value.length > def.maxCount) {\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_COUNT, maxCount: def.maxCount };\n    }\n}\nexports.default = checkArrayValue;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"checkDateValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/checkDateValue.js                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\nconst index_js_1 = require(\"../../utility/index.js\");\nfunction checkDateValue(def, value) {\n    // Is it an invalid date?\n    if (isNaN(value.getTime())) {\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.BAD_DATE };\n    }\n    // Is it earlier than the minimum date?\n    if (def.min !== undefined &&\n        typeof def.min.getTime === 'function' &&\n        def.min.getTime() > value.getTime()) {\n        return {\n            type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_DATE,\n            min: (0, index_js_1.dateToDateString)(def.min)\n        };\n    }\n    // Is it later than the maximum date?\n    if (def.max !== undefined &&\n        typeof def.max.getTime === 'function' &&\n        def.max.getTime() < value.getTime()) {\n        return {\n            type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_DATE,\n            max: (0, index_js_1.dateToDateString)(def.max)\n        };\n    }\n}\nexports.default = checkDateValue;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"checkNumberValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/checkNumberValue.js                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\nfunction checkNumberValue(def, value, op, expectsInteger) {\n    // Is it a valid number?\n    if (typeof value !== 'number' || isNaN(value)) {\n        return {\n            type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE,\n            dataType: expectsInteger ? 'Integer' : 'Number'\n        };\n    }\n    // Assuming we are not incrementing, is the value less than the maximum value?\n    if (op !== '$inc' &&\n        def.max !== null &&\n        (def.exclusiveMax === true\n            ? def.max <= value\n            : def.max < value)) {\n        return {\n            type: def.exclusiveMax === true\n                ? SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_NUMBER_EXCLUSIVE\n                : SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_NUMBER,\n            max: def.max\n        };\n    }\n    // Assuming we are not incrementing, is the value more than the minimum value?\n    if (op !== '$inc' &&\n        def.min !== null &&\n        (def.exclusiveMin === true\n            ? def.min >= value\n            : def.min > value)) {\n        return {\n            type: def.exclusiveMin === true\n                ? SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_NUMBER_EXCLUSIVE\n                : SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_NUMBER,\n            min: def.min\n        };\n    }\n    // Is it an integer if we expect an integer?\n    if (expectsInteger && !Number.isInteger(value)) {\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MUST_BE_INTEGER };\n    }\n}\nexports.default = checkNumberValue;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"checkStringValue.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/validation/typeValidator/checkStringValue.js                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SimpleSchema_js_1 = require(\"../../SimpleSchema.js\");\nfunction checkStringValue(def, value) {\n    // Is it a String?\n    if (typeof value !== 'string') {\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.EXPECTED_TYPE, dataType: 'String' };\n    }\n    // Is the string too long?\n    if (def.max !== null && def.max < value.length) {\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MAX_STRING, max: def.max };\n    }\n    // Is the string too short?\n    if (def.min !== null && def.min > value.length) {\n        return { type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.MIN_STRING, min: def.min };\n    }\n    // Does the string match the regular expression?\n    if ((def.skipRegExCheckForEmptyStrings !== true || value !== '') &&\n        def.regEx instanceof RegExp &&\n        !def.regEx.test(value)) {\n        return {\n            type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.FAILED_REGULAR_EXPRESSION,\n            regExp: def.regEx.toString()\n        };\n    }\n    // If regEx is an array of regular expressions, does the string match all of them?\n    if (Array.isArray(def.regEx)) {\n        let regExError;\n        def.regEx.every((re) => {\n            if (!re.test(value)) {\n                regExError = {\n                    type: SimpleSchema_js_1.SimpleSchema.ErrorTypes.FAILED_REGULAR_EXPRESSION,\n                    regExp: re.toString()\n                };\n                return false;\n            }\n            return true;\n        });\n        if (regExError !== undefined)\n            return regExError;\n    }\n}\nexports.default = checkStringValue;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"toJsonSchema.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/simpl-schema/dist/cjs/toJsonSchema.js                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toJsonSchema = void 0;\nconst SimpleSchema_js_1 = require(\"./SimpleSchema.js\");\nconst jsonSchemaVersion = 'https://json-schema.org/draft/2020-12/schema';\nfunction toJSArray(ss, key, fieldDef) {\n    const itemSchema = fieldDefToJsonSchema(ss, `${key}.$`);\n    if (itemSchema == null)\n        return null;\n    const arrayDef = {\n        type: 'array',\n        items: [itemSchema],\n        additionalItems: false\n    };\n    if (fieldDef.minCount !== undefined) {\n        arrayDef.minItems = fieldDef.minCount;\n    }\n    if (fieldDef.maxCount !== undefined) {\n        arrayDef.maxItems = fieldDef.maxCount;\n    }\n    return arrayDef;\n}\nfunction toJsProperties(ss) {\n    const properties = {};\n    const required = [];\n    for (const key of ss.objectKeys()) {\n        const fieldDef = ss.schema(key);\n        if (fieldDef == null)\n            continue;\n        if (fieldDef.optional !== true)\n            required.push(key);\n        const schema = fieldDefToJsonSchema(ss, key);\n        if (schema != null)\n            properties[key] = schema;\n    }\n    return { properties, required };\n}\nfunction toJSObj(simpleSchema, additionalProperties = false) {\n    return Object.assign(Object.assign({ type: 'object' }, toJsProperties(simpleSchema)), { additionalProperties });\n}\nfunction fieldDefToJsonSchema(ss, key) {\n    var _a;\n    const fieldDef = ss.schema(key);\n    if (fieldDef == null)\n        return null;\n    const itemSchemas = [];\n    for (const fieldTypeDef of fieldDef.type.definitions) {\n        let itemSchema = null;\n        switch (fieldTypeDef.type) {\n            case String:\n                itemSchema = { type: 'string' };\n                if (fieldTypeDef.allowedValues !== undefined && typeof fieldTypeDef.allowedValues !== 'function') {\n                    itemSchema.enum = [...fieldTypeDef.allowedValues];\n                }\n                if (fieldTypeDef.max !== undefined && typeof fieldTypeDef.max !== 'function') {\n                    itemSchema.maxLength = fieldTypeDef.max;\n                }\n                if (fieldTypeDef.min !== undefined && typeof fieldTypeDef.min !== 'function') {\n                    itemSchema.minLength = fieldTypeDef.min;\n                }\n                if (fieldTypeDef.regEx instanceof RegExp) {\n                    itemSchema.pattern = String(fieldTypeDef.regEx);\n                }\n                break;\n            case Number:\n            case SimpleSchema_js_1.SimpleSchema.Integer:\n                itemSchema = { type: fieldTypeDef.type === Number ? 'number' : 'integer' };\n                if (fieldTypeDef.max !== undefined && typeof fieldTypeDef.max !== 'function') {\n                    if (fieldTypeDef.exclusiveMax === true) {\n                        itemSchema.exclusiveMaximum = fieldTypeDef.max;\n                    }\n                    else {\n                        itemSchema.maximum = fieldTypeDef.max;\n                    }\n                }\n                if (fieldTypeDef.min !== undefined && typeof fieldTypeDef.min !== 'function') {\n                    if (fieldTypeDef.exclusiveMin === true) {\n                        itemSchema.exclusiveMinimum = fieldTypeDef.min;\n                    }\n                    else {\n                        itemSchema.minimum = fieldTypeDef.min;\n                    }\n                }\n                break;\n            case Boolean:\n                itemSchema = { type: 'boolean' };\n                break;\n            case Date:\n                itemSchema = {\n                    type: 'string',\n                    format: 'date-time'\n                };\n                break;\n            case Array:\n                itemSchema = toJSArray(ss, key, fieldDef);\n                break;\n            case Object:\n                itemSchema = toJSObj(ss.getObjectSchema(key), fieldTypeDef.blackbox);\n                break;\n            case SimpleSchema_js_1.SimpleSchema.Any:\n                // In JSONSchema an empty object means any type\n                itemSchema = {};\n                break;\n            default:\n                if (SimpleSchema_js_1.SimpleSchema.isSimpleSchema(fieldTypeDef.type)) {\n                    itemSchema = toJSObj(fieldTypeDef.type, fieldTypeDef.blackbox);\n                }\n                else if (\n                // support custom objects\n                fieldTypeDef.type instanceof Function) {\n                    itemSchema = toJSObj(ss.getObjectSchema(key), fieldTypeDef.blackbox);\n                }\n                break;\n        }\n        if (itemSchema != null && fieldTypeDef.defaultValue !== undefined) {\n            itemSchema.default = fieldTypeDef.defaultValue;\n        }\n        if (itemSchema != null)\n            itemSchemas.push(itemSchema);\n    }\n    if (itemSchemas.length > 1) {\n        return { anyOf: itemSchemas };\n    }\n    return (_a = itemSchemas[0]) !== null && _a !== void 0 ? _a : null;\n}\n/**\n * Convert a SimpleSchema to a JSONSchema Document.\n *\n * Notes:\n * - Date fields will become string fields with built-in 'date-time' format.\n * - JSONSchema does not support minimum or maximum values for date fields\n * - Custom validators are ignored\n * - Field definition properties that are a function are ignored\n * - Custom objects are treated as regular objects\n *\n * @param simpleSchema SimpleSchema instance to convert\n * @param id Optional ID to use for the `$id` field\n * @returns JSONSchema Document\n */\nfunction toJsonSchema(simpleSchema, id) {\n    return Object.assign(Object.assign(Object.assign({}, (id != null ? { $id: id } : {})), { $schema: jsonSchemaVersion }), toJSObj(simpleSchema));\n}\nexports.toJsonSchema = toJsonSchema;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}},\"clone\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/clone/package.json                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"clone\",\n  \"version\": \"2.1.2\",\n  \"main\": \"clone.js\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"clone.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/clone/clone.js                                                                                         //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"mongo-object\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/mongo-object/package.json                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"mongo-object\",\n  \"version\": \"3.0.1\",\n  \"main\": \"./dist/cjs/main.js\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"dist\":{\"cjs\":{\"main.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/mongo-object/dist/cjs/main.js                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MongoObject = exports.reportNulls = exports.makeKeyGeneric = exports.keyToPosition = exports.isBasicObject = exports.genericKeyAffectsOtherGenericKey = exports.extractOp = exports.expandKey = exports.cleanNulls = exports.appendAffectedKey = void 0;\nconst mongo_object_js_1 = __importDefault(require(\"./mongo-object.js\"));\nexports.MongoObject = mongo_object_js_1.default;\nvar util_js_1 = require(\"./util.js\");\nObject.defineProperty(exports, \"appendAffectedKey\", { enumerable: true, get: function () { return util_js_1.appendAffectedKey; } });\nObject.defineProperty(exports, \"cleanNulls\", { enumerable: true, get: function () { return util_js_1.cleanNulls; } });\nObject.defineProperty(exports, \"expandKey\", { enumerable: true, get: function () { return util_js_1.expandKey; } });\nObject.defineProperty(exports, \"extractOp\", { enumerable: true, get: function () { return util_js_1.extractOp; } });\nObject.defineProperty(exports, \"genericKeyAffectsOtherGenericKey\", { enumerable: true, get: function () { return util_js_1.genericKeyAffectsOtherGenericKey; } });\nObject.defineProperty(exports, \"isBasicObject\", { enumerable: true, get: function () { return util_js_1.isBasicObject; } });\nObject.defineProperty(exports, \"keyToPosition\", { enumerable: true, get: function () { return util_js_1.keyToPosition; } });\nObject.defineProperty(exports, \"makeKeyGeneric\", { enumerable: true, get: function () { return util_js_1.makeKeyGeneric; } });\nObject.defineProperty(exports, \"reportNulls\", { enumerable: true, get: function () { return util_js_1.reportNulls; } });\nexports.default = mongo_object_js_1.default;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"mongo-object.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/mongo-object/dist/cjs/mongo-object.js                                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_js_1 = require(\"./util.js\");\nconst REMOVED_MARKER = '______MONGO_OBJECT_REMOVED______';\nclass MongoObject {\n    /*\n     * @constructor\n     * @param obj\n     * @param blackboxKeys A list of the names of keys that shouldn't be traversed\n     * @returns {undefined}\n     *\n     * Creates a new MongoObject instance. The object passed as the first argument\n     * will be modified in place by calls to instance methods. Also, immediately\n     * upon creation of the instance, the object will have any `undefined` keys\n     * removed recursively.\n     */\n    constructor(obj, blackboxKeys = []) {\n        this._affectedKeys = {};\n        this._arrayItemPositions = [];\n        this._blackboxKeys = [];\n        this._genericAffectedKeys = {};\n        this._objectPositions = [];\n        this._parentPositions = [];\n        this._positionsByGenericKey = {};\n        this._positionsInsideArrays = [];\n        this._positionsThatCreateGenericKey = {};\n        this._obj = obj;\n        this._blackboxKeys = blackboxKeys;\n        this._reParseObj();\n    }\n    _reParseObj() {\n        const blackboxKeys = this._blackboxKeys;\n        this._affectedKeys = {};\n        this._genericAffectedKeys = {};\n        this._positionsByGenericKey = {};\n        this._positionsThatCreateGenericKey = {};\n        this._parentPositions = [];\n        this._positionsInsideArrays = [];\n        this._objectPositions = [];\n        this._arrayItemPositions = [];\n        function parseObj(self, val, currentPosition, affectedKey, operator, adjusted, isWithinArray) {\n            // Adjust for first-level modifier operators\n            if (operator == null && (affectedKey === null || affectedKey === void 0 ? void 0 : affectedKey.substring(0, 1)) === '$') {\n                operator = affectedKey;\n                affectedKey = null;\n            }\n            let affectedKeyIsBlackBox = false;\n            let stop = false;\n            if (affectedKey != null) {\n                // Adjust for $push and $addToSet and $pull and $pop\n                if (adjusted !== true) {\n                    if (operator === '$push' ||\n                        operator === '$addToSet' ||\n                        operator === '$pop') {\n                        // Adjust for $each\n                        // We can simply jump forward and pretend like the $each array\n                        // is the array for the field. This has the added benefit of\n                        // skipping past any $slice, which we also don't care about.\n                        if ((0, util_js_1.isBasicObject)(val) && '$each' in val) {\n                            val = val.$each;\n                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                            currentPosition = `${currentPosition}[$each]`;\n                        }\n                        else {\n                            affectedKey = `${affectedKey}.0`;\n                        }\n                        adjusted = true;\n                    }\n                    else if (operator === '$pull') {\n                        affectedKey = `${affectedKey}.0`;\n                        if ((0, util_js_1.isBasicObject)(val)) {\n                            stop = true;\n                        }\n                        adjusted = true;\n                    }\n                }\n                // Make generic key\n                const affectedKeyGeneric = (0, util_js_1.makeKeyGeneric)(affectedKey);\n                if (affectedKeyGeneric === null)\n                    throw new Error(`Failed to get generic key for key \"${affectedKey}\"`);\n                // Determine whether affected key should be treated as a black box\n                affectedKeyIsBlackBox = affectedKeyGeneric !== null &&\n                    blackboxKeys.includes(affectedKeyGeneric);\n                // Mark that this position affects this generic and non-generic key\n                if (currentPosition != null) {\n                    self._affectedKeys[currentPosition] = affectedKey;\n                    self._genericAffectedKeys[currentPosition] = affectedKeyGeneric;\n                    const positionInfo = {\n                        key: affectedKey,\n                        operator: operator !== null && operator !== void 0 ? operator : null,\n                        position: currentPosition\n                    };\n                    if (self._positionsByGenericKey[affectedKeyGeneric] == null)\n                        self._positionsByGenericKey[affectedKeyGeneric] = [];\n                    self._positionsByGenericKey[affectedKeyGeneric].push(positionInfo);\n                    // Operators other than $unset will cause ancestor object keys to\n                    // be auto-created.\n                    if (operator != null && operator !== '$unset') {\n                        MongoObject.objectsThatGenericKeyWillCreate(affectedKeyGeneric).forEach((objGenericKey) => {\n                            if (self._positionsThatCreateGenericKey[objGenericKey] === undefined) {\n                                self._positionsThatCreateGenericKey[objGenericKey] = [];\n                            }\n                            self._positionsThatCreateGenericKey[objGenericKey].push(positionInfo);\n                        });\n                    }\n                    // If we're within an array, mark this position so we can omit it from flat docs\n                    if (isWithinArray === true)\n                        self._positionsInsideArrays.push(currentPosition);\n                }\n            }\n            if (stop)\n                return;\n            // Loop through arrays\n            if (Array.isArray(val) && val.length > 0) {\n                if (currentPosition != null) {\n                    // Mark positions with arrays that should be ignored when we want endpoints only\n                    self._parentPositions.push(currentPosition);\n                }\n                // Loop\n                val.forEach((v, i) => {\n                    if (currentPosition != null)\n                        self._arrayItemPositions.push(`${currentPosition}[${i}]`);\n                    parseObj(self, v, currentPosition != null ? `${currentPosition}[${i}]` : String(i), \n                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                    `${affectedKey}.${i}`, operator, adjusted, true);\n                });\n            }\n            else if (((0, util_js_1.isBasicObject)(val) && !affectedKeyIsBlackBox) ||\n                currentPosition == null) {\n                // Loop through object keys, only for basic objects,\n                // but always for the passed-in object, even if it\n                // is a custom object.\n                if (currentPosition != null && !(0, util_js_1.isEmpty)(val)) {\n                    // Mark positions with objects that should be ignored when we want endpoints only\n                    self._parentPositions.push(currentPosition);\n                    // Mark positions with objects that should be left out of flat docs.\n                    self._objectPositions.push(currentPosition);\n                }\n                // Loop\n                Object.keys(val).forEach((k) => {\n                    const v = val[k];\n                    if (v === undefined) {\n                        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                        delete val[k];\n                    }\n                    else if (k !== '$slice') {\n                        parseObj(self, v, currentPosition != null ? `${currentPosition}[${k}]` : k, (0, util_js_1.appendAffectedKey)(affectedKey, k), operator, adjusted, isWithinArray);\n                    }\n                });\n            }\n        }\n        parseObj(this, this._obj);\n    }\n    /**\n     * @param func\n     * @param [options]\n     * @param [options.endPointsOnly=true] - Only call function for endpoints and not for nodes that contain other nodes\n     * @returns\n     *\n     * Runs a function for each endpoint node in the object tree, including all items in every array.\n     * The function arguments are\n     * (1) the value at this node\n     * (2) a string representing the node position\n     * (3) the representation of what would be changed in mongo, using mongo dot notation\n     * (4) the generic equivalent of argument 3, with '$' instead of numeric pieces\n     */\n    forEachNode(func, { endPointsOnly = true } = {}) {\n        if (typeof func !== 'function')\n            throw new Error('filter requires a loop function');\n        const updatedValues = {};\n        Object.keys(this._affectedKeys).forEach((position) => {\n            if (endPointsOnly && this._parentPositions.includes(position))\n                return; // Only endpoints\n            func.call({\n                value: this.getValueForPosition(position),\n                isArrayItem: this._arrayItemPositions.includes(position),\n                operator: (0, util_js_1.extractOp)(position),\n                position,\n                key: this._affectedKeys[position],\n                genericKey: this._genericAffectedKeys[position],\n                updateValue: (newVal) => {\n                    updatedValues[position] = newVal;\n                },\n                remove: () => {\n                    updatedValues[position] = undefined;\n                }\n            });\n        });\n        // Actually update/remove values as instructed\n        Object.keys(updatedValues).forEach((position) => {\n            this.setValueForPosition(position, updatedValues[position]);\n        });\n    }\n    getValueForPosition(position) {\n        const subkeys = position.split('[');\n        let current = this._obj;\n        const ln = subkeys.length;\n        for (let i = 0; i < ln; i++) {\n            let subkey = subkeys[i];\n            // If the subkey ends in ']', remove the ending\n            if (subkey.slice(-1) === ']')\n                subkey = subkey.slice(0, -1);\n            current = current[subkey];\n            if (!Array.isArray(current) && !(0, util_js_1.isBasicObject)(current) && i < ln - 1)\n                return;\n        }\n        if (current === REMOVED_MARKER)\n            return;\n        return current;\n    }\n    /**\n     * @param position\n     * @param value\n     */\n    setValueForPosition(position, value) {\n        const subkeys = position.split('[');\n        let current = this._obj;\n        const ln = subkeys.length;\n        let createdObjectsOrArrays = false;\n        let affectedKey = '';\n        for (let i = 0; i < ln; i++) {\n            let subkey = subkeys[i];\n            // If the subkey ends in \"]\", remove the ending\n            if (subkey.slice(-1) === ']')\n                subkey = subkey.slice(0, -1);\n            // We don't store modifiers\n            if (subkey.length > 0 && subkey.substring(0, 1) !== '$') {\n                affectedKey = (0, util_js_1.appendAffectedKey)(affectedKey, subkey);\n            }\n            // If we've reached the key in the object tree that needs setting or\n            // deleting, do it.\n            if (i === ln - 1) {\n                // If value is undefined, delete the property\n                if (value === undefined) {\n                    if (Array.isArray(current)) {\n                        // We can't just delete it because indexes in the position strings will be off\n                        // We will mark it uniquely and then parse this elsewhere\n                        current[Number(subkey)] = REMOVED_MARKER;\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                        delete current[subkey];\n                    }\n                }\n                else {\n                    current[subkey] = value;\n                }\n                this._affectedKeys[position] = affectedKey;\n            }\n            else {\n                // Otherwise attempt to keep moving deeper into the object.\n                // If we're setting (as opposed to deleting) a key and we hit a place\n                // in the ancestor chain where the keys are not yet created, create them.\n                if (current[subkey] === undefined && value !== undefined) {\n                    // See if the next piece is a number\n                    const nextPiece = subkeys[i + 1];\n                    current[subkey] = Number.isNaN(parseInt(nextPiece, 10)) ? {} : [];\n                    createdObjectsOrArrays = true;\n                }\n                // Move deeper into the object\n                current = current[subkey];\n                // If we can go no further, then quit\n                if (!Array.isArray(current) && !(0, util_js_1.isBasicObject)(current) && i < ln - 1)\n                    return;\n            }\n        }\n        // If there are now new arrays or objects in the main object, we need to reparse it\n        if (createdObjectsOrArrays ||\n            Array.isArray(value) ||\n            (0, util_js_1.isBasicObject)(value)) {\n            this._reParseObj();\n        }\n    }\n    removeValueForPosition(position) {\n        this.setValueForPosition(position, undefined);\n    }\n    getKeyForPosition(position) {\n        return this._affectedKeys[position];\n    }\n    getGenericKeyForPosition(position) {\n        return this._genericAffectedKeys[position];\n    }\n    /**\n     * @param key Non-generic key\n     * @returns The value and operator of the requested non-generic key.\n     *   Example: {value: 1, operator: \"$pull\"}\n     */\n    getInfoForKey(key) {\n        // Get the info\n        const position = this.getPositionForKey(key);\n        if (position !== undefined) {\n            return {\n                value: this.getValueForPosition(position),\n                operator: (0, util_js_1.extractOp)(position)\n            };\n        }\n        // If we haven't returned yet, check to see if there is an array value\n        // corresponding to this key\n        // We find the first item within the array, strip the last piece off the\n        // position string, and then return whatever is at that new position in\n        // the original object.\n        const positions = this.getPositionsForGenericKey(`${key}.$`);\n        for (let index = 0; index < positions.length; index++) {\n            const pos = positions[index];\n            let value = this.getValueForPosition(pos);\n            if (value === undefined) {\n                const parentPosition = pos.slice(0, pos.lastIndexOf('['));\n                value = this.getValueForPosition(parentPosition);\n            }\n            if (value !== undefined) {\n                return {\n                    value,\n                    operator: (0, util_js_1.extractOp)(pos)\n                };\n            }\n        }\n    }\n    /**\n     * @method MongoObject.getPositionForKey\n     * @param {String} key - Non-generic key\n     * @returns The position string for the place in the object that\n     *   affects the requested non-generic key.\n     *   Example: 'foo[bar][0]'\n     */\n    getPositionForKey(key) {\n        const positions = Object.getOwnPropertyNames(this._affectedKeys);\n        for (let index = 0; index < positions.length; index++) {\n            const position = positions[index];\n            // We return the first one we find. While it's\n            // possible that multiple update operators could\n            // affect the same non-generic key, we'll assume that's not the case.\n            if (this._affectedKeys[position] === key)\n                return position;\n        }\n    }\n    /**\n     * @param genericKey Generic key\n     * @returns An array of position strings for the places in the object that\n     *   affect the requested generic key.\n     *   Example: ['foo[bar][0]']\n     */\n    getPositionsForGenericKey(genericKey) {\n        return this.getPositionsInfoForGenericKey(genericKey).map((p) => p.position);\n    }\n    /**\n     * @param genericKey Generic key\n     * @returns An array of position info for the places in the object that\n     *   affect the requested generic key.\n     */\n    getPositionsInfoForGenericKey(genericKey) {\n        let positions = this._positionsByGenericKey[genericKey];\n        if (positions == null || positions.length === 0)\n            positions = this._positionsByGenericKey[`${genericKey}.$`];\n        if (positions == null || positions.length === 0)\n            positions = [];\n        return positions.map((info) => (Object.assign({ value: this.getValueForPosition(info.position) }, info)));\n    }\n    getPositionsThatCreateGenericKey(genericKey) {\n        var _a;\n        return (_a = this._positionsThatCreateGenericKey[genericKey]) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * @deprecated Use getInfoForKey\n     * @param {String} key - Non-generic key\n     * @returns The value of the requested non-generic key\n     */\n    getValueForKey(key) {\n        const position = this.getPositionForKey(key);\n        if (position != null)\n            return this.getValueForPosition(position);\n    }\n    /**\n     * Adds `key` with value `val` under operator `op` to the source object.\n     *\n     * @param key Key to set\n     * @param val Value to give this key\n     * @param op Operator under which to set it, or `null` for a non-modifier object\n     * @returns\n     */\n    addKey(key, val, op) {\n        const position = op != null ? `${op}[${key}]` : (0, util_js_1.keyToPosition)(key);\n        this.setValueForPosition(position, val);\n    }\n    /**\n     * Removes anything that affects any of the generic keys in the list\n     */\n    removeGenericKeys(keys) {\n        Object.getOwnPropertyNames(this._genericAffectedKeys).forEach((position) => {\n            const genericKey = this._genericAffectedKeys[position];\n            if (genericKey !== null && keys.includes(genericKey)) {\n                this.removeValueForPosition(position);\n            }\n        });\n    }\n    /**\n     * Removes anything that affects the requested generic key\n     */\n    removeGenericKey(key) {\n        Object.getOwnPropertyNames(this._genericAffectedKeys).forEach((position) => {\n            if (this._genericAffectedKeys[position] === key) {\n                this.removeValueForPosition(position);\n            }\n        });\n    }\n    /**\n     * Removes anything that affects the requested non-generic key\n     */\n    removeKey(key) {\n        // We don't use getPositionForKey here because we want to be sure to\n        // remove for all positions if there are multiple.\n        Object.getOwnPropertyNames(this._affectedKeys).forEach((position) => {\n            if (this._affectedKeys[position] === key) {\n                this.removeValueForPosition(position);\n            }\n        });\n    }\n    /**\n     * Removes anything that affects any of the non-generic keys in the list\n     */\n    removeKeys(keys) {\n        keys.forEach((key) => this.removeKey(key));\n    }\n    /**\n     * Passes all affected keys to a test function, which\n     * should return false to remove whatever is affecting that key\n     */\n    filterGenericKeys(test) {\n        const checkedKeys = [];\n        const keysToRemove = [];\n        Object.getOwnPropertyNames(this._genericAffectedKeys).forEach((position) => {\n            const genericKey = this._genericAffectedKeys[position];\n            if (genericKey !== null && !checkedKeys.includes(genericKey)) {\n                checkedKeys.push(genericKey);\n                if (genericKey != null && !test(genericKey)) {\n                    keysToRemove.push(genericKey);\n                }\n            }\n        });\n        keysToRemove.forEach((key) => this.removeGenericKey(key));\n    }\n    /**\n     * Sets the value for every place in the object that affects\n     * the requested non-generic key\n     */\n    setValueForKey(key, val) {\n        // We don't use getPositionForKey here because we want to be sure to\n        // set the value for all positions if there are multiple.\n        Object.getOwnPropertyNames(this._affectedKeys).forEach((position) => {\n            if (this._affectedKeys[position] === key) {\n                this.setValueForPosition(position, val);\n            }\n        });\n    }\n    /**\n     * Sets the value for every place in the object that affects\n     * the requested generic key\n     */\n    setValueForGenericKey(key, val) {\n        // We don't use getPositionForKey here because we want to be sure to\n        // set the value for all positions if there are multiple.\n        Object.getOwnPropertyNames(this._genericAffectedKeys).forEach((position) => {\n            if (this._genericAffectedKeys[position] === key) {\n                this.setValueForPosition(position, val);\n            }\n        });\n    }\n    removeArrayItems() {\n        // Traverse and pull out removed array items at this point\n        function traverse(obj) {\n            (0, util_js_1.each)(obj, (val, indexOrProp) => {\n                // Move deeper into the object\n                const next = obj[indexOrProp];\n                // If we can go no further, then quit\n                if ((0, util_js_1.isBasicObject)(next)) {\n                    traverse(next);\n                }\n                else if (Array.isArray(next)) {\n                    obj[indexOrProp] = next.filter((item) => item !== REMOVED_MARKER);\n                    traverse(obj[indexOrProp]);\n                }\n                return undefined;\n            });\n        }\n        traverse(this._obj);\n    }\n    /**\n     * Get the source object, potentially modified by other method calls on this\n     * MongoObject instance.\n     */\n    getObject() {\n        return this._obj;\n    }\n    /**\n     * Gets a flat object based on the MongoObject instance.\n     * In a flat object, the key is the name of the non-generic affectedKey,\n     * with mongo dot notation if necessary, and the value is the value for\n     * that key.\n     *\n     * With `keepArrays: true`, we don't flatten within arrays. Currently\n     * MongoDB does not see a key such as `a.0.b` and automatically assume\n     * an array. Instead it would create an object with key '0' if there\n     * wasn't already an array saved as the value of `a`, which is rarely\n     * if ever what we actually want. To avoid this confusion, we\n     * set entire arrays.\n     */\n    getFlatObject({ keepArrays = false } = {}) {\n        const newObj = {};\n        Object.keys(this._affectedKeys).forEach((position) => {\n            const affectedKey = this._affectedKeys[position];\n            if (typeof affectedKey === 'string' &&\n                ((keepArrays &&\n                    !this._positionsInsideArrays.includes(position) &&\n                    !this._objectPositions.includes(position)) ||\n                    (!keepArrays &&\n                        !this._parentPositions.includes(position)))) {\n                newObj[affectedKey] = this.getValueForPosition(position);\n            }\n        });\n        return newObj;\n    }\n    /**\n     * @method MongoObject.affectsKey\n     * @param key Key to test\n     * @returns True if the non-generic key is affected by this object\n     */\n    affectsKey(key) {\n        return this.getPositionForKey(key) !== undefined;\n    }\n    /**\n     * @method MongoObject.affectsGenericKey\n     * @param key Key to test\n     * @returns True if the generic key is affected by this object\n     */\n    affectsGenericKey(key) {\n        const positions = Object.getOwnPropertyNames(this._genericAffectedKeys);\n        for (let index = 0; index < positions.length; index++) {\n            const position = positions[index];\n            if (this._genericAffectedKeys[position] === key)\n                return true;\n        }\n        return false;\n    }\n    /**\n     * @method MongoObject.affectsGenericKeyImplicit\n     * @param key Key to test\n     * @returns Like affectsGenericKey, but will return true if a child key is affected\n     */\n    affectsGenericKeyImplicit(key) {\n        const positions = Object.getOwnPropertyNames(this._genericAffectedKeys);\n        for (let index = 0; index < positions.length; index++) {\n            const position = positions[index];\n            const affectedKey = this._genericAffectedKeys[position];\n            if (affectedKey !== null &&\n                (0, util_js_1.genericKeyAffectsOtherGenericKey)(key, affectedKey))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * This is different from MongoObject.prototype.getKeyForPosition in that\n     * this method does not depend on the requested position actually being\n     * present in any particular MongoObject.\n     *\n     * @method MongoObject._positionToKey\n     * @param position\n     * @returns The key that this position in an object would affect.\n     */\n    static _positionToKey(position) {\n        // XXX Probably a better way to do this, but this is\n        // foolproof for now.\n        const mDoc = new MongoObject({});\n        mDoc.setValueForPosition(position, 1); // Value doesn't matter\n        return mDoc.getKeyForPosition(position);\n    }\n    /**\n     * @method MongoObject.docToModifier\n     * @public\n     * @param doc - An object to be converted into a MongoDB modifier\n     * @param [options] Options\n     * @returns A MongoDB modifier.\n     *\n     * Converts an object into a modifier by flattening it, putting keys with\n     * null, undefined, and empty string values into `modifier.$unset`, and\n     * putting the rest of the keys into `modifier.$set`.\n     */\n    static docToModifier(doc, { keepArrays = false, keepEmptyStrings = false } = {}) {\n        // Flatten doc\n        const mDoc = new MongoObject(doc);\n        let flatDoc = mDoc.getFlatObject({ keepArrays });\n        // Get a list of null, undefined, and empty string values so we can unset them instead\n        const nulls = (0, util_js_1.reportNulls)(flatDoc, keepEmptyStrings);\n        flatDoc = (0, util_js_1.cleanNulls)(flatDoc, false, keepEmptyStrings);\n        const modifier = {};\n        if (!(0, util_js_1.isEmpty)(flatDoc))\n            modifier.$set = flatDoc;\n        if (!(0, util_js_1.isEmpty)(nulls))\n            modifier.$unset = nulls;\n        return modifier;\n    }\n    static objAffectsKey(obj, key) {\n        const mDoc = new MongoObject(obj);\n        return mDoc.affectsKey(key);\n    }\n    /**\n     * @param genericKey Generic key\n     * @return Array of other generic keys that would be created by this generic key\n     */\n    static objectsThatGenericKeyWillCreate(genericKey) {\n        const objs = [];\n        do {\n            const lastDotPosition = genericKey.lastIndexOf('.');\n            genericKey = lastDotPosition === -1 ? '' : genericKey.slice(0, lastDotPosition);\n            if (genericKey.length > 0 && !genericKey.endsWith('.$'))\n                objs.push(genericKey);\n        } while (genericKey.length > 0);\n        return objs;\n    }\n    /**\n     * Takes a flat object and returns an expanded version of it.\n     */\n    static expandObj(doc) {\n        const newDoc = {};\n        Object.keys(doc).forEach((key) => {\n            const val = doc[key];\n            const subkeys = key.split('.');\n            const subkeylen = subkeys.length;\n            let current = newDoc;\n            for (let i = 0; i < subkeylen; i++) {\n                const subkey = subkeys[i];\n                if (typeof current[subkey] !== 'undefined' &&\n                    !(0, util_js_1.isObject)(current[subkey])) {\n                    break; // Already set for some reason; leave it alone\n                }\n                if (i === subkeylen - 1) {\n                    // Last iteration; time to set the value\n                    current[subkey] = val;\n                }\n                else {\n                    // See if the next piece is a number\n                    const nextPiece = subkeys[i + 1];\n                    const nextPieceInt = parseInt(nextPiece, 10);\n                    if (Number.isNaN(nextPieceInt) && !(0, util_js_1.isObject)(current[subkey])) {\n                        current[subkey] = {};\n                    }\n                    else if (!Number.isNaN(nextPieceInt) &&\n                        !Array.isArray(current[subkey])) {\n                        current[subkey] = [];\n                    }\n                }\n                current = current[subkey];\n            }\n        });\n        return newDoc;\n    }\n}\nexports.default = MongoObject;\n/* STATIC */\nMongoObject._keyToPosition = util_js_1.keyToPosition;\nMongoObject.cleanNulls = util_js_1.cleanNulls;\nMongoObject.expandKey = util_js_1.expandKey;\nMongoObject.isBasicObject = util_js_1.isBasicObject;\nMongoObject.makeKeyGeneric = util_js_1.makeKeyGeneric;\nMongoObject.reportNulls = util_js_1.reportNulls;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"util.js\":function module(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/mongo-object/dist/cjs/util.js                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expandKey = exports.keyToPosition = exports.makeKeyGeneric = exports.isObject = exports.isEmpty = exports.isPrototype = exports.each = exports.isArrayLike = exports.isLength = exports.isNullUndefinedOrEmptyString = exports.genericKeyAffectsOtherGenericKey = exports.extractOp = exports.appendAffectedKey = exports.reportNulls = exports.isBasicObject = exports.cleanNulls = void 0;\n/** Used as references for various `Number` constants. */\nconst MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * @param doc Source object or array\n * @param isArray True if `doc` is an array\n * @param keepEmptyStrings Whether to keep empty strings\n * @returns An object in which all properties with null, undefined, or empty\n *   string values have been removed, recursively.\n */\nfunction cleanNulls(doc, isArray = false, keepEmptyStrings = false) {\n    const newDoc = isArray ? [] : {};\n    Object.keys(doc).forEach((key) => {\n        let val = doc[key];\n        if (!Array.isArray(val) && isBasicObject(val)) {\n            val = cleanNulls(val, false, keepEmptyStrings); // Recurse into plain objects\n            if (!isEmpty(val))\n                newDoc[key] = val;\n        }\n        else if (Array.isArray(val)) {\n            val = cleanNulls(val, true, keepEmptyStrings); // Recurse into non-typed arrays\n            if (!isEmpty(val))\n                newDoc[key] = val;\n        }\n        else if (!isNullUndefinedOrEmptyString(val)) {\n            newDoc[key] = val;\n        }\n        else if (keepEmptyStrings &&\n            typeof val === 'string' &&\n            val.length === 0) {\n            newDoc[key] = val;\n        }\n    });\n    return newDoc;\n}\nexports.cleanNulls = cleanNulls;\n/**\n * @param obj Any reference to check\n * @returns True if obj is an Object as opposed to\n *   something that inherits from Object\n */\nfunction isBasicObject(obj) {\n    return obj === Object(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n}\nexports.isBasicObject = isBasicObject;\n/**\n * @method MongoObject.reportNulls\n * @public\n * @param flatDoc An object with no properties that are also objects.\n * @returns An object in which the keys represent the keys in the\n *   original object that were null, undefined, or empty strings, and the value\n *   of each key is \"\".\n */\nfunction reportNulls(flatDoc, keepEmptyStrings = false) {\n    const nulls = {};\n    // Loop through the flat doc\n    Object.keys(flatDoc).forEach((key) => {\n        const val = flatDoc[key];\n        if (val === null ||\n            val === undefined ||\n            (!keepEmptyStrings && typeof val === 'string' && val.length === 0) ||\n            // If value is an array in which all the values recursively are undefined, null,\n            // or an empty string\n            (Array.isArray(val) &&\n                cleanNulls(val, true, keepEmptyStrings).length === 0)) {\n            nulls[key] = '';\n        }\n    });\n    return nulls;\n}\nexports.reportNulls = reportNulls;\nfunction appendAffectedKey(affectedKey, key) {\n    if (key === '$each')\n        return affectedKey;\n    return (affectedKey != null && affectedKey.length > 0) ? `${affectedKey}.${key}` : key;\n}\nexports.appendAffectedKey = appendAffectedKey;\n// Extracts operator piece, if present, from position string\nfunction extractOp(position) {\n    const firstPositionPiece = position.slice(0, position.indexOf('['));\n    return firstPositionPiece.substring(0, 1) === '$' ? firstPositionPiece : null;\n}\nexports.extractOp = extractOp;\nfunction genericKeyAffectsOtherGenericKey(key, affectedKey) {\n    // If the affected key is the test key\n    if (affectedKey === key)\n        return true;\n    // If the affected key implies the test key because the affected key\n    // starts with the test key followed by a period\n    if (affectedKey.substring(0, key.length + 1) === `${key}.`)\n        return true;\n    // If the affected key implies the test key because the affected key\n    // starts with the test key and the test key ends with \".$\"\n    const lastTwo = key.slice(-2);\n    if (lastTwo === '.$' && key.slice(0, -2) === affectedKey)\n        return true;\n    return false;\n}\nexports.genericKeyAffectsOtherGenericKey = genericKeyAffectsOtherGenericKey;\nfunction isNullUndefinedOrEmptyString(val) {\n    return (val === undefined ||\n        val === null ||\n        (typeof val === 'string' && val.length === 0));\n}\nexports.isNullUndefinedOrEmptyString = isNullUndefinedOrEmptyString;\nfunction isLength(value) {\n    return (typeof value === 'number' &&\n        value > -1 &&\n        value % 1 === 0 &&\n        value <= MAX_SAFE_INTEGER);\n}\nexports.isLength = isLength;\nfunction isArrayLike(value) {\n    return value != null && typeof value !== 'function' && isLength(value.length);\n}\nexports.isArrayLike = isArrayLike;\nfunction each(collection, iteratee) {\n    if (collection == null) {\n        return;\n    }\n    if (Array.isArray(collection)) {\n        collection.forEach(iteratee);\n        return;\n    }\n    const iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n        Object.keys(iterable).forEach((key) => iteratee(iterable[key], key, iterable));\n        return;\n    }\n    let index = -1;\n    while (++index < collection.length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n        }\n    }\n}\nexports.each = each;\nfunction isPrototype(value) {\n    const Ctor = value === null || value === void 0 ? void 0 : value.constructor;\n    if (typeof Ctor !== 'function' || Ctor.prototype === undefined) {\n        return value === Object.prototype;\n    }\n    return value === Ctor.prototype;\n}\nexports.isPrototype = isPrototype;\nfunction isEmpty(value) {\n    if (value === null || value === undefined) {\n        return true;\n    }\n    if (Array.isArray(value) || typeof value === 'string') {\n        return value.length === 0;\n    }\n    const tag = Object.prototype.toString.call(value);\n    if (tag === '[object Map]' || tag === '[object Set]') {\n        return value.size === 0;\n    }\n    if (isPrototype(value)) {\n        return Object.keys(value).length === 0;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key in value) {\n        if (Object.hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isEmpty = isEmpty;\nfunction isObject(value) {\n    const type = typeof value;\n    return value != null && (type === 'object' || type === 'function');\n}\nexports.isObject = isObject;\n/* Takes a specific string that uses any mongo-style positional update\n * dot notation and returns a generic string equivalent. Replaces all numeric\n * positional \"pieces\" (e.g. '.1') or any other positional operator\n * (e.g. '$[<identifier>]')  with a dollar sign ($).\n *\n * @param key A specific or generic key\n * @returns Generic name.\n */\nfunction makeKeyGeneric(key) {\n    if (typeof key !== 'string')\n        return null;\n    return key.replace(/\\.([0-9]+|\\$\\[[^\\]]*\\])(?=\\.|$)/g, '.$');\n}\nexports.makeKeyGeneric = makeKeyGeneric;\nfunction keyToPosition(key, wrapAll = false) {\n    let position = '';\n    key.split('.').forEach((piece, i) => {\n        if (i === 0 && !wrapAll) {\n            position += piece;\n        }\n        else {\n            position += `[${piece}]`;\n        }\n    });\n    return position;\n}\nexports.keyToPosition = keyToPosition;\n/**\n *  Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *\n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    'a[b.0.c]' -> {a: {'b.0.c': 1}}\n * @param val Value\n * @param key Key\n * @param obj Object\n */\nfunction expandKey(val, key, obj) {\n    const subkeys = key.split('[');\n    let current = obj;\n    for (let i = 0, ln = subkeys.length; i < ln; i++) {\n        let subkey = subkeys[i];\n        if (subkey.slice(-1) === ']') {\n            subkey = subkey.slice(0, -1);\n        }\n        if (i === ln - 1) {\n            // Last iteration; time to set the value; always overwrite\n            current[subkey] = val;\n            // If val is undefined, delete the property\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            if (val === undefined)\n                delete current[subkey];\n        }\n        else {\n            // See if the next piece is a number\n            const nextPiece = subkeys[i + 1];\n            if (current[subkey] === undefined) {\n                current[subkey] = Number.isNaN(parseInt(nextPiece, 10)) ? {} : [];\n            }\n        }\n        current = current[subkey];\n    }\n}\nexports.expandKey = expandKey;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}},\"react\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/react/package.json                                                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"browserify\": {\n    \"transform\": [\n      \"loose-envify\"\n    ]\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/facebook/react/issues\"\n  },\n  \"dependencies\": {\n    \"loose-envify\": \"^1.1.0\"\n  },\n  \"description\": \"React is a JavaScript library for building user interfaces.\",\n  \"engines\": {\n    \"node\": \">=0.10.0\"\n  },\n  \"exports\": {\n    \".\": {\n      \"react-server\": \"./react.shared-subset.js\",\n      \"default\": \"./index.js\"\n    },\n    \"./package.json\": \"./package.json\",\n    \"./jsx-runtime\": \"./jsx-runtime.js\",\n    \"./jsx-dev-runtime\": \"./jsx-dev-runtime.js\"\n  },\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"index.js\",\n    \"cjs/\",\n    \"umd/\",\n    \"jsx-runtime.js\",\n    \"jsx-dev-runtime.js\",\n    \"react.shared-subset.js\"\n  ],\n  \"homepage\": \"https://reactjs.org/\",\n  \"keywords\": [\n    \"react\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"index.js\",\n  \"name\": \"react\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/facebook/react.git\",\n    \"directory\": \"packages/react\"\n  },\n  \"version\": \"18.2.0\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"@babel\":{\"runtime\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/@babel/runtime/package.json                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"author\": {\n    \"name\": \"The Babel Team\",\n    \"url\": \"https://babel.dev/team\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/babel/babel/issues\"\n  },\n  \"dependencies\": {\n    \"regenerator-runtime\": \"^0.14.0\"\n  },\n  \"description\": \"babel's modular runtime helpers\",\n  \"engines\": {\n    \"node\": \">=6.9.0\"\n  },\n  \"exports\": {\n    \"./helpers/AsyncGenerator\": [\n      {\n        \"node\": \"./helpers/AsyncGenerator.js\",\n        \"import\": \"./helpers/esm/AsyncGenerator.js\",\n        \"default\": \"./helpers/AsyncGenerator.js\"\n      },\n      \"./helpers/AsyncGenerator.js\"\n    ],\n    \"./helpers/esm/AsyncGenerator\": \"./helpers/esm/AsyncGenerator.js\",\n    \"./helpers/OverloadYield\": [\n      {\n        \"node\": \"./helpers/OverloadYield.js\",\n        \"import\": \"./helpers/esm/OverloadYield.js\",\n        \"default\": \"./helpers/OverloadYield.js\"\n      },\n      \"./helpers/OverloadYield.js\"\n    ],\n    \"./helpers/esm/OverloadYield\": \"./helpers/esm/OverloadYield.js\",\n    \"./helpers/applyDecs\": [\n      {\n        \"node\": \"./helpers/applyDecs.js\",\n        \"import\": \"./helpers/esm/applyDecs.js\",\n        \"default\": \"./helpers/applyDecs.js\"\n      },\n      \"./helpers/applyDecs.js\"\n    ],\n    \"./helpers/esm/applyDecs\": \"./helpers/esm/applyDecs.js\",\n    \"./helpers/applyDecs2203\": [\n      {\n        \"node\": \"./helpers/applyDecs2203.js\",\n        \"import\": \"./helpers/esm/applyDecs2203.js\",\n        \"default\": \"./helpers/applyDecs2203.js\"\n      },\n      \"./helpers/applyDecs2203.js\"\n    ],\n    \"./helpers/esm/applyDecs2203\": \"./helpers/esm/applyDecs2203.js\",\n    \"./helpers/applyDecs2203R\": [\n      {\n        \"node\": \"./helpers/applyDecs2203R.js\",\n        \"import\": \"./helpers/esm/applyDecs2203R.js\",\n        \"default\": \"./helpers/applyDecs2203R.js\"\n      },\n      \"./helpers/applyDecs2203R.js\"\n    ],\n    \"./helpers/esm/applyDecs2203R\": \"./helpers/esm/applyDecs2203R.js\",\n    \"./helpers/applyDecs2301\": [\n      {\n        \"node\": \"./helpers/applyDecs2301.js\",\n        \"import\": \"./helpers/esm/applyDecs2301.js\",\n        \"default\": \"./helpers/applyDecs2301.js\"\n      },\n      \"./helpers/applyDecs2301.js\"\n    ],\n    \"./helpers/esm/applyDecs2301\": \"./helpers/esm/applyDecs2301.js\",\n    \"./helpers/applyDecs2305\": [\n      {\n        \"node\": \"./helpers/applyDecs2305.js\",\n        \"import\": \"./helpers/esm/applyDecs2305.js\",\n        \"default\": \"./helpers/applyDecs2305.js\"\n      },\n      \"./helpers/applyDecs2305.js\"\n    ],\n    \"./helpers/esm/applyDecs2305\": \"./helpers/esm/applyDecs2305.js\",\n    \"./helpers/applyDecs2311\": [\n      {\n        \"node\": \"./helpers/applyDecs2311.js\",\n        \"import\": \"./helpers/esm/applyDecs2311.js\",\n        \"default\": \"./helpers/applyDecs2311.js\"\n      },\n      \"./helpers/applyDecs2311.js\"\n    ],\n    \"./helpers/esm/applyDecs2311\": \"./helpers/esm/applyDecs2311.js\",\n    \"./helpers/assertClassBrand\": [\n      {\n        \"node\": \"./helpers/assertClassBrand.js\",\n        \"import\": \"./helpers/esm/assertClassBrand.js\",\n        \"default\": \"./helpers/assertClassBrand.js\"\n      },\n      \"./helpers/assertClassBrand.js\"\n    ],\n    \"./helpers/esm/assertClassBrand\": \"./helpers/esm/assertClassBrand.js\",\n    \"./helpers/asyncGeneratorDelegate\": [\n      {\n        \"node\": \"./helpers/asyncGeneratorDelegate.js\",\n        \"import\": \"./helpers/esm/asyncGeneratorDelegate.js\",\n        \"default\": \"./helpers/asyncGeneratorDelegate.js\"\n      },\n      \"./helpers/asyncGeneratorDelegate.js\"\n    ],\n    \"./helpers/esm/asyncGeneratorDelegate\": \"./helpers/esm/asyncGeneratorDelegate.js\",\n    \"./helpers/asyncIterator\": [\n      {\n        \"node\": \"./helpers/asyncIterator.js\",\n        \"import\": \"./helpers/esm/asyncIterator.js\",\n        \"default\": \"./helpers/asyncIterator.js\"\n      },\n      \"./helpers/asyncIterator.js\"\n    ],\n    \"./helpers/esm/asyncIterator\": \"./helpers/esm/asyncIterator.js\",\n    \"./helpers/awaitAsyncGenerator\": [\n      {\n        \"node\": \"./helpers/awaitAsyncGenerator.js\",\n        \"import\": \"./helpers/esm/awaitAsyncGenerator.js\",\n        \"default\": \"./helpers/awaitAsyncGenerator.js\"\n      },\n      \"./helpers/awaitAsyncGenerator.js\"\n    ],\n    \"./helpers/esm/awaitAsyncGenerator\": \"./helpers/esm/awaitAsyncGenerator.js\",\n    \"./helpers/callSuper\": [\n      {\n        \"node\": \"./helpers/callSuper.js\",\n        \"import\": \"./helpers/esm/callSuper.js\",\n        \"default\": \"./helpers/callSuper.js\"\n      },\n      \"./helpers/callSuper.js\"\n    ],\n    \"./helpers/esm/callSuper\": \"./helpers/esm/callSuper.js\",\n    \"./helpers/checkInRHS\": [\n      {\n        \"node\": \"./helpers/checkInRHS.js\",\n        \"import\": \"./helpers/esm/checkInRHS.js\",\n        \"default\": \"./helpers/checkInRHS.js\"\n      },\n      \"./helpers/checkInRHS.js\"\n    ],\n    \"./helpers/esm/checkInRHS\": \"./helpers/esm/checkInRHS.js\",\n    \"./helpers/classPrivateFieldGet2\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldGet2.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldGet2.js\",\n        \"default\": \"./helpers/classPrivateFieldGet2.js\"\n      },\n      \"./helpers/classPrivateFieldGet2.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldGet2\": \"./helpers/esm/classPrivateFieldGet2.js\",\n    \"./helpers/classPrivateFieldSet2\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldSet2.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldSet2.js\",\n        \"default\": \"./helpers/classPrivateFieldSet2.js\"\n      },\n      \"./helpers/classPrivateFieldSet2.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldSet2\": \"./helpers/esm/classPrivateFieldSet2.js\",\n    \"./helpers/classPrivateGetter\": [\n      {\n        \"node\": \"./helpers/classPrivateGetter.js\",\n        \"import\": \"./helpers/esm/classPrivateGetter.js\",\n        \"default\": \"./helpers/classPrivateGetter.js\"\n      },\n      \"./helpers/classPrivateGetter.js\"\n    ],\n    \"./helpers/esm/classPrivateGetter\": \"./helpers/esm/classPrivateGetter.js\",\n    \"./helpers/classPrivateSetter\": [\n      {\n        \"node\": \"./helpers/classPrivateSetter.js\",\n        \"import\": \"./helpers/esm/classPrivateSetter.js\",\n        \"default\": \"./helpers/classPrivateSetter.js\"\n      },\n      \"./helpers/classPrivateSetter.js\"\n    ],\n    \"./helpers/esm/classPrivateSetter\": \"./helpers/esm/classPrivateSetter.js\",\n    \"./helpers/construct\": [\n      {\n        \"node\": \"./helpers/construct.js\",\n        \"import\": \"./helpers/esm/construct.js\",\n        \"default\": \"./helpers/construct.js\"\n      },\n      \"./helpers/construct.js\"\n    ],\n    \"./helpers/esm/construct\": \"./helpers/esm/construct.js\",\n    \"./helpers/defineAccessor\": [\n      {\n        \"node\": \"./helpers/defineAccessor.js\",\n        \"import\": \"./helpers/esm/defineAccessor.js\",\n        \"default\": \"./helpers/defineAccessor.js\"\n      },\n      \"./helpers/defineAccessor.js\"\n    ],\n    \"./helpers/esm/defineAccessor\": \"./helpers/esm/defineAccessor.js\",\n    \"./helpers/dispose\": [\n      {\n        \"node\": \"./helpers/dispose.js\",\n        \"import\": \"./helpers/esm/dispose.js\",\n        \"default\": \"./helpers/dispose.js\"\n      },\n      \"./helpers/dispose.js\"\n    ],\n    \"./helpers/esm/dispose\": \"./helpers/esm/dispose.js\",\n    \"./helpers/importDeferProxy\": [\n      {\n        \"node\": \"./helpers/importDeferProxy.js\",\n        \"import\": \"./helpers/esm/importDeferProxy.js\",\n        \"default\": \"./helpers/importDeferProxy.js\"\n      },\n      \"./helpers/importDeferProxy.js\"\n    ],\n    \"./helpers/esm/importDeferProxy\": \"./helpers/esm/importDeferProxy.js\",\n    \"./helpers/interopRequireWildcard\": [\n      {\n        \"node\": \"./helpers/interopRequireWildcard.js\",\n        \"import\": \"./helpers/esm/interopRequireWildcard.js\",\n        \"default\": \"./helpers/interopRequireWildcard.js\"\n      },\n      \"./helpers/interopRequireWildcard.js\"\n    ],\n    \"./helpers/esm/interopRequireWildcard\": \"./helpers/esm/interopRequireWildcard.js\",\n    \"./helpers/isNativeReflectConstruct\": [\n      {\n        \"node\": \"./helpers/isNativeReflectConstruct.js\",\n        \"import\": \"./helpers/esm/isNativeReflectConstruct.js\",\n        \"default\": \"./helpers/isNativeReflectConstruct.js\"\n      },\n      \"./helpers/isNativeReflectConstruct.js\"\n    ],\n    \"./helpers/esm/isNativeReflectConstruct\": \"./helpers/esm/isNativeReflectConstruct.js\",\n    \"./helpers/iterableToArrayLimit\": [\n      {\n        \"node\": \"./helpers/iterableToArrayLimit.js\",\n        \"import\": \"./helpers/esm/iterableToArrayLimit.js\",\n        \"default\": \"./helpers/iterableToArrayLimit.js\"\n      },\n      \"./helpers/iterableToArrayLimit.js\"\n    ],\n    \"./helpers/esm/iterableToArrayLimit\": \"./helpers/esm/iterableToArrayLimit.js\",\n    \"./helpers/iterableToArrayLimitLoose\": [\n      {\n        \"node\": \"./helpers/iterableToArrayLimitLoose.js\",\n        \"import\": \"./helpers/esm/iterableToArrayLimitLoose.js\",\n        \"default\": \"./helpers/iterableToArrayLimitLoose.js\"\n      },\n      \"./helpers/iterableToArrayLimitLoose.js\"\n    ],\n    \"./helpers/esm/iterableToArrayLimitLoose\": \"./helpers/esm/iterableToArrayLimitLoose.js\",\n    \"./helpers/jsx\": [\n      {\n        \"node\": \"./helpers/jsx.js\",\n        \"import\": \"./helpers/esm/jsx.js\",\n        \"default\": \"./helpers/jsx.js\"\n      },\n      \"./helpers/jsx.js\"\n    ],\n    \"./helpers/esm/jsx\": \"./helpers/esm/jsx.js\",\n    \"./helpers/objectSpread2\": [\n      {\n        \"node\": \"./helpers/objectSpread2.js\",\n        \"import\": \"./helpers/esm/objectSpread2.js\",\n        \"default\": \"./helpers/objectSpread2.js\"\n      },\n      \"./helpers/objectSpread2.js\"\n    ],\n    \"./helpers/esm/objectSpread2\": \"./helpers/esm/objectSpread2.js\",\n    \"./helpers/regeneratorRuntime\": [\n      {\n        \"node\": \"./helpers/regeneratorRuntime.js\",\n        \"import\": \"./helpers/esm/regeneratorRuntime.js\",\n        \"default\": \"./helpers/regeneratorRuntime.js\"\n      },\n      \"./helpers/regeneratorRuntime.js\"\n    ],\n    \"./helpers/esm/regeneratorRuntime\": \"./helpers/esm/regeneratorRuntime.js\",\n    \"./helpers/setFunctionName\": [\n      {\n        \"node\": \"./helpers/setFunctionName.js\",\n        \"import\": \"./helpers/esm/setFunctionName.js\",\n        \"default\": \"./helpers/setFunctionName.js\"\n      },\n      \"./helpers/setFunctionName.js\"\n    ],\n    \"./helpers/esm/setFunctionName\": \"./helpers/esm/setFunctionName.js\",\n    \"./helpers/toPrimitive\": [\n      {\n        \"node\": \"./helpers/toPrimitive.js\",\n        \"import\": \"./helpers/esm/toPrimitive.js\",\n        \"default\": \"./helpers/toPrimitive.js\"\n      },\n      \"./helpers/toPrimitive.js\"\n    ],\n    \"./helpers/esm/toPrimitive\": \"./helpers/esm/toPrimitive.js\",\n    \"./helpers/toPropertyKey\": [\n      {\n        \"node\": \"./helpers/toPropertyKey.js\",\n        \"import\": \"./helpers/esm/toPropertyKey.js\",\n        \"default\": \"./helpers/toPropertyKey.js\"\n      },\n      \"./helpers/toPropertyKey.js\"\n    ],\n    \"./helpers/esm/toPropertyKey\": \"./helpers/esm/toPropertyKey.js\",\n    \"./helpers/toSetter\": [\n      {\n        \"node\": \"./helpers/toSetter.js\",\n        \"import\": \"./helpers/esm/toSetter.js\",\n        \"default\": \"./helpers/toSetter.js\"\n      },\n      \"./helpers/toSetter.js\"\n    ],\n    \"./helpers/esm/toSetter\": \"./helpers/esm/toSetter.js\",\n    \"./helpers/typeof\": [\n      {\n        \"node\": \"./helpers/typeof.js\",\n        \"import\": \"./helpers/esm/typeof.js\",\n        \"default\": \"./helpers/typeof.js\"\n      },\n      \"./helpers/typeof.js\"\n    ],\n    \"./helpers/esm/typeof\": \"./helpers/esm/typeof.js\",\n    \"./helpers/using\": [\n      {\n        \"node\": \"./helpers/using.js\",\n        \"import\": \"./helpers/esm/using.js\",\n        \"default\": \"./helpers/using.js\"\n      },\n      \"./helpers/using.js\"\n    ],\n    \"./helpers/esm/using\": \"./helpers/esm/using.js\",\n    \"./helpers/usingCtx\": [\n      {\n        \"node\": \"./helpers/usingCtx.js\",\n        \"import\": \"./helpers/esm/usingCtx.js\",\n        \"default\": \"./helpers/usingCtx.js\"\n      },\n      \"./helpers/usingCtx.js\"\n    ],\n    \"./helpers/esm/usingCtx\": \"./helpers/esm/usingCtx.js\",\n    \"./helpers/wrapRegExp\": [\n      {\n        \"node\": \"./helpers/wrapRegExp.js\",\n        \"import\": \"./helpers/esm/wrapRegExp.js\",\n        \"default\": \"./helpers/wrapRegExp.js\"\n      },\n      \"./helpers/wrapRegExp.js\"\n    ],\n    \"./helpers/esm/wrapRegExp\": \"./helpers/esm/wrapRegExp.js\",\n    \"./helpers/AwaitValue\": [\n      {\n        \"node\": \"./helpers/AwaitValue.js\",\n        \"import\": \"./helpers/esm/AwaitValue.js\",\n        \"default\": \"./helpers/AwaitValue.js\"\n      },\n      \"./helpers/AwaitValue.js\"\n    ],\n    \"./helpers/esm/AwaitValue\": \"./helpers/esm/AwaitValue.js\",\n    \"./helpers/wrapAsyncGenerator\": [\n      {\n        \"node\": \"./helpers/wrapAsyncGenerator.js\",\n        \"import\": \"./helpers/esm/wrapAsyncGenerator.js\",\n        \"default\": \"./helpers/wrapAsyncGenerator.js\"\n      },\n      \"./helpers/wrapAsyncGenerator.js\"\n    ],\n    \"./helpers/esm/wrapAsyncGenerator\": \"./helpers/esm/wrapAsyncGenerator.js\",\n    \"./helpers/asyncToGenerator\": [\n      {\n        \"node\": \"./helpers/asyncToGenerator.js\",\n        \"import\": \"./helpers/esm/asyncToGenerator.js\",\n        \"default\": \"./helpers/asyncToGenerator.js\"\n      },\n      \"./helpers/asyncToGenerator.js\"\n    ],\n    \"./helpers/esm/asyncToGenerator\": \"./helpers/esm/asyncToGenerator.js\",\n    \"./helpers/classCallCheck\": [\n      {\n        \"node\": \"./helpers/classCallCheck.js\",\n        \"import\": \"./helpers/esm/classCallCheck.js\",\n        \"default\": \"./helpers/classCallCheck.js\"\n      },\n      \"./helpers/classCallCheck.js\"\n    ],\n    \"./helpers/esm/classCallCheck\": \"./helpers/esm/classCallCheck.js\",\n    \"./helpers/createClass\": [\n      {\n        \"node\": \"./helpers/createClass.js\",\n        \"import\": \"./helpers/esm/createClass.js\",\n        \"default\": \"./helpers/createClass.js\"\n      },\n      \"./helpers/createClass.js\"\n    ],\n    \"./helpers/esm/createClass\": \"./helpers/esm/createClass.js\",\n    \"./helpers/defineEnumerableProperties\": [\n      {\n        \"node\": \"./helpers/defineEnumerableProperties.js\",\n        \"import\": \"./helpers/esm/defineEnumerableProperties.js\",\n        \"default\": \"./helpers/defineEnumerableProperties.js\"\n      },\n      \"./helpers/defineEnumerableProperties.js\"\n    ],\n    \"./helpers/esm/defineEnumerableProperties\": \"./helpers/esm/defineEnumerableProperties.js\",\n    \"./helpers/defaults\": [\n      {\n        \"node\": \"./helpers/defaults.js\",\n        \"import\": \"./helpers/esm/defaults.js\",\n        \"default\": \"./helpers/defaults.js\"\n      },\n      \"./helpers/defaults.js\"\n    ],\n    \"./helpers/esm/defaults\": \"./helpers/esm/defaults.js\",\n    \"./helpers/defineProperty\": [\n      {\n        \"node\": \"./helpers/defineProperty.js\",\n        \"import\": \"./helpers/esm/defineProperty.js\",\n        \"default\": \"./helpers/defineProperty.js\"\n      },\n      \"./helpers/defineProperty.js\"\n    ],\n    \"./helpers/esm/defineProperty\": \"./helpers/esm/defineProperty.js\",\n    \"./helpers/extends\": [\n      {\n        \"node\": \"./helpers/extends.js\",\n        \"import\": \"./helpers/esm/extends.js\",\n        \"default\": \"./helpers/extends.js\"\n      },\n      \"./helpers/extends.js\"\n    ],\n    \"./helpers/esm/extends\": \"./helpers/esm/extends.js\",\n    \"./helpers/objectSpread\": [\n      {\n        \"node\": \"./helpers/objectSpread.js\",\n        \"import\": \"./helpers/esm/objectSpread.js\",\n        \"default\": \"./helpers/objectSpread.js\"\n      },\n      \"./helpers/objectSpread.js\"\n    ],\n    \"./helpers/esm/objectSpread\": \"./helpers/esm/objectSpread.js\",\n    \"./helpers/inherits\": [\n      {\n        \"node\": \"./helpers/inherits.js\",\n        \"import\": \"./helpers/esm/inherits.js\",\n        \"default\": \"./helpers/inherits.js\"\n      },\n      \"./helpers/inherits.js\"\n    ],\n    \"./helpers/esm/inherits\": \"./helpers/esm/inherits.js\",\n    \"./helpers/inheritsLoose\": [\n      {\n        \"node\": \"./helpers/inheritsLoose.js\",\n        \"import\": \"./helpers/esm/inheritsLoose.js\",\n        \"default\": \"./helpers/inheritsLoose.js\"\n      },\n      \"./helpers/inheritsLoose.js\"\n    ],\n    \"./helpers/esm/inheritsLoose\": \"./helpers/esm/inheritsLoose.js\",\n    \"./helpers/getPrototypeOf\": [\n      {\n        \"node\": \"./helpers/getPrototypeOf.js\",\n        \"import\": \"./helpers/esm/getPrototypeOf.js\",\n        \"default\": \"./helpers/getPrototypeOf.js\"\n      },\n      \"./helpers/getPrototypeOf.js\"\n    ],\n    \"./helpers/esm/getPrototypeOf\": \"./helpers/esm/getPrototypeOf.js\",\n    \"./helpers/setPrototypeOf\": [\n      {\n        \"node\": \"./helpers/setPrototypeOf.js\",\n        \"import\": \"./helpers/esm/setPrototypeOf.js\",\n        \"default\": \"./helpers/setPrototypeOf.js\"\n      },\n      \"./helpers/setPrototypeOf.js\"\n    ],\n    \"./helpers/esm/setPrototypeOf\": \"./helpers/esm/setPrototypeOf.js\",\n    \"./helpers/isNativeFunction\": [\n      {\n        \"node\": \"./helpers/isNativeFunction.js\",\n        \"import\": \"./helpers/esm/isNativeFunction.js\",\n        \"default\": \"./helpers/isNativeFunction.js\"\n      },\n      \"./helpers/isNativeFunction.js\"\n    ],\n    \"./helpers/esm/isNativeFunction\": \"./helpers/esm/isNativeFunction.js\",\n    \"./helpers/wrapNativeSuper\": [\n      {\n        \"node\": \"./helpers/wrapNativeSuper.js\",\n        \"import\": \"./helpers/esm/wrapNativeSuper.js\",\n        \"default\": \"./helpers/wrapNativeSuper.js\"\n      },\n      \"./helpers/wrapNativeSuper.js\"\n    ],\n    \"./helpers/esm/wrapNativeSuper\": \"./helpers/esm/wrapNativeSuper.js\",\n    \"./helpers/instanceof\": [\n      {\n        \"node\": \"./helpers/instanceof.js\",\n        \"import\": \"./helpers/esm/instanceof.js\",\n        \"default\": \"./helpers/instanceof.js\"\n      },\n      \"./helpers/instanceof.js\"\n    ],\n    \"./helpers/esm/instanceof\": \"./helpers/esm/instanceof.js\",\n    \"./helpers/interopRequireDefault\": [\n      {\n        \"node\": \"./helpers/interopRequireDefault.js\",\n        \"import\": \"./helpers/esm/interopRequireDefault.js\",\n        \"default\": \"./helpers/interopRequireDefault.js\"\n      },\n      \"./helpers/interopRequireDefault.js\"\n    ],\n    \"./helpers/esm/interopRequireDefault\": \"./helpers/esm/interopRequireDefault.js\",\n    \"./helpers/newArrowCheck\": [\n      {\n        \"node\": \"./helpers/newArrowCheck.js\",\n        \"import\": \"./helpers/esm/newArrowCheck.js\",\n        \"default\": \"./helpers/newArrowCheck.js\"\n      },\n      \"./helpers/newArrowCheck.js\"\n    ],\n    \"./helpers/esm/newArrowCheck\": \"./helpers/esm/newArrowCheck.js\",\n    \"./helpers/objectDestructuringEmpty\": [\n      {\n        \"node\": \"./helpers/objectDestructuringEmpty.js\",\n        \"import\": \"./helpers/esm/objectDestructuringEmpty.js\",\n        \"default\": \"./helpers/objectDestructuringEmpty.js\"\n      },\n      \"./helpers/objectDestructuringEmpty.js\"\n    ],\n    \"./helpers/esm/objectDestructuringEmpty\": \"./helpers/esm/objectDestructuringEmpty.js\",\n    \"./helpers/objectWithoutPropertiesLoose\": [\n      {\n        \"node\": \"./helpers/objectWithoutPropertiesLoose.js\",\n        \"import\": \"./helpers/esm/objectWithoutPropertiesLoose.js\",\n        \"default\": \"./helpers/objectWithoutPropertiesLoose.js\"\n      },\n      \"./helpers/objectWithoutPropertiesLoose.js\"\n    ],\n    \"./helpers/esm/objectWithoutPropertiesLoose\": \"./helpers/esm/objectWithoutPropertiesLoose.js\",\n    \"./helpers/objectWithoutProperties\": [\n      {\n        \"node\": \"./helpers/objectWithoutProperties.js\",\n        \"import\": \"./helpers/esm/objectWithoutProperties.js\",\n        \"default\": \"./helpers/objectWithoutProperties.js\"\n      },\n      \"./helpers/objectWithoutProperties.js\"\n    ],\n    \"./helpers/esm/objectWithoutProperties\": \"./helpers/esm/objectWithoutProperties.js\",\n    \"./helpers/assertThisInitialized\": [\n      {\n        \"node\": \"./helpers/assertThisInitialized.js\",\n        \"import\": \"./helpers/esm/assertThisInitialized.js\",\n        \"default\": \"./helpers/assertThisInitialized.js\"\n      },\n      \"./helpers/assertThisInitialized.js\"\n    ],\n    \"./helpers/esm/assertThisInitialized\": \"./helpers/esm/assertThisInitialized.js\",\n    \"./helpers/possibleConstructorReturn\": [\n      {\n        \"node\": \"./helpers/possibleConstructorReturn.js\",\n        \"import\": \"./helpers/esm/possibleConstructorReturn.js\",\n        \"default\": \"./helpers/possibleConstructorReturn.js\"\n      },\n      \"./helpers/possibleConstructorReturn.js\"\n    ],\n    \"./helpers/esm/possibleConstructorReturn\": \"./helpers/esm/possibleConstructorReturn.js\",\n    \"./helpers/createSuper\": [\n      {\n        \"node\": \"./helpers/createSuper.js\",\n        \"import\": \"./helpers/esm/createSuper.js\",\n        \"default\": \"./helpers/createSuper.js\"\n      },\n      \"./helpers/createSuper.js\"\n    ],\n    \"./helpers/esm/createSuper\": \"./helpers/esm/createSuper.js\",\n    \"./helpers/superPropBase\": [\n      {\n        \"node\": \"./helpers/superPropBase.js\",\n        \"import\": \"./helpers/esm/superPropBase.js\",\n        \"default\": \"./helpers/superPropBase.js\"\n      },\n      \"./helpers/superPropBase.js\"\n    ],\n    \"./helpers/esm/superPropBase\": \"./helpers/esm/superPropBase.js\",\n    \"./helpers/get\": [\n      {\n        \"node\": \"./helpers/get.js\",\n        \"import\": \"./helpers/esm/get.js\",\n        \"default\": \"./helpers/get.js\"\n      },\n      \"./helpers/get.js\"\n    ],\n    \"./helpers/esm/get\": \"./helpers/esm/get.js\",\n    \"./helpers/set\": [\n      {\n        \"node\": \"./helpers/set.js\",\n        \"import\": \"./helpers/esm/set.js\",\n        \"default\": \"./helpers/set.js\"\n      },\n      \"./helpers/set.js\"\n    ],\n    \"./helpers/esm/set\": \"./helpers/esm/set.js\",\n    \"./helpers/taggedTemplateLiteral\": [\n      {\n        \"node\": \"./helpers/taggedTemplateLiteral.js\",\n        \"import\": \"./helpers/esm/taggedTemplateLiteral.js\",\n        \"default\": \"./helpers/taggedTemplateLiteral.js\"\n      },\n      \"./helpers/taggedTemplateLiteral.js\"\n    ],\n    \"./helpers/esm/taggedTemplateLiteral\": \"./helpers/esm/taggedTemplateLiteral.js\",\n    \"./helpers/taggedTemplateLiteralLoose\": [\n      {\n        \"node\": \"./helpers/taggedTemplateLiteralLoose.js\",\n        \"import\": \"./helpers/esm/taggedTemplateLiteralLoose.js\",\n        \"default\": \"./helpers/taggedTemplateLiteralLoose.js\"\n      },\n      \"./helpers/taggedTemplateLiteralLoose.js\"\n    ],\n    \"./helpers/esm/taggedTemplateLiteralLoose\": \"./helpers/esm/taggedTemplateLiteralLoose.js\",\n    \"./helpers/readOnlyError\": [\n      {\n        \"node\": \"./helpers/readOnlyError.js\",\n        \"import\": \"./helpers/esm/readOnlyError.js\",\n        \"default\": \"./helpers/readOnlyError.js\"\n      },\n      \"./helpers/readOnlyError.js\"\n    ],\n    \"./helpers/esm/readOnlyError\": \"./helpers/esm/readOnlyError.js\",\n    \"./helpers/writeOnlyError\": [\n      {\n        \"node\": \"./helpers/writeOnlyError.js\",\n        \"import\": \"./helpers/esm/writeOnlyError.js\",\n        \"default\": \"./helpers/writeOnlyError.js\"\n      },\n      \"./helpers/writeOnlyError.js\"\n    ],\n    \"./helpers/esm/writeOnlyError\": \"./helpers/esm/writeOnlyError.js\",\n    \"./helpers/classNameTDZError\": [\n      {\n        \"node\": \"./helpers/classNameTDZError.js\",\n        \"import\": \"./helpers/esm/classNameTDZError.js\",\n        \"default\": \"./helpers/classNameTDZError.js\"\n      },\n      \"./helpers/classNameTDZError.js\"\n    ],\n    \"./helpers/esm/classNameTDZError\": \"./helpers/esm/classNameTDZError.js\",\n    \"./helpers/temporalUndefined\": [\n      {\n        \"node\": \"./helpers/temporalUndefined.js\",\n        \"import\": \"./helpers/esm/temporalUndefined.js\",\n        \"default\": \"./helpers/temporalUndefined.js\"\n      },\n      \"./helpers/temporalUndefined.js\"\n    ],\n    \"./helpers/esm/temporalUndefined\": \"./helpers/esm/temporalUndefined.js\",\n    \"./helpers/tdz\": [\n      {\n        \"node\": \"./helpers/tdz.js\",\n        \"import\": \"./helpers/esm/tdz.js\",\n        \"default\": \"./helpers/tdz.js\"\n      },\n      \"./helpers/tdz.js\"\n    ],\n    \"./helpers/esm/tdz\": \"./helpers/esm/tdz.js\",\n    \"./helpers/temporalRef\": [\n      {\n        \"node\": \"./helpers/temporalRef.js\",\n        \"import\": \"./helpers/esm/temporalRef.js\",\n        \"default\": \"./helpers/temporalRef.js\"\n      },\n      \"./helpers/temporalRef.js\"\n    ],\n    \"./helpers/esm/temporalRef\": \"./helpers/esm/temporalRef.js\",\n    \"./helpers/slicedToArray\": [\n      {\n        \"node\": \"./helpers/slicedToArray.js\",\n        \"import\": \"./helpers/esm/slicedToArray.js\",\n        \"default\": \"./helpers/slicedToArray.js\"\n      },\n      \"./helpers/slicedToArray.js\"\n    ],\n    \"./helpers/esm/slicedToArray\": \"./helpers/esm/slicedToArray.js\",\n    \"./helpers/slicedToArrayLoose\": [\n      {\n        \"node\": \"./helpers/slicedToArrayLoose.js\",\n        \"import\": \"./helpers/esm/slicedToArrayLoose.js\",\n        \"default\": \"./helpers/slicedToArrayLoose.js\"\n      },\n      \"./helpers/slicedToArrayLoose.js\"\n    ],\n    \"./helpers/esm/slicedToArrayLoose\": \"./helpers/esm/slicedToArrayLoose.js\",\n    \"./helpers/toArray\": [\n      {\n        \"node\": \"./helpers/toArray.js\",\n        \"import\": \"./helpers/esm/toArray.js\",\n        \"default\": \"./helpers/toArray.js\"\n      },\n      \"./helpers/toArray.js\"\n    ],\n    \"./helpers/esm/toArray\": \"./helpers/esm/toArray.js\",\n    \"./helpers/toConsumableArray\": [\n      {\n        \"node\": \"./helpers/toConsumableArray.js\",\n        \"import\": \"./helpers/esm/toConsumableArray.js\",\n        \"default\": \"./helpers/toConsumableArray.js\"\n      },\n      \"./helpers/toConsumableArray.js\"\n    ],\n    \"./helpers/esm/toConsumableArray\": \"./helpers/esm/toConsumableArray.js\",\n    \"./helpers/arrayWithoutHoles\": [\n      {\n        \"node\": \"./helpers/arrayWithoutHoles.js\",\n        \"import\": \"./helpers/esm/arrayWithoutHoles.js\",\n        \"default\": \"./helpers/arrayWithoutHoles.js\"\n      },\n      \"./helpers/arrayWithoutHoles.js\"\n    ],\n    \"./helpers/esm/arrayWithoutHoles\": \"./helpers/esm/arrayWithoutHoles.js\",\n    \"./helpers/arrayWithHoles\": [\n      {\n        \"node\": \"./helpers/arrayWithHoles.js\",\n        \"import\": \"./helpers/esm/arrayWithHoles.js\",\n        \"default\": \"./helpers/arrayWithHoles.js\"\n      },\n      \"./helpers/arrayWithHoles.js\"\n    ],\n    \"./helpers/esm/arrayWithHoles\": \"./helpers/esm/arrayWithHoles.js\",\n    \"./helpers/maybeArrayLike\": [\n      {\n        \"node\": \"./helpers/maybeArrayLike.js\",\n        \"import\": \"./helpers/esm/maybeArrayLike.js\",\n        \"default\": \"./helpers/maybeArrayLike.js\"\n      },\n      \"./helpers/maybeArrayLike.js\"\n    ],\n    \"./helpers/esm/maybeArrayLike\": \"./helpers/esm/maybeArrayLike.js\",\n    \"./helpers/iterableToArray\": [\n      {\n        \"node\": \"./helpers/iterableToArray.js\",\n        \"import\": \"./helpers/esm/iterableToArray.js\",\n        \"default\": \"./helpers/iterableToArray.js\"\n      },\n      \"./helpers/iterableToArray.js\"\n    ],\n    \"./helpers/esm/iterableToArray\": \"./helpers/esm/iterableToArray.js\",\n    \"./helpers/unsupportedIterableToArray\": [\n      {\n        \"node\": \"./helpers/unsupportedIterableToArray.js\",\n        \"import\": \"./helpers/esm/unsupportedIterableToArray.js\",\n        \"default\": \"./helpers/unsupportedIterableToArray.js\"\n      },\n      \"./helpers/unsupportedIterableToArray.js\"\n    ],\n    \"./helpers/esm/unsupportedIterableToArray\": \"./helpers/esm/unsupportedIterableToArray.js\",\n    \"./helpers/arrayLikeToArray\": [\n      {\n        \"node\": \"./helpers/arrayLikeToArray.js\",\n        \"import\": \"./helpers/esm/arrayLikeToArray.js\",\n        \"default\": \"./helpers/arrayLikeToArray.js\"\n      },\n      \"./helpers/arrayLikeToArray.js\"\n    ],\n    \"./helpers/esm/arrayLikeToArray\": \"./helpers/esm/arrayLikeToArray.js\",\n    \"./helpers/nonIterableSpread\": [\n      {\n        \"node\": \"./helpers/nonIterableSpread.js\",\n        \"import\": \"./helpers/esm/nonIterableSpread.js\",\n        \"default\": \"./helpers/nonIterableSpread.js\"\n      },\n      \"./helpers/nonIterableSpread.js\"\n    ],\n    \"./helpers/esm/nonIterableSpread\": \"./helpers/esm/nonIterableSpread.js\",\n    \"./helpers/nonIterableRest\": [\n      {\n        \"node\": \"./helpers/nonIterableRest.js\",\n        \"import\": \"./helpers/esm/nonIterableRest.js\",\n        \"default\": \"./helpers/nonIterableRest.js\"\n      },\n      \"./helpers/nonIterableRest.js\"\n    ],\n    \"./helpers/esm/nonIterableRest\": \"./helpers/esm/nonIterableRest.js\",\n    \"./helpers/createForOfIteratorHelper\": [\n      {\n        \"node\": \"./helpers/createForOfIteratorHelper.js\",\n        \"import\": \"./helpers/esm/createForOfIteratorHelper.js\",\n        \"default\": \"./helpers/createForOfIteratorHelper.js\"\n      },\n      \"./helpers/createForOfIteratorHelper.js\"\n    ],\n    \"./helpers/esm/createForOfIteratorHelper\": \"./helpers/esm/createForOfIteratorHelper.js\",\n    \"./helpers/createForOfIteratorHelperLoose\": [\n      {\n        \"node\": \"./helpers/createForOfIteratorHelperLoose.js\",\n        \"import\": \"./helpers/esm/createForOfIteratorHelperLoose.js\",\n        \"default\": \"./helpers/createForOfIteratorHelperLoose.js\"\n      },\n      \"./helpers/createForOfIteratorHelperLoose.js\"\n    ],\n    \"./helpers/esm/createForOfIteratorHelperLoose\": \"./helpers/esm/createForOfIteratorHelperLoose.js\",\n    \"./helpers/skipFirstGeneratorNext\": [\n      {\n        \"node\": \"./helpers/skipFirstGeneratorNext.js\",\n        \"import\": \"./helpers/esm/skipFirstGeneratorNext.js\",\n        \"default\": \"./helpers/skipFirstGeneratorNext.js\"\n      },\n      \"./helpers/skipFirstGeneratorNext.js\"\n    ],\n    \"./helpers/esm/skipFirstGeneratorNext\": \"./helpers/esm/skipFirstGeneratorNext.js\",\n    \"./helpers/initializerWarningHelper\": [\n      {\n        \"node\": \"./helpers/initializerWarningHelper.js\",\n        \"import\": \"./helpers/esm/initializerWarningHelper.js\",\n        \"default\": \"./helpers/initializerWarningHelper.js\"\n      },\n      \"./helpers/initializerWarningHelper.js\"\n    ],\n    \"./helpers/esm/initializerWarningHelper\": \"./helpers/esm/initializerWarningHelper.js\",\n    \"./helpers/initializerDefineProperty\": [\n      {\n        \"node\": \"./helpers/initializerDefineProperty.js\",\n        \"import\": \"./helpers/esm/initializerDefineProperty.js\",\n        \"default\": \"./helpers/initializerDefineProperty.js\"\n      },\n      \"./helpers/initializerDefineProperty.js\"\n    ],\n    \"./helpers/esm/initializerDefineProperty\": \"./helpers/esm/initializerDefineProperty.js\",\n    \"./helpers/applyDecoratedDescriptor\": [\n      {\n        \"node\": \"./helpers/applyDecoratedDescriptor.js\",\n        \"import\": \"./helpers/esm/applyDecoratedDescriptor.js\",\n        \"default\": \"./helpers/applyDecoratedDescriptor.js\"\n      },\n      \"./helpers/applyDecoratedDescriptor.js\"\n    ],\n    \"./helpers/esm/applyDecoratedDescriptor\": \"./helpers/esm/applyDecoratedDescriptor.js\",\n    \"./helpers/classPrivateFieldLooseKey\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldLooseKey.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldLooseKey.js\",\n        \"default\": \"./helpers/classPrivateFieldLooseKey.js\"\n      },\n      \"./helpers/classPrivateFieldLooseKey.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldLooseKey\": \"./helpers/esm/classPrivateFieldLooseKey.js\",\n    \"./helpers/classPrivateFieldLooseBase\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldLooseBase.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldLooseBase.js\",\n        \"default\": \"./helpers/classPrivateFieldLooseBase.js\"\n      },\n      \"./helpers/classPrivateFieldLooseBase.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldLooseBase\": \"./helpers/esm/classPrivateFieldLooseBase.js\",\n    \"./helpers/classPrivateFieldGet\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldGet.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldGet.js\",\n        \"default\": \"./helpers/classPrivateFieldGet.js\"\n      },\n      \"./helpers/classPrivateFieldGet.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldGet\": \"./helpers/esm/classPrivateFieldGet.js\",\n    \"./helpers/classPrivateFieldSet\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldSet.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldSet.js\",\n        \"default\": \"./helpers/classPrivateFieldSet.js\"\n      },\n      \"./helpers/classPrivateFieldSet.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldSet\": \"./helpers/esm/classPrivateFieldSet.js\",\n    \"./helpers/classPrivateFieldDestructureSet\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldDestructureSet.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldDestructureSet.js\",\n        \"default\": \"./helpers/classPrivateFieldDestructureSet.js\"\n      },\n      \"./helpers/classPrivateFieldDestructureSet.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldDestructureSet\": \"./helpers/esm/classPrivateFieldDestructureSet.js\",\n    \"./helpers/classExtractFieldDescriptor\": [\n      {\n        \"node\": \"./helpers/classExtractFieldDescriptor.js\",\n        \"import\": \"./helpers/esm/classExtractFieldDescriptor.js\",\n        \"default\": \"./helpers/classExtractFieldDescriptor.js\"\n      },\n      \"./helpers/classExtractFieldDescriptor.js\"\n    ],\n    \"./helpers/esm/classExtractFieldDescriptor\": \"./helpers/esm/classExtractFieldDescriptor.js\",\n    \"./helpers/classStaticPrivateFieldSpecGet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateFieldSpecGet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateFieldSpecGet.js\",\n        \"default\": \"./helpers/classStaticPrivateFieldSpecGet.js\"\n      },\n      \"./helpers/classStaticPrivateFieldSpecGet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateFieldSpecGet\": \"./helpers/esm/classStaticPrivateFieldSpecGet.js\",\n    \"./helpers/classStaticPrivateFieldSpecSet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateFieldSpecSet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateFieldSpecSet.js\",\n        \"default\": \"./helpers/classStaticPrivateFieldSpecSet.js\"\n      },\n      \"./helpers/classStaticPrivateFieldSpecSet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateFieldSpecSet\": \"./helpers/esm/classStaticPrivateFieldSpecSet.js\",\n    \"./helpers/classStaticPrivateMethodGet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateMethodGet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateMethodGet.js\",\n        \"default\": \"./helpers/classStaticPrivateMethodGet.js\"\n      },\n      \"./helpers/classStaticPrivateMethodGet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateMethodGet\": \"./helpers/esm/classStaticPrivateMethodGet.js\",\n    \"./helpers/classStaticPrivateMethodSet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateMethodSet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateMethodSet.js\",\n        \"default\": \"./helpers/classStaticPrivateMethodSet.js\"\n      },\n      \"./helpers/classStaticPrivateMethodSet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateMethodSet\": \"./helpers/esm/classStaticPrivateMethodSet.js\",\n    \"./helpers/classApplyDescriptorGet\": [\n      {\n        \"node\": \"./helpers/classApplyDescriptorGet.js\",\n        \"import\": \"./helpers/esm/classApplyDescriptorGet.js\",\n        \"default\": \"./helpers/classApplyDescriptorGet.js\"\n      },\n      \"./helpers/classApplyDescriptorGet.js\"\n    ],\n    \"./helpers/esm/classApplyDescriptorGet\": \"./helpers/esm/classApplyDescriptorGet.js\",\n    \"./helpers/classApplyDescriptorSet\": [\n      {\n        \"node\": \"./helpers/classApplyDescriptorSet.js\",\n        \"import\": \"./helpers/esm/classApplyDescriptorSet.js\",\n        \"default\": \"./helpers/classApplyDescriptorSet.js\"\n      },\n      \"./helpers/classApplyDescriptorSet.js\"\n    ],\n    \"./helpers/esm/classApplyDescriptorSet\": \"./helpers/esm/classApplyDescriptorSet.js\",\n    \"./helpers/classApplyDescriptorDestructureSet\": [\n      {\n        \"node\": \"./helpers/classApplyDescriptorDestructureSet.js\",\n        \"import\": \"./helpers/esm/classApplyDescriptorDestructureSet.js\",\n        \"default\": \"./helpers/classApplyDescriptorDestructureSet.js\"\n      },\n      \"./helpers/classApplyDescriptorDestructureSet.js\"\n    ],\n    \"./helpers/esm/classApplyDescriptorDestructureSet\": \"./helpers/esm/classApplyDescriptorDestructureSet.js\",\n    \"./helpers/classStaticPrivateFieldDestructureSet\": [\n      {\n        \"node\": \"./helpers/classStaticPrivateFieldDestructureSet.js\",\n        \"import\": \"./helpers/esm/classStaticPrivateFieldDestructureSet.js\",\n        \"default\": \"./helpers/classStaticPrivateFieldDestructureSet.js\"\n      },\n      \"./helpers/classStaticPrivateFieldDestructureSet.js\"\n    ],\n    \"./helpers/esm/classStaticPrivateFieldDestructureSet\": \"./helpers/esm/classStaticPrivateFieldDestructureSet.js\",\n    \"./helpers/classCheckPrivateStaticAccess\": [\n      {\n        \"node\": \"./helpers/classCheckPrivateStaticAccess.js\",\n        \"import\": \"./helpers/esm/classCheckPrivateStaticAccess.js\",\n        \"default\": \"./helpers/classCheckPrivateStaticAccess.js\"\n      },\n      \"./helpers/classCheckPrivateStaticAccess.js\"\n    ],\n    \"./helpers/esm/classCheckPrivateStaticAccess\": \"./helpers/esm/classCheckPrivateStaticAccess.js\",\n    \"./helpers/classCheckPrivateStaticFieldDescriptor\": [\n      {\n        \"node\": \"./helpers/classCheckPrivateStaticFieldDescriptor.js\",\n        \"import\": \"./helpers/esm/classCheckPrivateStaticFieldDescriptor.js\",\n        \"default\": \"./helpers/classCheckPrivateStaticFieldDescriptor.js\"\n      },\n      \"./helpers/classCheckPrivateStaticFieldDescriptor.js\"\n    ],\n    \"./helpers/esm/classCheckPrivateStaticFieldDescriptor\": \"./helpers/esm/classCheckPrivateStaticFieldDescriptor.js\",\n    \"./helpers/decorate\": [\n      {\n        \"node\": \"./helpers/decorate.js\",\n        \"import\": \"./helpers/esm/decorate.js\",\n        \"default\": \"./helpers/decorate.js\"\n      },\n      \"./helpers/decorate.js\"\n    ],\n    \"./helpers/esm/decorate\": \"./helpers/esm/decorate.js\",\n    \"./helpers/classPrivateMethodGet\": [\n      {\n        \"node\": \"./helpers/classPrivateMethodGet.js\",\n        \"import\": \"./helpers/esm/classPrivateMethodGet.js\",\n        \"default\": \"./helpers/classPrivateMethodGet.js\"\n      },\n      \"./helpers/classPrivateMethodGet.js\"\n    ],\n    \"./helpers/esm/classPrivateMethodGet\": \"./helpers/esm/classPrivateMethodGet.js\",\n    \"./helpers/checkPrivateRedeclaration\": [\n      {\n        \"node\": \"./helpers/checkPrivateRedeclaration.js\",\n        \"import\": \"./helpers/esm/checkPrivateRedeclaration.js\",\n        \"default\": \"./helpers/checkPrivateRedeclaration.js\"\n      },\n      \"./helpers/checkPrivateRedeclaration.js\"\n    ],\n    \"./helpers/esm/checkPrivateRedeclaration\": \"./helpers/esm/checkPrivateRedeclaration.js\",\n    \"./helpers/classPrivateFieldInitSpec\": [\n      {\n        \"node\": \"./helpers/classPrivateFieldInitSpec.js\",\n        \"import\": \"./helpers/esm/classPrivateFieldInitSpec.js\",\n        \"default\": \"./helpers/classPrivateFieldInitSpec.js\"\n      },\n      \"./helpers/classPrivateFieldInitSpec.js\"\n    ],\n    \"./helpers/esm/classPrivateFieldInitSpec\": \"./helpers/esm/classPrivateFieldInitSpec.js\",\n    \"./helpers/classPrivateMethodInitSpec\": [\n      {\n        \"node\": \"./helpers/classPrivateMethodInitSpec.js\",\n        \"import\": \"./helpers/esm/classPrivateMethodInitSpec.js\",\n        \"default\": \"./helpers/classPrivateMethodInitSpec.js\"\n      },\n      \"./helpers/classPrivateMethodInitSpec.js\"\n    ],\n    \"./helpers/esm/classPrivateMethodInitSpec\": \"./helpers/esm/classPrivateMethodInitSpec.js\",\n    \"./helpers/classPrivateMethodSet\": [\n      {\n        \"node\": \"./helpers/classPrivateMethodSet.js\",\n        \"import\": \"./helpers/esm/classPrivateMethodSet.js\",\n        \"default\": \"./helpers/classPrivateMethodSet.js\"\n      },\n      \"./helpers/classPrivateMethodSet.js\"\n    ],\n    \"./helpers/esm/classPrivateMethodSet\": \"./helpers/esm/classPrivateMethodSet.js\",\n    \"./helpers/identity\": [\n      {\n        \"node\": \"./helpers/identity.js\",\n        \"import\": \"./helpers/esm/identity.js\",\n        \"default\": \"./helpers/identity.js\"\n      },\n      \"./helpers/identity.js\"\n    ],\n    \"./helpers/esm/identity\": \"./helpers/esm/identity.js\",\n    \"./helpers/nullishReceiverError\": [\n      {\n        \"node\": \"./helpers/nullishReceiverError.js\",\n        \"import\": \"./helpers/esm/nullishReceiverError.js\",\n        \"default\": \"./helpers/nullishReceiverError.js\"\n      },\n      \"./helpers/nullishReceiverError.js\"\n    ],\n    \"./helpers/esm/nullishReceiverError\": \"./helpers/esm/nullishReceiverError.js\",\n    \"./package\": \"./package.json\",\n    \"./package.json\": \"./package.json\",\n    \"./regenerator\": \"./regenerator/index.js\",\n    \"./regenerator/*.js\": \"./regenerator/*.js\",\n    \"./regenerator/\": \"./regenerator/\"\n  },\n  \"homepage\": \"https://babel.dev/docs/en/next/babel-runtime\",\n  \"license\": \"MIT\",\n  \"name\": \"@babel/runtime\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/babel/babel.git\",\n    \"directory\": \"packages/babel-runtime\"\n  },\n  \"type\": \"commonjs\",\n  \"version\": \"7.24.0\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"helpers\":{\"objectSpread2.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/@babel/runtime/helpers/objectSpread2.js                                                                //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"objectWithoutProperties.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/@babel/runtime/helpers/objectWithoutProperties.js                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\",\n    \".mjs\",\n    \".jsx\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/modules/server.js\");\n\n/* Exports */\nPackage._define(\"modules\", exports, {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules.js"}]