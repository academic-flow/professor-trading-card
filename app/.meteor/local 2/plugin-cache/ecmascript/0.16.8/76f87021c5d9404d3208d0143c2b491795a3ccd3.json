{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/alanning:roles/roles/roles_common_async.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/alanning:roles/roles/roles_common_async.js","filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/alanning:roles/roles/roles_common_async.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/phatca/Documents/GitHub/professor-trading-card/app","root":"/Users/phatca/Documents/GitHub/professor-trading-card/app","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/Users/phatca/Documents/GitHub/professor-trading-card/app/packages/alanning:roles/roles/roles_common_async.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/alanning:roles/roles/roles_common_async.js"}},"code":"!function (module1) {\n  let Meteor;\n  module1.link(\"meteor/meteor\", {\n    Meteor(v) {\n      Meteor = v;\n    }\n  }, 0);\n  let Mongo;\n  module1.link(\"meteor/mongo\", {\n    Mongo(v) {\n      Mongo = v;\n    }\n  }, 1);\n  /**\n   * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n   *\n   * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n   *  - `_id`: role name\n   *  - `children`: list of subdocuments:\n   *    - `_id`\n   *\n   * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n   *\n   * Roles can have multiple parents and can be children (subroles) of multiple roles.\n   *\n   * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n   *\n   * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n   * It's documents consist of\n   *  - `_id`: Internal MongoDB id\n   *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n   *  - `user`: A user object, usually only contains the `_id` property\n   *  - `scope`: scope name\n   *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n   *\n   * @module Roles\n   */\n  if (!Meteor.roles) {\n    Meteor.roles = new Mongo.Collection('roles');\n  }\n  if (!Meteor.roleAssignment) {\n    Meteor.roleAssignment = new Mongo.Collection('role-assignment');\n  }\n\n  /**\n   * @class Roles\n   */\n  if (typeof Roles === 'undefined') {\n    Roles = {}; // eslint-disable-line no-global-assign\n  }\n  let getGroupsForUserDeprecationWarning = false;\n\n  /**\n   * Helper, resolves async some\n   * @param {*} arr\n   * @param {*} predicate\n   * @returns {Promise<Boolean>}\n   */\n  const asyncSome = async (arr, predicate) => {\n    for (const e of arr) {\n      if (await predicate(e)) return true;\n    }\n    return false;\n  };\n  Object.assign(Roles, {\n    /**\n     * Used as a global group (now scope) name. Not used anymore.\n     *\n     * @property GLOBAL_GROUP\n     * @static\n     * @deprecated\n     */\n    GLOBAL_GROUP: null,\n    /**\n     * Create a new role.\n     *\n     * @method createRoleAsync\n     * @param {String} roleName Name of role.\n     * @param {Object} [options] Options:\n     *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n     * @return {Promise<String>} ID of the new role or null.\n     * @static\n     */\n    createRoleAsync: async function (roleName, options) {\n      Roles._checkRoleName(roleName);\n      options = Object.assign({\n        unlessExists: false\n      }, options);\n      let insertedId = null;\n      const existingRole = await Meteor.roles.findOneAsync({\n        _id: roleName\n      });\n      if (existingRole) {\n        await Meteor.roles.updateAsync({\n          _id: roleName\n        }, {\n          $setOnInsert: {\n            children: []\n          }\n        });\n        return null;\n      } else {\n        insertedId = await Meteor.roles.insertAsync({\n          _id: roleName,\n          children: []\n        });\n      }\n      if (!insertedId) {\n        if (options.unlessExists) return null;\n        throw new Error(\"Role '\" + roleName + \"' already exists.\");\n      }\n      return insertedId;\n    },\n    /**\n     * Delete an existing role.\n     *\n     * If the role is set for any user, it is automatically unset.\n     *\n     * @method deleteRoleAsync\n     * @param {String} roleName Name of role.\n     * @returns {Promise}\n     * @static\n     */\n    deleteRoleAsync: async function (roleName) {\n      let roles;\n      let inheritedRoles;\n      Roles._checkRoleName(roleName);\n\n      // Remove all assignments\n      await Meteor.roleAssignment.removeAsync({\n        'role._id': roleName\n      });\n      do {\n        // For all roles who have it as a dependency ...\n        roles = Roles._getParentRoleNames(await Meteor.roles.findOneAsync({\n          _id: roleName\n        }));\n        for (const r of await Meteor.roles.find({\n          _id: {\n            $in: roles\n          }\n        }).fetchAsync()) {\n          await Meteor.roles.updateAsync({\n            _id: r._id\n          }, {\n            $pull: {\n              children: {\n                _id: roleName\n              }\n            }\n          });\n          inheritedRoles = await Roles._getInheritedRoleNamesAsync(await Meteor.roles.findOneAsync({\n            _id: r._id\n          }));\n          await Meteor.roleAssignment.updateAsync({\n            'role._id': r._id\n          }, {\n            $set: {\n              inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({\n                _id: r2\n              }))\n            }\n          }, {\n            multi: true\n          });\n        }\n      } while (roles.length > 0);\n\n      // And finally remove the role itself\n      await Meteor.roles.removeAsync({\n        _id: roleName\n      });\n    },\n    /**\n     * Rename an existing role.\n     *\n     * @method renameRoleAsync\n     * @param {String} oldName Old name of a role.\n     * @param {String} newName New name of a role.\n     * @returns {Promise}\n     * @static\n     */\n    renameRoleAsync: async function (oldName, newName) {\n      let count;\n      Roles._checkRoleName(oldName);\n      Roles._checkRoleName(newName);\n      if (oldName === newName) return;\n      const role = await Meteor.roles.findOneAsync({\n        _id: oldName\n      });\n      if (!role) {\n        throw new Error(\"Role '\" + oldName + \"' does not exist.\");\n      }\n      role._id = newName;\n      await Meteor.roles.insertAsync(role);\n      do {\n        count = await Meteor.roleAssignment.updateAsync({\n          'role._id': oldName\n        }, {\n          $set: {\n            'role._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      do {\n        count = await Meteor.roleAssignment.updateAsync({\n          'inheritedRoles._id': oldName\n        }, {\n          $set: {\n            'inheritedRoles.$._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      do {\n        count = await Meteor.roles.updateAsync({\n          'children._id': oldName\n        }, {\n          $set: {\n            'children.$._id': newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n      await Meteor.roles.removeAsync({\n        _id: oldName\n      });\n    },\n    /**\n     * Add role parent to roles.\n     *\n     * Previous parents are kept (role can have multiple parents). For users which have the\n     * parent role set, new subroles are added automatically.\n     *\n     * @method addRolesToParentAsync\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @static\n     */\n    addRolesToParentAsync: async function (rolesNames, parentName) {\n      // ensure arrays\n      if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n      for (const roleName of rolesNames) {\n        await Roles._addRoleToParentAsync(roleName, parentName);\n      }\n    },\n    /**\n     * @method _addRoleToParentAsync\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _addRoleToParentAsync: async function (roleName, parentName) {\n      Roles._checkRoleName(roleName);\n      Roles._checkRoleName(parentName);\n\n      // query to get role's children\n      const role = await Meteor.roles.findOneAsync({\n        _id: roleName\n      });\n      if (!role) {\n        throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n      }\n\n      // detect cycles\n      if ((await Roles._getInheritedRoleNamesAsync(role)).includes(parentName)) {\n        throw new Error(\"Roles '\" + roleName + \"' and '\" + parentName + \"' would form a cycle.\");\n      }\n      const count = await Meteor.roles.updateAsync({\n        _id: parentName,\n        'children._id': {\n          $ne: role._id\n        }\n      }, {\n        $push: {\n          children: {\n            _id: role._id\n          }\n        }\n      });\n\n      // if there was no change, parent role might not exist, or role is\n      // already a sub-role; in any case we do not have anything more to do\n      if (!count) return;\n      await Meteor.roleAssignment.updateAsync({\n        'inheritedRoles._id': parentName\n      }, {\n        $push: {\n          inheritedRoles: {\n            $each: [role._id, ...(await Roles._getInheritedRoleNamesAsync(role))].map(r => ({\n              _id: r\n            }))\n          }\n        }\n      }, {\n        multi: true\n      });\n    },\n    /**\n     * Remove role parent from roles.\n     *\n     * Other parents are kept (role can have multiple parents). For users which have the\n     * parent role set, removed subrole is removed automatically.\n     *\n     * @method removeRolesFromParentAsync\n     * @param {Array|String} rolesNames Name(s) of role(s).\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @static\n     */\n    removeRolesFromParentAsync: async function (rolesNames, parentName) {\n      // ensure arrays\n      if (!Array.isArray(rolesNames)) rolesNames = [rolesNames];\n      for (const roleName of rolesNames) {\n        await Roles._removeRoleFromParentAsync(roleName, parentName);\n      }\n    },\n    /**\n     * @method _removeRoleFromParentAsync\n     * @param {String} roleName Name of role.\n     * @param {String} parentName Name of parent role.\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _removeRoleFromParentAsync: async function (roleName, parentName) {\n      Roles._checkRoleName(roleName);\n      Roles._checkRoleName(parentName);\n\n      // check for role existence\n      // this would not really be needed, but we are trying to match addRolesToParent\n      const role = await Meteor.roles.findOneAsync({\n        _id: roleName\n      }, {\n        fields: {\n          _id: 1\n        }\n      });\n      if (!role) {\n        throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n      }\n      const count = await Meteor.roles.updateAsync({\n        _id: parentName\n      }, {\n        $pull: {\n          children: {\n            _id: role._id\n          }\n        }\n      });\n\n      // if there was no change, parent role might not exist, or role was\n      // already not a subrole; in any case we do not have anything more to do\n      if (!count) return;\n\n      // For all roles who have had it as a dependency ...\n      const roles = [...(await Roles._getParentRoleNamesAsync(await Meteor.roles.findOneAsync({\n        _id: parentName\n      }))), parentName];\n      for (const r of await Meteor.roles.find({\n        _id: {\n          $in: roles\n        }\n      }).fetchAsync()) {\n        const inheritedRoles = await Roles._getInheritedRoleNamesAsync(await Meteor.roles.findOneAsync({\n          _id: r._id\n        }));\n        await Meteor.roleAssignment.updateAsync({\n          'role._id': r._id,\n          'inheritedRoles._id': role._id\n        }, {\n          $set: {\n            inheritedRoles: [r._id, ...inheritedRoles].map(r2 => ({\n              _id: r2\n            }))\n          }\n        }, {\n          multi: true\n        });\n      }\n    },\n    /**\n     * Add users to roles.\n     *\n     * Adds roles to existing roles for each user.\n     *\n     * @example\n     *     Roles.addUsersToRolesAsync(userId, 'admin')\n     *     Roles.addUsersToRolesAsync(userId, ['view-secrets'], 'example.com')\n     *     Roles.addUsersToRolesAsync([user1, user2], ['user','editor'])\n     *     Roles.addUsersToRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method addUsersToRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    addUsersToRolesAsync: async function (users, roles, options) {\n      let id;\n      if (!users) throw new Error(\"Missing 'users' param.\");\n      if (!roles) throw new Error(\"Missing 'roles' param.\");\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        ifExists: false\n      }, options);\n      for (const user of users) {\n        if (typeof user === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        for (const role of roles) {\n          await Roles._addUserToRoleAsync(id, role, options);\n        }\n      }\n    },\n    /**\n     * Set users' roles.\n     *\n     * Replaces all existing roles with a new set of roles.\n     *\n     * @example\n     *     await Roles.setUserRolesAsync(userId, 'admin')\n     *     await Roles.setUserRolesAsync(userId, ['view-secrets'], 'example.com')\n     *     await Roles.setUserRolesAsync([user1, user2], ['user','editor'])\n     *     await Roles.setUserRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n     *\n     * @method setUserRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    setUserRolesAsync: async function (users, roles, options) {\n      let id;\n      if (!users) throw new Error(\"Missing 'users' param.\");\n      if (!roles) throw new Error(\"Missing 'roles' param.\");\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        ifExists: false,\n        anyScope: false\n      }, options);\n      for (const user of users) {\n        if (typeof user === 'object') {\n          id = user._id;\n        } else {\n          id = user;\n        }\n        // we first clear all roles for the user\n        const selector = {\n          'user._id': id\n        };\n        if (!options.anyScope) {\n          selector.scope = options.scope;\n        }\n        await Meteor.roleAssignment.removeAsync(selector);\n\n        // and then add all\n        for (const role of roles) {\n          await Roles._addUserToRole(id, role, options);\n        }\n      }\n    },\n    /**\n     * Add one user to one role.\n     *\n     * @method _addUserToRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _addUserToRoleAsync: async function (userId, roleName, options) {\n      Roles._checkRoleName(roleName);\n      Roles._checkScopeName(options.scope);\n      if (!userId) {\n        return;\n      }\n      const role = await Meteor.roles.findOneAsync({\n        _id: roleName\n      }, {\n        fields: {\n          children: 1\n        }\n      });\n      if (!role) {\n        if (options.ifExists) {\n          return [];\n        } else {\n          throw new Error(\"Role '\" + roleName + \"' does not exist.\");\n        }\n      }\n\n      // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n      // TODO revisit this\n      /* const res = await Meteor.roleAssignment.upsertAsync(\n        {\n          \"user._id\": userId,\n          \"role._id\": roleName,\n          scope: options.scope,\n        },\n        {\n          $setOnInsert: {\n            user: { _id: userId },\n            role: { _id: roleName },\n            scope: options.scope,\n          },\n        }\n      ); */\n      const existingAssignment = await Meteor.roleAssignment.findOneAsync({\n        'user._id': userId,\n        'role._id': roleName,\n        scope: options.scope\n      });\n      let insertedId;\n      let res;\n      if (existingAssignment) {\n        await Meteor.roleAssignment.updateAsync(existingAssignment._id, {\n          $set: {\n            user: {\n              _id: userId\n            },\n            role: {\n              _id: roleName\n            },\n            scope: options.scope\n          }\n        });\n        res = await Meteor.roleAssignment.findOneAsync(existingAssignment._id);\n      } else {\n        insertedId = await Meteor.roleAssignment.insertAsync({\n          user: {\n            _id: userId\n          },\n          role: {\n            _id: roleName\n          },\n          scope: options.scope\n        });\n      }\n      if (insertedId) {\n        await Meteor.roleAssignment.updateAsync({\n          _id: insertedId\n        }, {\n          $set: {\n            inheritedRoles: [roleName, ...(await Roles._getInheritedRoleNamesAsync(role))].map(r => ({\n              _id: r\n            }))\n          }\n        });\n        res = await Meteor.roleAssignment.findOneAsync({\n          _id: insertedId\n        });\n      }\n      res.insertedId = insertedId; // For backward compatibility\n\n      return res;\n    },\n    /**\n     * Returns an array of role names the given role name is a child of.\n     *\n     * @example\n     *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getParentRoleNames\n     * @param {object} role The role object\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _getParentRoleNamesAsync: async function (role) {\n      if (!role) {\n        return [];\n      }\n      const parentRoles = new Set([role._id]);\n      for (const roleName of parentRoles) {\n        for (const parentRole of await Meteor.roles.find({\n          'children._id': roleName\n        }).fetchAsync()) {\n          parentRoles.add(parentRole._id);\n        }\n      }\n      parentRoles.delete(role._id);\n      return [...parentRoles];\n    },\n    /**\n     * Returns an array of role names the given role name is a parent of.\n     *\n     * @example\n     *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n     *\n     * @method _getInheritedRoleNames\n     * @param {object} role The role object\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _getInheritedRoleNamesAsync: async function (role) {\n      const inheritedRoles = new Set();\n      const nestedRoles = new Set([role]);\n      for (const r of nestedRoles) {\n        const roles = await Meteor.roles.find({\n          _id: {\n            $in: r.children.map(r => r._id)\n          }\n        }, {\n          fields: {\n            children: 1\n          }\n        }).fetchAsync();\n        for (const r2 of roles) {\n          inheritedRoles.add(r2._id);\n          nestedRoles.add(r2);\n        }\n      }\n      return [...inheritedRoles];\n    },\n    /**\n     * Remove users from assigned roles.\n     *\n     * @example\n     *     await Roles.removeUsersFromRolesAsync(userId, 'admin')\n     *     await Roles.removeUsersFromRolesAsync([userId, user2], ['editor'])\n     *     await Roles.removeUsersFromRolesAsync(userId, ['user'], 'group1')\n     *\n     * @method removeUsersFromRolesAsync\n     * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n     * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @returns {Promise}\n     *\n     * Alternatively, it can be a scope name string.\n     * @static\n     */\n    removeUsersFromRolesAsync: async function (users, roles, options) {\n      if (!users) throw new Error(\"Missing 'users' param.\");\n      if (!roles) throw new Error(\"Missing 'roles' param.\");\n      options = Roles._normalizeOptions(options);\n\n      // ensure arrays\n      if (!Array.isArray(users)) users = [users];\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      for (const user of users) {\n        if (!user) return;\n        for (const role of roles) {\n          let id;\n          if (typeof user === 'object') {\n            id = user._id;\n          } else {\n            id = user;\n          }\n          await Roles._removeUserFromRoleAsync(id, role, options);\n        }\n      }\n    },\n    /**\n     * Remove one user from one role.\n     *\n     * @method _removeUserFromRole\n     * @param {String} userId The user ID.\n     * @param {String} roleName Name of the role to add the user to. The role have to exist.\n     * @param {Object} options Options:\n     *   - `scope`: name of the scope, or `null` for the global role\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     * @returns {Promise}\n     * @private\n     * @static\n     */\n    _removeUserFromRoleAsync: async function (userId, roleName, options) {\n      Roles._checkRoleName(roleName);\n      Roles._checkScopeName(options.scope);\n      if (!userId) return;\n      const selector = {\n        'user._id': userId,\n        'role._id': roleName\n      };\n      if (!options.anyScope) {\n        selector.scope = options.scope;\n      }\n      await Meteor.roleAssignment.removeAsync(selector);\n    },\n    /**\n     * Check if user has specified roles.\n     *\n     * @example\n     *     // global roles\n     *     await Roles.userIsInRoleAsync(user, 'admin')\n     *     await Roles.userIsInRoleAsync(user, ['admin','editor'])\n     *     await Roles.userIsInRoleAsync(userId, 'admin')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'])\n     *\n     *     // scope roles (global roles are still checked)\n     *     await Roles.userIsInRoleAsync(user, 'admin', 'group1')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], 'group1')\n     *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], {scope: 'group1'})\n     *\n     * @method userIsInRoleAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n     *                             will return `true` if user is in _any_ role.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope; if supplied, limits check to just that scope\n     *     the user's global roles will always be checked whether scope is specified or not\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Promise<Boolean>} `true` if user is in _any_ of the target roles\n     * @static\n     */\n    userIsInRoleAsync: async function (user, roles, options) {\n      let id;\n      options = Roles._normalizeOptions(options);\n\n      // ensure array to simplify code\n      if (!Array.isArray(roles)) roles = [roles];\n      roles = roles.filter(r => r != null);\n      if (!roles.length) return false;\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        anyScope: false\n      }, options);\n      if (user && typeof user === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return false;\n      if (typeof id !== 'string') return false;\n      const selector = {\n        'user._id': id\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope, null]\n        };\n      }\n      const res = await asyncSome(roles, async roleName => {\n        selector['inheritedRoles._id'] = roleName;\n        const out = (await Meteor.roleAssignment.find(selector, {\n          limit: 1\n        }).countAsync()) > 0;\n        return out;\n      });\n      return res;\n    },\n    /**\n     * Retrieve user's roles.\n     *\n     * @method getRolesForUserAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n     *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n     *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n     *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n     *     result strongly dependent on the internal data structure of this plugin.\n     *\n     * Alternatively, it can be a scope name string.\n     * @return {Promise<Array>} Array of user's roles, unsorted.\n     * @static\n     */\n    getRolesForUserAsync: async function (user, options) {\n      let id;\n      options = Roles._normalizeOptions(options);\n      Roles._checkScopeName(options.scope);\n      options = Object.assign({\n        fullObjects: false,\n        onlyAssigned: false,\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n      if (user && typeof user === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return [];\n      const selector = {\n        'user._id': id\n      };\n      const filter = {\n        fields: {\n          'inheritedRoles._id': 1\n        }\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n      if (options.onlyAssigned) {\n        delete filter.fields['inheritedRoles._id'];\n        filter.fields['role._id'] = 1;\n      }\n      if (options.fullObjects) {\n        delete filter.fields;\n      }\n      const roles = await Meteor.roleAssignment.find(selector, filter).fetchAsync();\n      if (options.fullObjects) {\n        return roles;\n      }\n      return [...new Set(roles.reduce((rev, current) => {\n        if (current.inheritedRoles) {\n          return rev.concat(current.inheritedRoles.map(r => r._id));\n        } else if (current.role) {\n          rev.push(current.role._id);\n        }\n        return rev;\n      }, []))];\n    },\n    /**\n     * Retrieve cursor of all existing roles.\n     *\n     * @method getAllRoles\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.roles.find(query, options)`.\n     * @return {Cursor} Cursor of existing roles.\n     * @static\n     */\n    getAllRoles: function (queryOptions) {\n      queryOptions = queryOptions || {\n        sort: {\n          _id: 1\n        }\n      };\n      return Meteor.roles.find({}, queryOptions);\n    },\n    /**\n     * Retrieve all users who are in target role.\n     *\n     * Options:\n     *\n     * @method getUsersInRoleAsync\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `onlyScoped`: if set, only roles in the specified scope are returned\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.users.find(query, options)`\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [queryOptions] Options which are passed directly\n     *                                through to `Meteor.users.find(query, options)`\n     * @return {Promise<Cursor>} Cursor of users in roles.\n     * @static\n     */\n    getUsersInRoleAsync: async function (roles, options, queryOptions) {\n      const ids = (await Roles.getUserAssignmentsForRole(roles, options).fetchAsync()).map(a => a.user._id);\n      return Meteor.users.find({\n        _id: {\n          $in: ids\n        }\n      }, options && options.queryOptions || queryOptions || {});\n    },\n    /**\n     * Retrieve all assignments of a user which are for the target role.\n     *\n     * Options:\n     *\n     * @method getUserAssignmentsForRole\n     * @param {Array|String} roles Name of role or an array of roles. If array, users\n     *                             returned will have at least one of the roles\n     *                             specified but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *   - `queryOptions`: options which are passed directly\n     *     through to `Meteor.roleAssignment.find(query, options)`\n      * Alternatively, it can be a scope name string.\n     * @return {Cursor} Cursor of user assignments for roles.\n     * @static\n     */\n    getUserAssignmentsForRole: function (roles, options) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        queryOptions: {}\n      }, options);\n      return Roles._getUsersInRoleCursor(roles, options, options.queryOptions);\n    },\n    /**\n     * @method _getUsersInRoleCursor\n     * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n     *                             returned which have at least one of the roles\n     *                             assigned but need not have _all_ roles.\n     *                             Roles do not have to exist.\n     * @param {Object|String} [options] Options:\n     *   - `scope`: name of the scope to restrict roles to; user's global\n     *     roles will also be checked\n     *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n     *\n     * Alternatively, it can be a scope name string.\n     * @param {Object} [filter] Options which are passed directly\n     *                                through to `Meteor.roleAssignment.find(query, options)`\n     * @return {Object} Cursor to the assignment documents\n     * @private\n     * @static\n     */\n    _getUsersInRoleCursor: function (roles, options, filter) {\n      options = Roles._normalizeOptions(options);\n      options = Object.assign({\n        anyScope: false,\n        onlyScoped: false\n      }, options);\n\n      // ensure array to simplify code\n      if (!Array.isArray(roles)) roles = [roles];\n      Roles._checkScopeName(options.scope);\n      filter = Object.assign({\n        fields: {\n          'user._id': 1\n        }\n      }, filter);\n      const selector = {\n        'inheritedRoles._id': {\n          $in: roles\n        }\n      };\n      if (!options.anyScope) {\n        selector.scope = {\n          $in: [options.scope]\n        };\n        if (!options.onlyScoped) {\n          selector.scope.$in.push(null);\n        }\n      }\n      return Meteor.roleAssignment.find(selector, filter);\n    },\n    /**\n     * Deprecated. Use `getScopesForUser` instead.\n     *\n     * @method getGroupsForUserAsync\n     * @returns {Promise<Array>}\n     * @static\n     * @deprecated\n     */\n    getGroupsForUserAsync: async function () {\n      if (!getGroupsForUserDeprecationWarning) {\n        getGroupsForUserDeprecationWarning = true;\n        console && console.warn('getGroupsForUser has been deprecated. Use getScopesForUser instead.');\n      }\n      return await Roles.getScopesForUser(...arguments);\n    },\n    /**\n     * Retrieve users scopes, if any.\n     *\n     * @method getScopesForUserAsync\n     * @param {String|Object} user User ID or an actual user object.\n     * @param {Array|String} [roles] Name of roles to restrict scopes to.\n     *\n     * @return {Promise<Array>} Array of user's scopes, unsorted.\n     * @static\n     */\n    getScopesForUserAsync: async function (user, roles) {\n      let id;\n      if (roles && !Array.isArray(roles)) roles = [roles];\n      if (user && typeof user === 'object') {\n        id = user._id;\n      } else {\n        id = user;\n      }\n      if (!id) return [];\n      const selector = {\n        'user._id': id,\n        scope: {\n          $ne: null\n        }\n      };\n      if (roles) {\n        selector['inheritedRoles._id'] = {\n          $in: roles\n        };\n      }\n      const scopes = (await Meteor.roleAssignment.find(selector, {\n        fields: {\n          scope: 1\n        }\n      }).fetchAsync()).map(obi => obi.scope);\n      return [...new Set(scopes)];\n    },\n    /**\n     * Rename a scope.\n     *\n     * Roles assigned with a given scope are changed to be under the new scope.\n     *\n     * @method renameScopeAsync\n     * @param {String} oldName Old name of a scope.\n     * @param {String} newName New name of a scope.\n     * @returns {Promise}\n     * @static\n     */\n    renameScopeAsync: async function (oldName, newName) {\n      let count;\n      Roles._checkScopeName(oldName);\n      Roles._checkScopeName(newName);\n      if (oldName === newName) return;\n      do {\n        count = await Meteor.roleAssignment.updateAsync({\n          scope: oldName\n        }, {\n          $set: {\n            scope: newName\n          }\n        }, {\n          multi: true\n        });\n      } while (count > 0);\n    },\n    /**\n     * Remove a scope.\n     *\n     * Roles assigned with a given scope are removed.\n     *\n     * @method removeScopeAsync\n     * @param {String} name The name of a scope.\n     * @returns {Promise}\n     * @static\n     */\n    removeScopeAsync: async function (name) {\n      Roles._checkScopeName(name);\n      await Meteor.roleAssignment.removeAsync({\n        scope: name\n      });\n    },\n    /**\n     * Throw an exception if `roleName` is an invalid role name.\n     *\n     * @method _checkRoleName\n     * @param {String} roleName A role name to match against.\n     * @private\n     * @static\n     */\n    _checkRoleName: function (roleName) {\n      if (!roleName || typeof roleName !== 'string' || roleName.trim() !== roleName) {\n        throw new Error(\"Invalid role name '\" + roleName + \"'.\");\n      }\n    },\n    /**\n     * Find out if a role is an ancestor of another role.\n     *\n     * WARNING: If you check this on the client, please make sure all roles are published.\n     *\n     * @method isParentOfAsync\n     * @param {String} parentRoleName The role you want to research.\n     * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n     * @returns {Promise}\n     * @static\n     */\n    isParentOfAsync: async function (parentRoleName, childRoleName) {\n      if (parentRoleName === childRoleName) {\n        return true;\n      }\n      if (parentRoleName == null || childRoleName == null) {\n        return false;\n      }\n      Roles._checkRoleName(parentRoleName);\n      Roles._checkRoleName(childRoleName);\n      let rolesToCheck = [parentRoleName];\n      while (rolesToCheck.length !== 0) {\n        const roleName = rolesToCheck.pop();\n        if (roleName === childRoleName) {\n          return true;\n        }\n        const role = await Meteor.roles.findOneAsync({\n          _id: roleName\n        });\n\n        // This should not happen, but this is a problem to address at some other time.\n        if (!role) continue;\n        rolesToCheck = rolesToCheck.concat(role.children.map(r => r._id));\n      }\n      return false;\n    },\n    /**\n     * Normalize options.\n     *\n     * @method _normalizeOptions\n     * @param {Object} options Options to normalize.\n     * @return {Object} Normalized options.\n     * @private\n     * @static\n     */\n    _normalizeOptions: function (options) {\n      options = options === undefined ? {} : options;\n      if (options === null || typeof options === 'string') {\n        options = {\n          scope: options\n        };\n      }\n      options.scope = Roles._normalizeScopeName(options.scope);\n      return options;\n    },\n    /**\n     * Normalize scope name.\n     *\n     * @method _normalizeScopeName\n     * @param {String} scopeName A scope name to normalize.\n     * @return {String} Normalized scope name.\n     * @private\n     * @static\n     */\n    _normalizeScopeName: function (scopeName) {\n      // map undefined and null to null\n      if (scopeName == null) {\n        return null;\n      } else {\n        return scopeName;\n      }\n    },\n    /**\n     * Throw an exception if `scopeName` is an invalid scope name.\n     *\n     * @method _checkRoleName\n     * @param {String} scopeName A scope name to match against.\n     * @private\n     * @static\n     */\n    _checkScopeName: function (scopeName) {\n      if (scopeName === null) return;\n      if (!scopeName || typeof scopeName !== 'string' || scopeName.trim() !== scopeName) {\n        throw new Error(\"Invalid scope name '\" + scopeName + \"'.\");\n      }\n    }\n  });\n}.call(this, module);","map":{"version":3,"names":["Meteor","module1","link","v","Mongo","roles","Collection","roleAssignment","Roles","getGroupsForUserDeprecationWarning","asyncSome","arr","predicate","e","Object","assign","GLOBAL_GROUP","createRoleAsync","roleName","options","_checkRoleName","unlessExists","insertedId","existingRole","findOneAsync","_id","updateAsync","$setOnInsert","children","insertAsync","Error","deleteRoleAsync","inheritedRoles","removeAsync","_getParentRoleNames","r","find","$in","fetchAsync","$pull","_getInheritedRoleNamesAsync","$set","map","r2","multi","length","renameRoleAsync","oldName","newName","count","role","addRolesToParentAsync","rolesNames","parentName","Array","isArray","_addRoleToParentAsync","includes","$ne","$push","$each","removeRolesFromParentAsync","_removeRoleFromParentAsync","fields","_getParentRoleNamesAsync","addUsersToRolesAsync","users","id","_normalizeOptions","_checkScopeName","scope","ifExists","user","_addUserToRoleAsync","setUserRolesAsync","anyScope","selector","_addUserToRole","userId","existingAssignment","res","parentRoles","Set","parentRole","add","delete","nestedRoles","removeUsersFromRolesAsync","_removeUserFromRoleAsync","userIsInRoleAsync","filter","out","limit","countAsync","getRolesForUserAsync","fullObjects","onlyAssigned","onlyScoped","push","reduce","rev","current","concat","getAllRoles","queryOptions","sort","getUsersInRoleAsync","ids","getUserAssignmentsForRole","a","_getUsersInRoleCursor","getGroupsForUserAsync","console","warn","getScopesForUser","arguments","getScopesForUserAsync","scopes","obi","renameScopeAsync","removeScopeAsync","name","trim","isParentOfAsync","parentRoleName","childRoleName","rolesToCheck","pop","undefined","_normalizeScopeName","scopeName","call","module"],"sources":["packages/alanning:roles/roles/roles_common_async.js"],"sourcesContent":["/* global Roles */\nimport { Meteor } from 'meteor/meteor'\nimport { Mongo } from 'meteor/mongo'\n\n/**\n * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n *\n * Roles are accessible throgh `Meteor.roles` collection and documents consist of:\n *  - `_id`: role name\n *  - `children`: list of subdocuments:\n *    - `_id`\n *\n * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.\n *\n * Roles can have multiple parents and can be children (subroles) of multiple roles.\n *\n * Example: `{_id: 'admin', children: [{_id: 'editor'}]}`\n *\n * The assignment of a role to a user is stored in a collection, accessible through `Meteor.roleAssignment`.\n * It's documents consist of\n *  - `_id`: Internal MongoDB id\n *  - `role`: A role object which got assigned. Usually only contains the `_id` property\n *  - `user`: A user object, usually only contains the `_id` property\n *  - `scope`: scope name\n *  - `inheritedRoles`: A list of all the roles objects inherited by the assigned role.\n *\n * @module Roles\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Mongo.Collection('roles')\n}\n\nif (!Meteor.roleAssignment) {\n  Meteor.roleAssignment = new Mongo.Collection('role-assignment')\n}\n\n/**\n * @class Roles\n */\nif (typeof Roles === 'undefined') {\n  Roles = {} // eslint-disable-line no-global-assign\n}\n\nlet getGroupsForUserDeprecationWarning = false\n\n/**\n * Helper, resolves async some\n * @param {*} arr\n * @param {*} predicate\n * @returns {Promise<Boolean>}\n */\nconst asyncSome = async (arr, predicate) => {\n  for (const e of arr) {\n    if (await predicate(e)) return true\n  }\n  return false\n}\n\nObject.assign(Roles, {\n  /**\n   * Used as a global group (now scope) name. Not used anymore.\n   *\n   * @property GLOBAL_GROUP\n   * @static\n   * @deprecated\n   */\n  GLOBAL_GROUP: null,\n\n  /**\n   * Create a new role.\n   *\n   * @method createRoleAsync\n   * @param {String} roleName Name of role.\n   * @param {Object} [options] Options:\n   *   - `unlessExists`: if `true`, exception will not be thrown in the role already exists\n   * @return {Promise<String>} ID of the new role or null.\n   * @static\n   */\n  createRoleAsync: async function (roleName, options) {\n    Roles._checkRoleName(roleName)\n\n    options = Object.assign(\n      {\n        unlessExists: false\n      },\n      options\n    )\n\n    let insertedId = null\n\n    const existingRole = await Meteor.roles.findOneAsync({ _id: roleName })\n\n    if (existingRole) {\n      await Meteor.roles.updateAsync(\n        { _id: roleName },\n        { $setOnInsert: { children: [] } }\n      )\n      return null\n    } else {\n      insertedId = await Meteor.roles.insertAsync({\n        _id: roleName,\n        children: []\n      })\n    }\n\n    if (!insertedId) {\n      if (options.unlessExists) return null\n      throw new Error(\"Role '\" + roleName + \"' already exists.\")\n    }\n\n    return insertedId\n  },\n\n  /**\n   * Delete an existing role.\n   *\n   * If the role is set for any user, it is automatically unset.\n   *\n   * @method deleteRoleAsync\n   * @param {String} roleName Name of role.\n   * @returns {Promise}\n   * @static\n   */\n  deleteRoleAsync: async function (roleName) {\n    let roles\n    let inheritedRoles\n\n    Roles._checkRoleName(roleName)\n\n    // Remove all assignments\n    await Meteor.roleAssignment.removeAsync({\n      'role._id': roleName\n    })\n\n    do {\n      // For all roles who have it as a dependency ...\n      roles = Roles._getParentRoleNames(\n        await Meteor.roles.findOneAsync({ _id: roleName })\n      )\n\n      for (const r of await Meteor.roles\n        .find({ _id: { $in: roles } })\n        .fetchAsync()) {\n        await Meteor.roles.updateAsync(\n          {\n            _id: r._id\n          },\n          {\n            $pull: {\n              children: {\n                _id: roleName\n              }\n            }\n          }\n        )\n\n        inheritedRoles = await Roles._getInheritedRoleNamesAsync(\n          await Meteor.roles.findOneAsync({ _id: r._id })\n        )\n        await Meteor.roleAssignment.updateAsync(\n          {\n            'role._id': r._id\n          },\n          {\n            $set: {\n              inheritedRoles: [r._id, ...inheritedRoles].map((r2) => ({\n                _id: r2\n              }))\n            }\n          },\n          { multi: true }\n        )\n      }\n    } while (roles.length > 0)\n\n    // And finally remove the role itself\n    await Meteor.roles.removeAsync({ _id: roleName })\n  },\n\n  /**\n   * Rename an existing role.\n   *\n   * @method renameRoleAsync\n   * @param {String} oldName Old name of a role.\n   * @param {String} newName New name of a role.\n   * @returns {Promise}\n   * @static\n   */\n  renameRoleAsync: async function (oldName, newName) {\n    let count\n\n    Roles._checkRoleName(oldName)\n    Roles._checkRoleName(newName)\n\n    if (oldName === newName) return\n\n    const role = await Meteor.roles.findOneAsync({ _id: oldName })\n\n    if (!role) {\n      throw new Error(\"Role '\" + oldName + \"' does not exist.\")\n    }\n\n    role._id = newName\n\n    await Meteor.roles.insertAsync(role)\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          'role._id': oldName\n        },\n        {\n          $set: {\n            'role._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          'inheritedRoles._id': oldName\n        },\n        {\n          $set: {\n            'inheritedRoles.$._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    do {\n      count = await Meteor.roles.updateAsync(\n        {\n          'children._id': oldName\n        },\n        {\n          $set: {\n            'children.$._id': newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n\n    await Meteor.roles.removeAsync({ _id: oldName })\n  },\n\n  /**\n   * Add role parent to roles.\n   *\n   * Previous parents are kept (role can have multiple parents). For users which have the\n   * parent role set, new subroles are added automatically.\n   *\n   * @method addRolesToParentAsync\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @static\n   */\n  addRolesToParentAsync: async function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    for (const roleName of rolesNames) {\n      await Roles._addRoleToParentAsync(roleName, parentName)\n    }\n  },\n\n  /**\n   * @method _addRoleToParentAsync\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _addRoleToParentAsync: async function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // query to get role's children\n    const role = await Meteor.roles.findOneAsync({ _id: roleName })\n\n    if (!role) {\n      throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n    }\n\n    // detect cycles\n    if ((await Roles._getInheritedRoleNamesAsync(role)).includes(parentName)) {\n      throw new Error(\n        \"Roles '\" + roleName + \"' and '\" + parentName + \"' would form a cycle.\"\n      )\n    }\n\n    const count = await Meteor.roles.updateAsync(\n      {\n        _id: parentName,\n        'children._id': {\n          $ne: role._id\n        }\n      },\n      {\n        $push: {\n          children: {\n            _id: role._id\n          }\n        }\n      }\n    )\n\n    // if there was no change, parent role might not exist, or role is\n    // already a sub-role; in any case we do not have anything more to do\n    if (!count) return\n\n    await Meteor.roleAssignment.updateAsync(\n      {\n        'inheritedRoles._id': parentName\n      },\n      {\n        $push: {\n          inheritedRoles: {\n            $each: [\n              role._id,\n              ...(await Roles._getInheritedRoleNamesAsync(role))\n            ].map((r) => ({ _id: r }))\n          }\n        }\n      },\n      { multi: true }\n    )\n  },\n\n  /**\n   * Remove role parent from roles.\n   *\n   * Other parents are kept (role can have multiple parents). For users which have the\n   * parent role set, removed subrole is removed automatically.\n   *\n   * @method removeRolesFromParentAsync\n   * @param {Array|String} rolesNames Name(s) of role(s).\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @static\n   */\n  removeRolesFromParentAsync: async function (rolesNames, parentName) {\n    // ensure arrays\n    if (!Array.isArray(rolesNames)) rolesNames = [rolesNames]\n\n    for (const roleName of rolesNames) {\n      await Roles._removeRoleFromParentAsync(roleName, parentName)\n    }\n  },\n\n  /**\n   * @method _removeRoleFromParentAsync\n   * @param {String} roleName Name of role.\n   * @param {String} parentName Name of parent role.\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _removeRoleFromParentAsync: async function (roleName, parentName) {\n    Roles._checkRoleName(roleName)\n    Roles._checkRoleName(parentName)\n\n    // check for role existence\n    // this would not really be needed, but we are trying to match addRolesToParent\n    const role = await Meteor.roles.findOneAsync(\n      { _id: roleName },\n      { fields: { _id: 1 } }\n    )\n\n    if (!role) {\n      throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n    }\n\n    const count = await Meteor.roles.updateAsync(\n      {\n        _id: parentName\n      },\n      {\n        $pull: {\n          children: {\n            _id: role._id\n          }\n        }\n      }\n    )\n\n    // if there was no change, parent role might not exist, or role was\n    // already not a subrole; in any case we do not have anything more to do\n    if (!count) return\n\n    // For all roles who have had it as a dependency ...\n    const roles = [\n      ...(await Roles._getParentRoleNamesAsync(\n        await Meteor.roles.findOneAsync({ _id: parentName })\n      )),\n      parentName\n    ]\n\n    for (const r of await Meteor.roles\n      .find({ _id: { $in: roles } })\n      .fetchAsync()) {\n      const inheritedRoles = await Roles._getInheritedRoleNamesAsync(\n        await Meteor.roles.findOneAsync({ _id: r._id })\n      )\n      await Meteor.roleAssignment.updateAsync(\n        {\n          'role._id': r._id,\n          'inheritedRoles._id': role._id\n        },\n        {\n          $set: {\n            inheritedRoles: [r._id, ...inheritedRoles].map((r2) => ({\n              _id: r2\n            }))\n          }\n        },\n        { multi: true }\n      )\n    }\n  },\n\n  /**\n   * Add users to roles.\n   *\n   * Adds roles to existing roles for each user.\n   *\n   * @example\n   *     Roles.addUsersToRolesAsync(userId, 'admin')\n   *     Roles.addUsersToRolesAsync(userId, ['view-secrets'], 'example.com')\n   *     Roles.addUsersToRolesAsync([user1, user2], ['user','editor'])\n   *     Roles.addUsersToRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method addUsersToRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  addUsersToRolesAsync: async function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        ifExists: false\n      },\n      options\n    )\n\n    for (const user of users) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n\n      for (const role of roles) {\n        await Roles._addUserToRoleAsync(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Set users' roles.\n   *\n   * Replaces all existing roles with a new set of roles.\n   *\n   * @example\n   *     await Roles.setUserRolesAsync(userId, 'admin')\n   *     await Roles.setUserRolesAsync(userId, ['view-secrets'], 'example.com')\n   *     await Roles.setUserRolesAsync([user1, user2], ['user','editor'])\n   *     await Roles.setUserRolesAsync([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *\n   * @method setUserRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if `true`, remove all roles the user has, of any scope, if `false`, only the one in the same scope\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  setUserRolesAsync: async function (users, roles, options) {\n    let id\n\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        ifExists: false,\n        anyScope: false\n      },\n      options\n    )\n\n    for (const user of users) {\n      if (typeof user === 'object') {\n        id = user._id\n      } else {\n        id = user\n      }\n      // we first clear all roles for the user\n      const selector = { 'user._id': id }\n      if (!options.anyScope) {\n        selector.scope = options.scope\n      }\n\n      await Meteor.roleAssignment.removeAsync(selector)\n\n      // and then add all\n      for (const role of roles) {\n        await Roles._addUserToRole(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Add one user to one role.\n   *\n   * @method _addUserToRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `ifExists`: if `true`, do not throw an exception if the role does not exist\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _addUserToRoleAsync: async function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) {\n      return\n    }\n\n    const role = await Meteor.roles.findOneAsync(\n      { _id: roleName },\n      { fields: { children: 1 } }\n    )\n\n    if (!role) {\n      if (options.ifExists) {\n        return []\n      } else {\n        throw new Error(\"Role '\" + roleName + \"' does not exist.\")\n      }\n    }\n\n    // This might create duplicates, because we don't have a unique index, but that's all right. In case there are two, withdrawing the role will effectively kill them both.\n    // TODO revisit this\n    /* const res = await Meteor.roleAssignment.upsertAsync(\n      {\n        \"user._id\": userId,\n        \"role._id\": roleName,\n        scope: options.scope,\n      },\n      {\n        $setOnInsert: {\n          user: { _id: userId },\n          role: { _id: roleName },\n          scope: options.scope,\n        },\n      }\n    ); */\n    const existingAssignment = await Meteor.roleAssignment.findOneAsync({\n      'user._id': userId,\n      'role._id': roleName,\n      scope: options.scope\n    })\n\n    let insertedId\n    let res\n    if (existingAssignment) {\n      await Meteor.roleAssignment.updateAsync(existingAssignment._id, {\n        $set: {\n          user: { _id: userId },\n          role: { _id: roleName },\n          scope: options.scope\n        }\n      })\n\n      res = await Meteor.roleAssignment.findOneAsync(existingAssignment._id)\n    } else {\n      insertedId = await Meteor.roleAssignment.insertAsync({\n        user: { _id: userId },\n        role: { _id: roleName },\n        scope: options.scope\n      })\n    }\n\n    if (insertedId) {\n      await Meteor.roleAssignment.updateAsync(\n        { _id: insertedId },\n        {\n          $set: {\n            inheritedRoles: [\n              roleName,\n              ...(await Roles._getInheritedRoleNamesAsync(role))\n            ].map((r) => ({ _id: r }))\n          }\n        }\n      )\n\n      res = await Meteor.roleAssignment.findOneAsync({ _id: insertedId })\n    }\n    res.insertedId = insertedId // For backward compatibility\n\n    return res\n  },\n\n  /**\n   * Returns an array of role names the given role name is a child of.\n   *\n   * @example\n   *     Roles._getParentRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getParentRoleNames\n   * @param {object} role The role object\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _getParentRoleNamesAsync: async function (role) {\n    if (!role) {\n      return []\n    }\n\n    const parentRoles = new Set([role._id])\n\n    for (const roleName of parentRoles) {\n      for (const parentRole of await Meteor.roles\n        .find({ 'children._id': roleName })\n        .fetchAsync()) {\n        parentRoles.add(parentRole._id)\n      }\n    }\n\n    parentRoles.delete(role._id)\n\n    return [...parentRoles]\n  },\n\n  /**\n   * Returns an array of role names the given role name is a parent of.\n   *\n   * @example\n   *     Roles._getInheritedRoleNames({ _id: 'admin', children; [] })\n   *\n   * @method _getInheritedRoleNames\n   * @param {object} role The role object\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _getInheritedRoleNamesAsync: async function (role) {\n    const inheritedRoles = new Set()\n    const nestedRoles = new Set([role])\n\n    for (const r of nestedRoles) {\n      const roles = await Meteor.roles\n        .find(\n          { _id: { $in: r.children.map((r) => r._id) } },\n          { fields: { children: 1 } }\n        )\n        .fetchAsync()\n\n      for (const r2 of roles) {\n        inheritedRoles.add(r2._id)\n        nestedRoles.add(r2)\n      }\n    }\n\n    return [...inheritedRoles]\n  },\n\n  /**\n   * Remove users from assigned roles.\n   *\n   * @example\n   *     await Roles.removeUsersFromRolesAsync(userId, 'admin')\n   *     await Roles.removeUsersFromRolesAsync([userId, user2], ['editor'])\n   *     await Roles.removeUsersFromRolesAsync(userId, ['user'], 'group1')\n   *\n   * @method removeUsersFromRolesAsync\n   * @param {Array|String} users User ID(s) or object(s) with an `_id` field.\n   * @param {Array|String} roles Name(s) of roles to remove users from. Roles have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @returns {Promise}\n   *\n   * Alternatively, it can be a scope name string.\n   * @static\n   */\n  removeUsersFromRolesAsync: async function (users, roles, options) {\n    if (!users) throw new Error(\"Missing 'users' param.\")\n    if (!roles) throw new Error(\"Missing 'roles' param.\")\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure arrays\n    if (!Array.isArray(users)) users = [users]\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    for (const user of users) {\n      if (!user) return\n\n      for (const role of roles) {\n        let id\n        if (typeof user === 'object') {\n          id = user._id\n        } else {\n          id = user\n        }\n\n        await Roles._removeUserFromRoleAsync(id, role, options)\n      }\n    }\n  },\n\n  /**\n   * Remove one user from one role.\n   *\n   * @method _removeUserFromRole\n   * @param {String} userId The user ID.\n   * @param {String} roleName Name of the role to add the user to. The role have to exist.\n   * @param {Object} options Options:\n   *   - `scope`: name of the scope, or `null` for the global role\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   * @returns {Promise}\n   * @private\n   * @static\n   */\n  _removeUserFromRoleAsync: async function (userId, roleName, options) {\n    Roles._checkRoleName(roleName)\n    Roles._checkScopeName(options.scope)\n\n    if (!userId) return\n\n    const selector = {\n      'user._id': userId,\n      'role._id': roleName\n    }\n\n    if (!options.anyScope) {\n      selector.scope = options.scope\n    }\n\n    await Meteor.roleAssignment.removeAsync(selector)\n  },\n\n  /**\n   * Check if user has specified roles.\n   *\n   * @example\n   *     // global roles\n   *     await Roles.userIsInRoleAsync(user, 'admin')\n   *     await Roles.userIsInRoleAsync(user, ['admin','editor'])\n   *     await Roles.userIsInRoleAsync(userId, 'admin')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'])\n   *\n   *     // scope roles (global roles are still checked)\n   *     await Roles.userIsInRoleAsync(user, 'admin', 'group1')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], 'group1')\n   *     await Roles.userIsInRoleAsync(userId, ['admin','editor'], {scope: 'group1'})\n   *\n   * @method userIsInRoleAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} roles Name of role or an array of roles to check against. If array,\n   *                             will return `true` if user is in _any_ role.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope; if supplied, limits check to just that scope\n   *     the user's global roles will always be checked whether scope is specified or not\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Promise<Boolean>} `true` if user is in _any_ of the target roles\n   * @static\n   */\n  userIsInRoleAsync: async function (user, roles, options) {\n    let id\n\n    options = Roles._normalizeOptions(options)\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    roles = roles.filter((r) => r != null)\n\n    if (!roles.length) return false\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign(\n      {\n        anyScope: false\n      },\n      options\n    )\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return false\n    if (typeof id !== 'string') return false\n\n    const selector = {\n      'user._id': id\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope, null] }\n    }\n\n    const res = await asyncSome(roles, async (roleName) => {\n      selector['inheritedRoles._id'] = roleName\n      const out =\n        (await Meteor.roleAssignment\n          .find(selector, { limit: 1 })\n          .countAsync()) > 0\n      return out\n    })\n\n    return res\n  },\n\n  /**\n   * Retrieve user's roles.\n   *\n   * @method getRolesForUserAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of scope to provide roles for; if not specified, global roles are returned\n   *   - `anyScope`: if set, role can be in any scope (`scope` and `onlyAssigned` options are ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `onlyAssigned`: return only assigned roles and not automatically inferred (like subroles)\n   *   - `fullObjects`: return full roles objects (`true`) or just names (`false`) (`onlyAssigned` option is ignored) (default `false`)\n   *     If you have a use-case for this option, please file a feature-request. You shouldn't need to use it as it's\n   *     result strongly dependent on the internal data structure of this plugin.\n   *\n   * Alternatively, it can be a scope name string.\n   * @return {Promise<Array>} Array of user's roles, unsorted.\n   * @static\n   */\n  getRolesForUserAsync: async function (user, options) {\n    let id\n\n    options = Roles._normalizeOptions(options)\n\n    Roles._checkScopeName(options.scope)\n\n    options = Object.assign({\n      fullObjects: false,\n      onlyAssigned: false,\n      anyScope: false,\n      onlyScoped: false\n    }, options)\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id\n    }\n\n    const filter = {\n      fields: { 'inheritedRoles._id': 1 }\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    if (options.onlyAssigned) {\n      delete filter.fields['inheritedRoles._id']\n      filter.fields['role._id'] = 1\n    }\n\n    if (options.fullObjects) {\n      delete filter.fields\n    }\n\n    const roles = await Meteor.roleAssignment.find(selector, filter).fetchAsync()\n\n    if (options.fullObjects) {\n      return roles\n    }\n\n    return [\n      ...new Set(\n        roles.reduce((rev, current) => {\n          if (current.inheritedRoles) {\n            return rev.concat(current.inheritedRoles.map((r) => r._id))\n          } else if (current.role) {\n            rev.push(current.role._id)\n          }\n          return rev\n        }, [])\n      )\n    ]\n  },\n\n  /**\n   * Retrieve cursor of all existing roles.\n   *\n   * @method getAllRoles\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.roles.find(query, options)`.\n   * @return {Cursor} Cursor of existing roles.\n   * @static\n   */\n  getAllRoles: function (queryOptions) {\n    queryOptions = queryOptions || { sort: { _id: 1 } }\n\n    return Meteor.roles.find({}, queryOptions)\n  },\n\n  /**\n   * Retrieve all users who are in target role.\n   *\n   * Options:\n   *\n   * @method getUsersInRoleAsync\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `onlyScoped`: if set, only roles in the specified scope are returned\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.users.find(query, options)`\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [queryOptions] Options which are passed directly\n   *                                through to `Meteor.users.find(query, options)`\n   * @return {Promise<Cursor>} Cursor of users in roles.\n   * @static\n   */\n  getUsersInRoleAsync: async function (roles, options, queryOptions) {\n    const ids = (\n      await Roles.getUserAssignmentsForRole(roles, options).fetchAsync()\n    ).map((a) => a.user._id)\n\n    return Meteor.users.find(\n      { _id: { $in: ids } },\n      (options && options.queryOptions) || queryOptions || {}\n    )\n  },\n\n  /**\n   * Retrieve all assignments of a user which are for the target role.\n   *\n   * Options:\n   *\n   * @method getUserAssignmentsForRole\n   * @param {Array|String} roles Name of role or an array of roles. If array, users\n   *                             returned will have at least one of the roles\n   *                             specified but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *   - `queryOptions`: options which are passed directly\n   *     through to `Meteor.roleAssignment.find(query, options)`\n\n   * Alternatively, it can be a scope name string.\n   * @return {Cursor} Cursor of user assignments for roles.\n   * @static\n   */\n  getUserAssignmentsForRole: function (roles, options) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign(\n      {\n        anyScope: false,\n        queryOptions: {}\n      },\n      options\n    )\n\n    return Roles._getUsersInRoleCursor(roles, options, options.queryOptions)\n  },\n\n  /**\n   * @method _getUsersInRoleCursor\n   * @param {Array|String} roles Name of role or an array of roles. If array, ids of users are\n   *                             returned which have at least one of the roles\n   *                             assigned but need not have _all_ roles.\n   *                             Roles do not have to exist.\n   * @param {Object|String} [options] Options:\n   *   - `scope`: name of the scope to restrict roles to; user's global\n   *     roles will also be checked\n   *   - `anyScope`: if set, role can be in any scope (`scope` option is ignored)\n   *\n   * Alternatively, it can be a scope name string.\n   * @param {Object} [filter] Options which are passed directly\n   *                                through to `Meteor.roleAssignment.find(query, options)`\n   * @return {Object} Cursor to the assignment documents\n   * @private\n   * @static\n   */\n  _getUsersInRoleCursor: function (roles, options, filter) {\n    options = Roles._normalizeOptions(options)\n\n    options = Object.assign(\n      {\n        anyScope: false,\n        onlyScoped: false\n      },\n      options\n    )\n\n    // ensure array to simplify code\n    if (!Array.isArray(roles)) roles = [roles]\n\n    Roles._checkScopeName(options.scope)\n\n    filter = Object.assign(\n      {\n        fields: { 'user._id': 1 }\n      },\n      filter\n    )\n\n    const selector = {\n      'inheritedRoles._id': { $in: roles }\n    }\n\n    if (!options.anyScope) {\n      selector.scope = { $in: [options.scope] }\n\n      if (!options.onlyScoped) {\n        selector.scope.$in.push(null)\n      }\n    }\n\n    return Meteor.roleAssignment.find(selector, filter)\n  },\n\n  /**\n   * Deprecated. Use `getScopesForUser` instead.\n   *\n   * @method getGroupsForUserAsync\n   * @returns {Promise<Array>}\n   * @static\n   * @deprecated\n   */\n  getGroupsForUserAsync: async function (...args) {\n    if (!getGroupsForUserDeprecationWarning) {\n      getGroupsForUserDeprecationWarning = true\n      console &&\n        console.warn(\n          'getGroupsForUser has been deprecated. Use getScopesForUser instead.'\n        )\n    }\n\n    return await Roles.getScopesForUser(...args)\n  },\n\n  /**\n   * Retrieve users scopes, if any.\n   *\n   * @method getScopesForUserAsync\n   * @param {String|Object} user User ID or an actual user object.\n   * @param {Array|String} [roles] Name of roles to restrict scopes to.\n   *\n   * @return {Promise<Array>} Array of user's scopes, unsorted.\n   * @static\n   */\n  getScopesForUserAsync: async function (user, roles) {\n    let id\n\n    if (roles && !Array.isArray(roles)) roles = [roles]\n\n    if (user && typeof user === 'object') {\n      id = user._id\n    } else {\n      id = user\n    }\n\n    if (!id) return []\n\n    const selector = {\n      'user._id': id,\n      scope: { $ne: null }\n    }\n\n    if (roles) {\n      selector['inheritedRoles._id'] = { $in: roles }\n    }\n\n    const scopes = (\n      await Meteor.roleAssignment\n        .find(selector, { fields: { scope: 1 } })\n        .fetchAsync()\n    ).map((obi) => obi.scope)\n\n    return [...new Set(scopes)]\n  },\n\n  /**\n   * Rename a scope.\n   *\n   * Roles assigned with a given scope are changed to be under the new scope.\n   *\n   * @method renameScopeAsync\n   * @param {String} oldName Old name of a scope.\n   * @param {String} newName New name of a scope.\n   * @returns {Promise}\n   * @static\n   */\n  renameScopeAsync: async function (oldName, newName) {\n    let count\n\n    Roles._checkScopeName(oldName)\n    Roles._checkScopeName(newName)\n\n    if (oldName === newName) return\n\n    do {\n      count = await Meteor.roleAssignment.updateAsync(\n        {\n          scope: oldName\n        },\n        {\n          $set: {\n            scope: newName\n          }\n        },\n        { multi: true }\n      )\n    } while (count > 0)\n  },\n\n  /**\n   * Remove a scope.\n   *\n   * Roles assigned with a given scope are removed.\n   *\n   * @method removeScopeAsync\n   * @param {String} name The name of a scope.\n   * @returns {Promise}\n   * @static\n   */\n  removeScopeAsync: async function (name) {\n    Roles._checkScopeName(name)\n\n    await Meteor.roleAssignment.removeAsync({ scope: name })\n  },\n\n  /**\n   * Throw an exception if `roleName` is an invalid role name.\n   *\n   * @method _checkRoleName\n   * @param {String} roleName A role name to match against.\n   * @private\n   * @static\n   */\n  _checkRoleName: function (roleName) {\n    if (\n      !roleName ||\n      typeof roleName !== 'string' ||\n      roleName.trim() !== roleName\n    ) {\n      throw new Error(\"Invalid role name '\" + roleName + \"'.\")\n    }\n  },\n\n  /**\n   * Find out if a role is an ancestor of another role.\n   *\n   * WARNING: If you check this on the client, please make sure all roles are published.\n   *\n   * @method isParentOfAsync\n   * @param {String} parentRoleName The role you want to research.\n   * @param {String} childRoleName The role you expect to be among the children of parentRoleName.\n   * @returns {Promise}\n   * @static\n   */\n  isParentOfAsync: async function (parentRoleName, childRoleName) {\n    if (parentRoleName === childRoleName) {\n      return true\n    }\n\n    if (parentRoleName == null || childRoleName == null) {\n      return false\n    }\n\n    Roles._checkRoleName(parentRoleName)\n    Roles._checkRoleName(childRoleName)\n\n    let rolesToCheck = [parentRoleName]\n    while (rolesToCheck.length !== 0) {\n      const roleName = rolesToCheck.pop()\n\n      if (roleName === childRoleName) {\n        return true\n      }\n\n      const role = await Meteor.roles.findOneAsync({ _id: roleName })\n\n      // This should not happen, but this is a problem to address at some other time.\n      if (!role) continue\n\n      rolesToCheck = rolesToCheck.concat(role.children.map((r) => r._id))\n    }\n\n    return false\n  },\n\n  /**\n   * Normalize options.\n   *\n   * @method _normalizeOptions\n   * @param {Object} options Options to normalize.\n   * @return {Object} Normalized options.\n   * @private\n   * @static\n   */\n  _normalizeOptions: function (options) {\n    options = options === undefined ? {} : options\n\n    if (options === null || typeof options === 'string') {\n      options = { scope: options }\n    }\n\n    options.scope = Roles._normalizeScopeName(options.scope)\n\n    return options\n  },\n\n  /**\n   * Normalize scope name.\n   *\n   * @method _normalizeScopeName\n   * @param {String} scopeName A scope name to normalize.\n   * @return {String} Normalized scope name.\n   * @private\n   * @static\n   */\n  _normalizeScopeName: function (scopeName) {\n    // map undefined and null to null\n    if (scopeName == null) {\n      return null\n    } else {\n      return scopeName\n    }\n  },\n\n  /**\n   * Throw an exception if `scopeName` is an invalid scope name.\n   *\n   * @method _checkRoleName\n   * @param {String} scopeName A scope name to match against.\n   * @private\n   * @static\n   */\n  _checkScopeName: function (scopeName) {\n    if (scopeName === null) return\n\n    if (\n      !scopeName ||\n      typeof scopeName !== 'string' ||\n      scopeName.trim() !== scopeName\n    ) {\n      throw new Error(\"Invalid scope name '\" + scopeName + \"'.\")\n    }\n  }\n})\n"],"mappings":";EAAA,IAAIA,MAAM;EAACC,OAAO,CAACC,IAAI,CAAC,eAAe,EAAC;IAACF,MAAMA,CAACG,CAAC,EAAC;MAACH,MAAM,GAACG,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAAC,IAAIC,KAAK;EAACH,OAAO,CAACC,IAAI,CAAC,cAAc,EAAC;IAACE,KAAKA,CAACD,CAAC,EAAC;MAACC,KAAK,GAACD,CAAC;IAAA;EAAC,CAAC,EAAC,CAAC,CAAC;EAI7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA,IAAI,CAACH,MAAM,CAACK,KAAK,EAAE;IACjBL,MAAM,CAACK,KAAK,GAAG,IAAID,KAAK,CAACE,UAAU,CAAC,OAAO,CAAC;EAC9C;EAEA,IAAI,CAACN,MAAM,CAACO,cAAc,EAAE;IAC1BP,MAAM,CAACO,cAAc,GAAG,IAAIH,KAAK,CAACE,UAAU,CAAC,iBAAiB,CAAC;EACjE;;EAEA;AACA;AACA;EACA,IAAI,OAAOE,KAAK,KAAK,WAAW,EAAE;IAChCA,KAAK,GAAG,CAAC,CAAC,EAAC;EACb;EAEA,IAAIC,kCAAkC,GAAG,KAAK;;EAE9C;AACA;AACA;AACA;AACA;AACA;EACA,MAAMC,SAAS,GAAG,MAAAA,CAAOC,GAAG,EAAEC,SAAS,KAAK;IAC1C,KAAK,MAAMC,CAAC,IAAIF,GAAG,EAAE;MACnB,IAAI,MAAMC,SAAS,CAACC,CAAC,CAAC,EAAE,OAAO,IAAI;IACrC;IACA,OAAO,KAAK;EACd,CAAC;EAEDC,MAAM,CAACC,MAAM,CAACP,KAAK,EAAE;IACnB;AACF;AACA;AACA;AACA;AACA;AACA;IACEQ,YAAY,EAAE,IAAI;IAElB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,eAAe,EAAE,eAAAA,CAAgBC,QAAQ,EAAEC,OAAO,EAAE;MAClDX,KAAK,CAACY,cAAc,CAACF,QAAQ,CAAC;MAE9BC,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;QACEM,YAAY,EAAE;MAChB,CAAC,EACDF,OACF,CAAC;MAED,IAAIG,UAAU,GAAG,IAAI;MAErB,MAAMC,YAAY,GAAG,MAAMvB,MAAM,CAACK,KAAK,CAACmB,YAAY,CAAC;QAAEC,GAAG,EAAEP;MAAS,CAAC,CAAC;MAEvE,IAAIK,YAAY,EAAE;QAChB,MAAMvB,MAAM,CAACK,KAAK,CAACqB,WAAW,CAC5B;UAAED,GAAG,EAAEP;QAAS,CAAC,EACjB;UAAES,YAAY,EAAE;YAAEC,QAAQ,EAAE;UAAG;QAAE,CACnC,CAAC;QACD,OAAO,IAAI;MACb,CAAC,MAAM;QACLN,UAAU,GAAG,MAAMtB,MAAM,CAACK,KAAK,CAACwB,WAAW,CAAC;UAC1CJ,GAAG,EAAEP,QAAQ;UACbU,QAAQ,EAAE;QACZ,CAAC,CAAC;MACJ;MAEA,IAAI,CAACN,UAAU,EAAE;QACf,IAAIH,OAAO,CAACE,YAAY,EAAE,OAAO,IAAI;QACrC,MAAM,IAAIS,KAAK,CAAC,QAAQ,GAAGZ,QAAQ,GAAG,mBAAmB,CAAC;MAC5D;MAEA,OAAOI,UAAU;IACnB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACES,eAAe,EAAE,eAAAA,CAAgBb,QAAQ,EAAE;MACzC,IAAIb,KAAK;MACT,IAAI2B,cAAc;MAElBxB,KAAK,CAACY,cAAc,CAACF,QAAQ,CAAC;;MAE9B;MACA,MAAMlB,MAAM,CAACO,cAAc,CAAC0B,WAAW,CAAC;QACtC,UAAU,EAAEf;MACd,CAAC,CAAC;MAEF,GAAG;QACD;QACAb,KAAK,GAAGG,KAAK,CAAC0B,mBAAmB,CAC/B,MAAMlC,MAAM,CAACK,KAAK,CAACmB,YAAY,CAAC;UAAEC,GAAG,EAAEP;QAAS,CAAC,CACnD,CAAC;QAED,KAAK,MAAMiB,CAAC,IAAI,MAAMnC,MAAM,CAACK,KAAK,CAC/B+B,IAAI,CAAC;UAAEX,GAAG,EAAE;YAAEY,GAAG,EAAEhC;UAAM;QAAE,CAAC,CAAC,CAC7BiC,UAAU,CAAC,CAAC,EAAE;UACf,MAAMtC,MAAM,CAACK,KAAK,CAACqB,WAAW,CAC5B;YACED,GAAG,EAAEU,CAAC,CAACV;UACT,CAAC,EACD;YACEc,KAAK,EAAE;cACLX,QAAQ,EAAE;gBACRH,GAAG,EAAEP;cACP;YACF;UACF,CACF,CAAC;UAEDc,cAAc,GAAG,MAAMxB,KAAK,CAACgC,2BAA2B,CACtD,MAAMxC,MAAM,CAACK,KAAK,CAACmB,YAAY,CAAC;YAAEC,GAAG,EAAEU,CAAC,CAACV;UAAI,CAAC,CAChD,CAAC;UACD,MAAMzB,MAAM,CAACO,cAAc,CAACmB,WAAW,CACrC;YACE,UAAU,EAAES,CAAC,CAACV;UAChB,CAAC,EACD;YACEgB,IAAI,EAAE;cACJT,cAAc,EAAE,CAACG,CAAC,CAACV,GAAG,EAAE,GAAGO,cAAc,CAAC,CAACU,GAAG,CAAEC,EAAE,KAAM;gBACtDlB,GAAG,EAAEkB;cACP,CAAC,CAAC;YACJ;UACF,CAAC,EACD;YAAEC,KAAK,EAAE;UAAK,CAChB,CAAC;QACH;MACF,CAAC,QAAQvC,KAAK,CAACwC,MAAM,GAAG,CAAC;;MAEzB;MACA,MAAM7C,MAAM,CAACK,KAAK,CAAC4B,WAAW,CAAC;QAAER,GAAG,EAAEP;MAAS,CAAC,CAAC;IACnD,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE4B,eAAe,EAAE,eAAAA,CAAgBC,OAAO,EAAEC,OAAO,EAAE;MACjD,IAAIC,KAAK;MAETzC,KAAK,CAACY,cAAc,CAAC2B,OAAO,CAAC;MAC7BvC,KAAK,CAACY,cAAc,CAAC4B,OAAO,CAAC;MAE7B,IAAID,OAAO,KAAKC,OAAO,EAAE;MAEzB,MAAME,IAAI,GAAG,MAAMlD,MAAM,CAACK,KAAK,CAACmB,YAAY,CAAC;QAAEC,GAAG,EAAEsB;MAAQ,CAAC,CAAC;MAE9D,IAAI,CAACG,IAAI,EAAE;QACT,MAAM,IAAIpB,KAAK,CAAC,QAAQ,GAAGiB,OAAO,GAAG,mBAAmB,CAAC;MAC3D;MAEAG,IAAI,CAACzB,GAAG,GAAGuB,OAAO;MAElB,MAAMhD,MAAM,CAACK,KAAK,CAACwB,WAAW,CAACqB,IAAI,CAAC;MAEpC,GAAG;QACDD,KAAK,GAAG,MAAMjD,MAAM,CAACO,cAAc,CAACmB,WAAW,CAC7C;UACE,UAAU,EAAEqB;QACd,CAAC,EACD;UACEN,IAAI,EAAE;YACJ,UAAU,EAAEO;UACd;QACF,CAAC,EACD;UAAEJ,KAAK,EAAE;QAAK,CAChB,CAAC;MACH,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB,GAAG;QACDA,KAAK,GAAG,MAAMjD,MAAM,CAACO,cAAc,CAACmB,WAAW,CAC7C;UACE,oBAAoB,EAAEqB;QACxB,CAAC,EACD;UACEN,IAAI,EAAE;YACJ,sBAAsB,EAAEO;UAC1B;QACF,CAAC,EACD;UAAEJ,KAAK,EAAE;QAAK,CAChB,CAAC;MACH,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB,GAAG;QACDA,KAAK,GAAG,MAAMjD,MAAM,CAACK,KAAK,CAACqB,WAAW,CACpC;UACE,cAAc,EAAEqB;QAClB,CAAC,EACD;UACEN,IAAI,EAAE;YACJ,gBAAgB,EAAEO;UACpB;QACF,CAAC,EACD;UAAEJ,KAAK,EAAE;QAAK,CAChB,CAAC;MACH,CAAC,QAAQK,KAAK,GAAG,CAAC;MAElB,MAAMjD,MAAM,CAACK,KAAK,CAAC4B,WAAW,CAAC;QAAER,GAAG,EAAEsB;MAAQ,CAAC,CAAC;IAClD,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEI,qBAAqB,EAAE,eAAAA,CAAgBC,UAAU,EAAEC,UAAU,EAAE;MAC7D;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAEA,UAAU,GAAG,CAACA,UAAU,CAAC;MAEzD,KAAK,MAAMlC,QAAQ,IAAIkC,UAAU,EAAE;QACjC,MAAM5C,KAAK,CAACgD,qBAAqB,CAACtC,QAAQ,EAAEmC,UAAU,CAAC;MACzD;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACEG,qBAAqB,EAAE,eAAAA,CAAgBtC,QAAQ,EAAEmC,UAAU,EAAE;MAC3D7C,KAAK,CAACY,cAAc,CAACF,QAAQ,CAAC;MAC9BV,KAAK,CAACY,cAAc,CAACiC,UAAU,CAAC;;MAEhC;MACA,MAAMH,IAAI,GAAG,MAAMlD,MAAM,CAACK,KAAK,CAACmB,YAAY,CAAC;QAAEC,GAAG,EAAEP;MAAS,CAAC,CAAC;MAE/D,IAAI,CAACgC,IAAI,EAAE;QACT,MAAM,IAAIpB,KAAK,CAAC,QAAQ,GAAGZ,QAAQ,GAAG,mBAAmB,CAAC;MAC5D;;MAEA;MACA,IAAI,CAAC,MAAMV,KAAK,CAACgC,2BAA2B,CAACU,IAAI,CAAC,EAAEO,QAAQ,CAACJ,UAAU,CAAC,EAAE;QACxE,MAAM,IAAIvB,KAAK,CACb,SAAS,GAAGZ,QAAQ,GAAG,SAAS,GAAGmC,UAAU,GAAG,uBAClD,CAAC;MACH;MAEA,MAAMJ,KAAK,GAAG,MAAMjD,MAAM,CAACK,KAAK,CAACqB,WAAW,CAC1C;QACED,GAAG,EAAE4B,UAAU;QACf,cAAc,EAAE;UACdK,GAAG,EAAER,IAAI,CAACzB;QACZ;MACF,CAAC,EACD;QACEkC,KAAK,EAAE;UACL/B,QAAQ,EAAE;YACRH,GAAG,EAAEyB,IAAI,CAACzB;UACZ;QACF;MACF,CACF,CAAC;;MAED;MACA;MACA,IAAI,CAACwB,KAAK,EAAE;MAEZ,MAAMjD,MAAM,CAACO,cAAc,CAACmB,WAAW,CACrC;QACE,oBAAoB,EAAE2B;MACxB,CAAC,EACD;QACEM,KAAK,EAAE;UACL3B,cAAc,EAAE;YACd4B,KAAK,EAAE,CACLV,IAAI,CAACzB,GAAG,EACR,IAAI,MAAMjB,KAAK,CAACgC,2BAA2B,CAACU,IAAI,CAAC,CAAC,CACnD,CAACR,GAAG,CAAEP,CAAC,KAAM;cAAEV,GAAG,EAAEU;YAAE,CAAC,CAAC;UAC3B;QACF;MACF,CAAC,EACD;QAAES,KAAK,EAAE;MAAK,CAChB,CAAC;IACH,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEiB,0BAA0B,EAAE,eAAAA,CAAgBT,UAAU,EAAEC,UAAU,EAAE;MAClE;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAAEA,UAAU,GAAG,CAACA,UAAU,CAAC;MAEzD,KAAK,MAAMlC,QAAQ,IAAIkC,UAAU,EAAE;QACjC,MAAM5C,KAAK,CAACsD,0BAA0B,CAAC5C,QAAQ,EAAEmC,UAAU,CAAC;MAC9D;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACES,0BAA0B,EAAE,eAAAA,CAAgB5C,QAAQ,EAAEmC,UAAU,EAAE;MAChE7C,KAAK,CAACY,cAAc,CAACF,QAAQ,CAAC;MAC9BV,KAAK,CAACY,cAAc,CAACiC,UAAU,CAAC;;MAEhC;MACA;MACA,MAAMH,IAAI,GAAG,MAAMlD,MAAM,CAACK,KAAK,CAACmB,YAAY,CAC1C;QAAEC,GAAG,EAAEP;MAAS,CAAC,EACjB;QAAE6C,MAAM,EAAE;UAAEtC,GAAG,EAAE;QAAE;MAAE,CACvB,CAAC;MAED,IAAI,CAACyB,IAAI,EAAE;QACT,MAAM,IAAIpB,KAAK,CAAC,QAAQ,GAAGZ,QAAQ,GAAG,mBAAmB,CAAC;MAC5D;MAEA,MAAM+B,KAAK,GAAG,MAAMjD,MAAM,CAACK,KAAK,CAACqB,WAAW,CAC1C;QACED,GAAG,EAAE4B;MACP,CAAC,EACD;QACEd,KAAK,EAAE;UACLX,QAAQ,EAAE;YACRH,GAAG,EAAEyB,IAAI,CAACzB;UACZ;QACF;MACF,CACF,CAAC;;MAED;MACA;MACA,IAAI,CAACwB,KAAK,EAAE;;MAEZ;MACA,MAAM5C,KAAK,GAAG,CACZ,IAAI,MAAMG,KAAK,CAACwD,wBAAwB,CACtC,MAAMhE,MAAM,CAACK,KAAK,CAACmB,YAAY,CAAC;QAAEC,GAAG,EAAE4B;MAAW,CAAC,CACrD,CAAC,CAAC,EACFA,UAAU,CACX;MAED,KAAK,MAAMlB,CAAC,IAAI,MAAMnC,MAAM,CAACK,KAAK,CAC/B+B,IAAI,CAAC;QAAEX,GAAG,EAAE;UAAEY,GAAG,EAAEhC;QAAM;MAAE,CAAC,CAAC,CAC7BiC,UAAU,CAAC,CAAC,EAAE;QACf,MAAMN,cAAc,GAAG,MAAMxB,KAAK,CAACgC,2BAA2B,CAC5D,MAAMxC,MAAM,CAACK,KAAK,CAACmB,YAAY,CAAC;UAAEC,GAAG,EAAEU,CAAC,CAACV;QAAI,CAAC,CAChD,CAAC;QACD,MAAMzB,MAAM,CAACO,cAAc,CAACmB,WAAW,CACrC;UACE,UAAU,EAAES,CAAC,CAACV,GAAG;UACjB,oBAAoB,EAAEyB,IAAI,CAACzB;QAC7B,CAAC,EACD;UACEgB,IAAI,EAAE;YACJT,cAAc,EAAE,CAACG,CAAC,CAACV,GAAG,EAAE,GAAGO,cAAc,CAAC,CAACU,GAAG,CAAEC,EAAE,KAAM;cACtDlB,GAAG,EAAEkB;YACP,CAAC,CAAC;UACJ;QACF,CAAC,EACD;UAAEC,KAAK,EAAE;QAAK,CAChB,CAAC;MACH;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEqB,oBAAoB,EAAE,eAAAA,CAAgBC,KAAK,EAAE7D,KAAK,EAAEc,OAAO,EAAE;MAC3D,IAAIgD,EAAE;MAEN,IAAI,CAACD,KAAK,EAAE,MAAM,IAAIpC,KAAK,CAAC,wBAAwB,CAAC;MACrD,IAAI,CAACzB,KAAK,EAAE,MAAM,IAAIyB,KAAK,CAAC,wBAAwB,CAAC;MAErDX,OAAO,GAAGX,KAAK,CAAC4D,iBAAiB,CAACjD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACmC,KAAK,CAACC,OAAO,CAACW,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACZ,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CG,KAAK,CAAC6D,eAAe,CAAClD,OAAO,CAACmD,KAAK,CAAC;MAEpCnD,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;QACEwD,QAAQ,EAAE;MACZ,CAAC,EACDpD,OACF,CAAC;MAED,KAAK,MAAMqD,IAAI,IAAIN,KAAK,EAAE;QACxB,IAAI,OAAOM,IAAI,KAAK,QAAQ,EAAE;UAC5BL,EAAE,GAAGK,IAAI,CAAC/C,GAAG;QACf,CAAC,MAAM;UACL0C,EAAE,GAAGK,IAAI;QACX;QAEA,KAAK,MAAMtB,IAAI,IAAI7C,KAAK,EAAE;UACxB,MAAMG,KAAK,CAACiE,mBAAmB,CAACN,EAAE,EAAEjB,IAAI,EAAE/B,OAAO,CAAC;QACpD;MACF;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEuD,iBAAiB,EAAE,eAAAA,CAAgBR,KAAK,EAAE7D,KAAK,EAAEc,OAAO,EAAE;MACxD,IAAIgD,EAAE;MAEN,IAAI,CAACD,KAAK,EAAE,MAAM,IAAIpC,KAAK,CAAC,wBAAwB,CAAC;MACrD,IAAI,CAACzB,KAAK,EAAE,MAAM,IAAIyB,KAAK,CAAC,wBAAwB,CAAC;MAErDX,OAAO,GAAGX,KAAK,CAAC4D,iBAAiB,CAACjD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACmC,KAAK,CAACC,OAAO,CAACW,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACZ,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CG,KAAK,CAAC6D,eAAe,CAAClD,OAAO,CAACmD,KAAK,CAAC;MAEpCnD,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;QACEwD,QAAQ,EAAE,KAAK;QACfI,QAAQ,EAAE;MACZ,CAAC,EACDxD,OACF,CAAC;MAED,KAAK,MAAMqD,IAAI,IAAIN,KAAK,EAAE;QACxB,IAAI,OAAOM,IAAI,KAAK,QAAQ,EAAE;UAC5BL,EAAE,GAAGK,IAAI,CAAC/C,GAAG;QACf,CAAC,MAAM;UACL0C,EAAE,GAAGK,IAAI;QACX;QACA;QACA,MAAMI,QAAQ,GAAG;UAAE,UAAU,EAAET;QAAG,CAAC;QACnC,IAAI,CAAChD,OAAO,CAACwD,QAAQ,EAAE;UACrBC,QAAQ,CAACN,KAAK,GAAGnD,OAAO,CAACmD,KAAK;QAChC;QAEA,MAAMtE,MAAM,CAACO,cAAc,CAAC0B,WAAW,CAAC2C,QAAQ,CAAC;;QAEjD;QACA,KAAK,MAAM1B,IAAI,IAAI7C,KAAK,EAAE;UACxB,MAAMG,KAAK,CAACqE,cAAc,CAACV,EAAE,EAAEjB,IAAI,EAAE/B,OAAO,CAAC;QAC/C;MACF;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEsD,mBAAmB,EAAE,eAAAA,CAAgBK,MAAM,EAAE5D,QAAQ,EAAEC,OAAO,EAAE;MAC9DX,KAAK,CAACY,cAAc,CAACF,QAAQ,CAAC;MAC9BV,KAAK,CAAC6D,eAAe,CAAClD,OAAO,CAACmD,KAAK,CAAC;MAEpC,IAAI,CAACQ,MAAM,EAAE;QACX;MACF;MAEA,MAAM5B,IAAI,GAAG,MAAMlD,MAAM,CAACK,KAAK,CAACmB,YAAY,CAC1C;QAAEC,GAAG,EAAEP;MAAS,CAAC,EACjB;QAAE6C,MAAM,EAAE;UAAEnC,QAAQ,EAAE;QAAE;MAAE,CAC5B,CAAC;MAED,IAAI,CAACsB,IAAI,EAAE;QACT,IAAI/B,OAAO,CAACoD,QAAQ,EAAE;UACpB,OAAO,EAAE;QACX,CAAC,MAAM;UACL,MAAM,IAAIzC,KAAK,CAAC,QAAQ,GAAGZ,QAAQ,GAAG,mBAAmB,CAAC;QAC5D;MACF;;MAEA;MACA;MACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACI,MAAM6D,kBAAkB,GAAG,MAAM/E,MAAM,CAACO,cAAc,CAACiB,YAAY,CAAC;QAClE,UAAU,EAAEsD,MAAM;QAClB,UAAU,EAAE5D,QAAQ;QACpBoD,KAAK,EAAEnD,OAAO,CAACmD;MACjB,CAAC,CAAC;MAEF,IAAIhD,UAAU;MACd,IAAI0D,GAAG;MACP,IAAID,kBAAkB,EAAE;QACtB,MAAM/E,MAAM,CAACO,cAAc,CAACmB,WAAW,CAACqD,kBAAkB,CAACtD,GAAG,EAAE;UAC9DgB,IAAI,EAAE;YACJ+B,IAAI,EAAE;cAAE/C,GAAG,EAAEqD;YAAO,CAAC;YACrB5B,IAAI,EAAE;cAAEzB,GAAG,EAAEP;YAAS,CAAC;YACvBoD,KAAK,EAAEnD,OAAO,CAACmD;UACjB;QACF,CAAC,CAAC;QAEFU,GAAG,GAAG,MAAMhF,MAAM,CAACO,cAAc,CAACiB,YAAY,CAACuD,kBAAkB,CAACtD,GAAG,CAAC;MACxE,CAAC,MAAM;QACLH,UAAU,GAAG,MAAMtB,MAAM,CAACO,cAAc,CAACsB,WAAW,CAAC;UACnD2C,IAAI,EAAE;YAAE/C,GAAG,EAAEqD;UAAO,CAAC;UACrB5B,IAAI,EAAE;YAAEzB,GAAG,EAAEP;UAAS,CAAC;UACvBoD,KAAK,EAAEnD,OAAO,CAACmD;QACjB,CAAC,CAAC;MACJ;MAEA,IAAIhD,UAAU,EAAE;QACd,MAAMtB,MAAM,CAACO,cAAc,CAACmB,WAAW,CACrC;UAAED,GAAG,EAAEH;QAAW,CAAC,EACnB;UACEmB,IAAI,EAAE;YACJT,cAAc,EAAE,CACdd,QAAQ,EACR,IAAI,MAAMV,KAAK,CAACgC,2BAA2B,CAACU,IAAI,CAAC,CAAC,CACnD,CAACR,GAAG,CAAEP,CAAC,KAAM;cAAEV,GAAG,EAAEU;YAAE,CAAC,CAAC;UAC3B;QACF,CACF,CAAC;QAED6C,GAAG,GAAG,MAAMhF,MAAM,CAACO,cAAc,CAACiB,YAAY,CAAC;UAAEC,GAAG,EAAEH;QAAW,CAAC,CAAC;MACrE;MACA0D,GAAG,CAAC1D,UAAU,GAAGA,UAAU,EAAC;;MAE5B,OAAO0D,GAAG;IACZ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEhB,wBAAwB,EAAE,eAAAA,CAAgBd,IAAI,EAAE;MAC9C,IAAI,CAACA,IAAI,EAAE;QACT,OAAO,EAAE;MACX;MAEA,MAAM+B,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAChC,IAAI,CAACzB,GAAG,CAAC,CAAC;MAEvC,KAAK,MAAMP,QAAQ,IAAI+D,WAAW,EAAE;QAClC,KAAK,MAAME,UAAU,IAAI,MAAMnF,MAAM,CAACK,KAAK,CACxC+B,IAAI,CAAC;UAAE,cAAc,EAAElB;QAAS,CAAC,CAAC,CAClCoB,UAAU,CAAC,CAAC,EAAE;UACf2C,WAAW,CAACG,GAAG,CAACD,UAAU,CAAC1D,GAAG,CAAC;QACjC;MACF;MAEAwD,WAAW,CAACI,MAAM,CAACnC,IAAI,CAACzB,GAAG,CAAC;MAE5B,OAAO,CAAC,GAAGwD,WAAW,CAAC;IACzB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEzC,2BAA2B,EAAE,eAAAA,CAAgBU,IAAI,EAAE;MACjD,MAAMlB,cAAc,GAAG,IAAIkD,GAAG,CAAC,CAAC;MAChC,MAAMI,WAAW,GAAG,IAAIJ,GAAG,CAAC,CAAChC,IAAI,CAAC,CAAC;MAEnC,KAAK,MAAMf,CAAC,IAAImD,WAAW,EAAE;QAC3B,MAAMjF,KAAK,GAAG,MAAML,MAAM,CAACK,KAAK,CAC7B+B,IAAI,CACH;UAAEX,GAAG,EAAE;YAAEY,GAAG,EAAEF,CAAC,CAACP,QAAQ,CAACc,GAAG,CAAEP,CAAC,IAAKA,CAAC,CAACV,GAAG;UAAE;QAAE,CAAC,EAC9C;UAAEsC,MAAM,EAAE;YAAEnC,QAAQ,EAAE;UAAE;QAAE,CAC5B,CAAC,CACAU,UAAU,CAAC,CAAC;QAEf,KAAK,MAAMK,EAAE,IAAItC,KAAK,EAAE;UACtB2B,cAAc,CAACoD,GAAG,CAACzC,EAAE,CAAClB,GAAG,CAAC;UAC1B6D,WAAW,CAACF,GAAG,CAACzC,EAAE,CAAC;QACrB;MACF;MAEA,OAAO,CAAC,GAAGX,cAAc,CAAC;IAC5B,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEuD,yBAAyB,EAAE,eAAAA,CAAgBrB,KAAK,EAAE7D,KAAK,EAAEc,OAAO,EAAE;MAChE,IAAI,CAAC+C,KAAK,EAAE,MAAM,IAAIpC,KAAK,CAAC,wBAAwB,CAAC;MACrD,IAAI,CAACzB,KAAK,EAAE,MAAM,IAAIyB,KAAK,CAAC,wBAAwB,CAAC;MAErDX,OAAO,GAAGX,KAAK,CAAC4D,iBAAiB,CAACjD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACmC,KAAK,CAACC,OAAO,CAACW,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAC1C,IAAI,CAACZ,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CG,KAAK,CAAC6D,eAAe,CAAClD,OAAO,CAACmD,KAAK,CAAC;MAEpC,KAAK,MAAME,IAAI,IAAIN,KAAK,EAAE;QACxB,IAAI,CAACM,IAAI,EAAE;QAEX,KAAK,MAAMtB,IAAI,IAAI7C,KAAK,EAAE;UACxB,IAAI8D,EAAE;UACN,IAAI,OAAOK,IAAI,KAAK,QAAQ,EAAE;YAC5BL,EAAE,GAAGK,IAAI,CAAC/C,GAAG;UACf,CAAC,MAAM;YACL0C,EAAE,GAAGK,IAAI;UACX;UAEA,MAAMhE,KAAK,CAACgF,wBAAwB,CAACrB,EAAE,EAAEjB,IAAI,EAAE/B,OAAO,CAAC;QACzD;MACF;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEqE,wBAAwB,EAAE,eAAAA,CAAgBV,MAAM,EAAE5D,QAAQ,EAAEC,OAAO,EAAE;MACnEX,KAAK,CAACY,cAAc,CAACF,QAAQ,CAAC;MAC9BV,KAAK,CAAC6D,eAAe,CAAClD,OAAO,CAACmD,KAAK,CAAC;MAEpC,IAAI,CAACQ,MAAM,EAAE;MAEb,MAAMF,QAAQ,GAAG;QACf,UAAU,EAAEE,MAAM;QAClB,UAAU,EAAE5D;MACd,CAAC;MAED,IAAI,CAACC,OAAO,CAACwD,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAGnD,OAAO,CAACmD,KAAK;MAChC;MAEA,MAAMtE,MAAM,CAACO,cAAc,CAAC0B,WAAW,CAAC2C,QAAQ,CAAC;IACnD,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEa,iBAAiB,EAAE,eAAAA,CAAgBjB,IAAI,EAAEnE,KAAK,EAAEc,OAAO,EAAE;MACvD,IAAIgD,EAAE;MAENhD,OAAO,GAAGX,KAAK,CAAC4D,iBAAiB,CAACjD,OAAO,CAAC;;MAE1C;MACA,IAAI,CAACmC,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CA,KAAK,GAAGA,KAAK,CAACqF,MAAM,CAAEvD,CAAC,IAAKA,CAAC,IAAI,IAAI,CAAC;MAEtC,IAAI,CAAC9B,KAAK,CAACwC,MAAM,EAAE,OAAO,KAAK;MAE/BrC,KAAK,CAAC6D,eAAe,CAAClD,OAAO,CAACmD,KAAK,CAAC;MAEpCnD,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;QACE4D,QAAQ,EAAE;MACZ,CAAC,EACDxD,OACF,CAAC;MAED,IAAIqD,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAC/C,GAAG;MACf,CAAC,MAAM;QACL0C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,KAAK;MACrB,IAAI,OAAOA,EAAE,KAAK,QAAQ,EAAE,OAAO,KAAK;MAExC,MAAMS,QAAQ,GAAG;QACf,UAAU,EAAET;MACd,CAAC;MAED,IAAI,CAAChD,OAAO,CAACwD,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAEjC,GAAG,EAAE,CAAClB,OAAO,CAACmD,KAAK,EAAE,IAAI;QAAE,CAAC;MACjD;MAEA,MAAMU,GAAG,GAAG,MAAMtE,SAAS,CAACL,KAAK,EAAE,MAAOa,QAAQ,IAAK;QACrD0D,QAAQ,CAAC,oBAAoB,CAAC,GAAG1D,QAAQ;QACzC,MAAMyE,GAAG,GACP,CAAC,MAAM3F,MAAM,CAACO,cAAc,CACzB6B,IAAI,CAACwC,QAAQ,EAAE;UAAEgB,KAAK,EAAE;QAAE,CAAC,CAAC,CAC5BC,UAAU,CAAC,CAAC,IAAI,CAAC;QACtB,OAAOF,GAAG;MACZ,CAAC,CAAC;MAEF,OAAOX,GAAG;IACZ,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEc,oBAAoB,EAAE,eAAAA,CAAgBtB,IAAI,EAAErD,OAAO,EAAE;MACnD,IAAIgD,EAAE;MAENhD,OAAO,GAAGX,KAAK,CAAC4D,iBAAiB,CAACjD,OAAO,CAAC;MAE1CX,KAAK,CAAC6D,eAAe,CAAClD,OAAO,CAACmD,KAAK,CAAC;MAEpCnD,OAAO,GAAGL,MAAM,CAACC,MAAM,CAAC;QACtBgF,WAAW,EAAE,KAAK;QAClBC,YAAY,EAAE,KAAK;QACnBrB,QAAQ,EAAE,KAAK;QACfsB,UAAU,EAAE;MACd,CAAC,EAAE9E,OAAO,CAAC;MAEX,IAAIqD,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAC/C,GAAG;MACf,CAAC,MAAM;QACL0C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,EAAE;MAElB,MAAMS,QAAQ,GAAG;QACf,UAAU,EAAET;MACd,CAAC;MAED,MAAMuB,MAAM,GAAG;QACb3B,MAAM,EAAE;UAAE,oBAAoB,EAAE;QAAE;MACpC,CAAC;MAED,IAAI,CAAC5C,OAAO,CAACwD,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAEjC,GAAG,EAAE,CAAClB,OAAO,CAACmD,KAAK;QAAE,CAAC;QAEzC,IAAI,CAACnD,OAAO,CAAC8E,UAAU,EAAE;UACvBrB,QAAQ,CAACN,KAAK,CAACjC,GAAG,CAAC6D,IAAI,CAAC,IAAI,CAAC;QAC/B;MACF;MAEA,IAAI/E,OAAO,CAAC6E,YAAY,EAAE;QACxB,OAAON,MAAM,CAAC3B,MAAM,CAAC,oBAAoB,CAAC;QAC1C2B,MAAM,CAAC3B,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;MAC/B;MAEA,IAAI5C,OAAO,CAAC4E,WAAW,EAAE;QACvB,OAAOL,MAAM,CAAC3B,MAAM;MACtB;MAEA,MAAM1D,KAAK,GAAG,MAAML,MAAM,CAACO,cAAc,CAAC6B,IAAI,CAACwC,QAAQ,EAAEc,MAAM,CAAC,CAACpD,UAAU,CAAC,CAAC;MAE7E,IAAInB,OAAO,CAAC4E,WAAW,EAAE;QACvB,OAAO1F,KAAK;MACd;MAEA,OAAO,CACL,GAAG,IAAI6E,GAAG,CACR7E,KAAK,CAAC8F,MAAM,CAAC,CAACC,GAAG,EAAEC,OAAO,KAAK;QAC7B,IAAIA,OAAO,CAACrE,cAAc,EAAE;UAC1B,OAAOoE,GAAG,CAACE,MAAM,CAACD,OAAO,CAACrE,cAAc,CAACU,GAAG,CAAEP,CAAC,IAAKA,CAAC,CAACV,GAAG,CAAC,CAAC;QAC7D,CAAC,MAAM,IAAI4E,OAAO,CAACnD,IAAI,EAAE;UACvBkD,GAAG,CAACF,IAAI,CAACG,OAAO,CAACnD,IAAI,CAACzB,GAAG,CAAC;QAC5B;QACA,OAAO2E,GAAG;MACZ,CAAC,EAAE,EAAE,CACP,CAAC,CACF;IACH,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEG,WAAW,EAAE,SAAAA,CAAUC,YAAY,EAAE;MACnCA,YAAY,GAAGA,YAAY,IAAI;QAAEC,IAAI,EAAE;UAAEhF,GAAG,EAAE;QAAE;MAAE,CAAC;MAEnD,OAAOzB,MAAM,CAACK,KAAK,CAAC+B,IAAI,CAAC,CAAC,CAAC,EAAEoE,YAAY,CAAC;IAC5C,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,mBAAmB,EAAE,eAAAA,CAAgBrG,KAAK,EAAEc,OAAO,EAAEqF,YAAY,EAAE;MACjE,MAAMG,GAAG,GAAG,CACV,MAAMnG,KAAK,CAACoG,yBAAyB,CAACvG,KAAK,EAAEc,OAAO,CAAC,CAACmB,UAAU,CAAC,CAAC,EAClEI,GAAG,CAAEmE,CAAC,IAAKA,CAAC,CAACrC,IAAI,CAAC/C,GAAG,CAAC;MAExB,OAAOzB,MAAM,CAACkE,KAAK,CAAC9B,IAAI,CACtB;QAAEX,GAAG,EAAE;UAAEY,GAAG,EAAEsE;QAAI;MAAE,CAAC,EACpBxF,OAAO,IAAIA,OAAO,CAACqF,YAAY,IAAKA,YAAY,IAAI,CAAC,CACxD,CAAC;IACH,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAEEI,yBAAyB,EAAE,SAAAA,CAAUvG,KAAK,EAAEc,OAAO,EAAE;MACnDA,OAAO,GAAGX,KAAK,CAAC4D,iBAAiB,CAACjD,OAAO,CAAC;MAE1CA,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;QACE4D,QAAQ,EAAE,KAAK;QACf6B,YAAY,EAAE,CAAC;MACjB,CAAC,EACDrF,OACF,CAAC;MAED,OAAOX,KAAK,CAACsG,qBAAqB,CAACzG,KAAK,EAAEc,OAAO,EAAEA,OAAO,CAACqF,YAAY,CAAC;IAC1E,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEM,qBAAqB,EAAE,SAAAA,CAAUzG,KAAK,EAAEc,OAAO,EAAEuE,MAAM,EAAE;MACvDvE,OAAO,GAAGX,KAAK,CAAC4D,iBAAiB,CAACjD,OAAO,CAAC;MAE1CA,OAAO,GAAGL,MAAM,CAACC,MAAM,CACrB;QACE4D,QAAQ,EAAE,KAAK;QACfsB,UAAU,EAAE;MACd,CAAC,EACD9E,OACF,CAAC;;MAED;MACA,IAAI,CAACmC,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAE1CG,KAAK,CAAC6D,eAAe,CAAClD,OAAO,CAACmD,KAAK,CAAC;MAEpCoB,MAAM,GAAG5E,MAAM,CAACC,MAAM,CACpB;QACEgD,MAAM,EAAE;UAAE,UAAU,EAAE;QAAE;MAC1B,CAAC,EACD2B,MACF,CAAC;MAED,MAAMd,QAAQ,GAAG;QACf,oBAAoB,EAAE;UAAEvC,GAAG,EAAEhC;QAAM;MACrC,CAAC;MAED,IAAI,CAACc,OAAO,CAACwD,QAAQ,EAAE;QACrBC,QAAQ,CAACN,KAAK,GAAG;UAAEjC,GAAG,EAAE,CAAClB,OAAO,CAACmD,KAAK;QAAE,CAAC;QAEzC,IAAI,CAACnD,OAAO,CAAC8E,UAAU,EAAE;UACvBrB,QAAQ,CAACN,KAAK,CAACjC,GAAG,CAAC6D,IAAI,CAAC,IAAI,CAAC;QAC/B;MACF;MAEA,OAAOlG,MAAM,CAACO,cAAc,CAAC6B,IAAI,CAACwC,QAAQ,EAAEc,MAAM,CAAC;IACrD,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACEqB,qBAAqB,EAAE,eAAAA,CAAA,EAAyB;MAC9C,IAAI,CAACtG,kCAAkC,EAAE;QACvCA,kCAAkC,GAAG,IAAI;QACzCuG,OAAO,IACLA,OAAO,CAACC,IAAI,CACV,qEACF,CAAC;MACL;MAEA,OAAO,MAAMzG,KAAK,CAAC0G,gBAAgB,CAAC,GAAAC,SAAO,CAAC;IAC9C,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,qBAAqB,EAAE,eAAAA,CAAgB5C,IAAI,EAAEnE,KAAK,EAAE;MAClD,IAAI8D,EAAE;MAEN,IAAI9D,KAAK,IAAI,CAACiD,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;MAEnD,IAAImE,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QACpCL,EAAE,GAAGK,IAAI,CAAC/C,GAAG;MACf,CAAC,MAAM;QACL0C,EAAE,GAAGK,IAAI;MACX;MAEA,IAAI,CAACL,EAAE,EAAE,OAAO,EAAE;MAElB,MAAMS,QAAQ,GAAG;QACf,UAAU,EAAET,EAAE;QACdG,KAAK,EAAE;UAAEZ,GAAG,EAAE;QAAK;MACrB,CAAC;MAED,IAAIrD,KAAK,EAAE;QACTuE,QAAQ,CAAC,oBAAoB,CAAC,GAAG;UAAEvC,GAAG,EAAEhC;QAAM,CAAC;MACjD;MAEA,MAAMgH,MAAM,GAAG,CACb,MAAMrH,MAAM,CAACO,cAAc,CACxB6B,IAAI,CAACwC,QAAQ,EAAE;QAAEb,MAAM,EAAE;UAAEO,KAAK,EAAE;QAAE;MAAE,CAAC,CAAC,CACxChC,UAAU,CAAC,CAAC,EACfI,GAAG,CAAE4E,GAAG,IAAKA,GAAG,CAAChD,KAAK,CAAC;MAEzB,OAAO,CAAC,GAAG,IAAIY,GAAG,CAACmC,MAAM,CAAC,CAAC;IAC7B,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEE,gBAAgB,EAAE,eAAAA,CAAgBxE,OAAO,EAAEC,OAAO,EAAE;MAClD,IAAIC,KAAK;MAETzC,KAAK,CAAC6D,eAAe,CAACtB,OAAO,CAAC;MAC9BvC,KAAK,CAAC6D,eAAe,CAACrB,OAAO,CAAC;MAE9B,IAAID,OAAO,KAAKC,OAAO,EAAE;MAEzB,GAAG;QACDC,KAAK,GAAG,MAAMjD,MAAM,CAACO,cAAc,CAACmB,WAAW,CAC7C;UACE4C,KAAK,EAAEvB;QACT,CAAC,EACD;UACEN,IAAI,EAAE;YACJ6B,KAAK,EAAEtB;UACT;QACF,CAAC,EACD;UAAEJ,KAAK,EAAE;QAAK,CAChB,CAAC;MACH,CAAC,QAAQK,KAAK,GAAG,CAAC;IACpB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEuE,gBAAgB,EAAE,eAAAA,CAAgBC,IAAI,EAAE;MACtCjH,KAAK,CAAC6D,eAAe,CAACoD,IAAI,CAAC;MAE3B,MAAMzH,MAAM,CAACO,cAAc,CAAC0B,WAAW,CAAC;QAAEqC,KAAK,EAAEmD;MAAK,CAAC,CAAC;IAC1D,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACErG,cAAc,EAAE,SAAAA,CAAUF,QAAQ,EAAE;MAClC,IACE,CAACA,QAAQ,IACT,OAAOA,QAAQ,KAAK,QAAQ,IAC5BA,QAAQ,CAACwG,IAAI,CAAC,CAAC,KAAKxG,QAAQ,EAC5B;QACA,MAAM,IAAIY,KAAK,CAAC,qBAAqB,GAAGZ,QAAQ,GAAG,IAAI,CAAC;MAC1D;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEyG,eAAe,EAAE,eAAAA,CAAgBC,cAAc,EAAEC,aAAa,EAAE;MAC9D,IAAID,cAAc,KAAKC,aAAa,EAAE;QACpC,OAAO,IAAI;MACb;MAEA,IAAID,cAAc,IAAI,IAAI,IAAIC,aAAa,IAAI,IAAI,EAAE;QACnD,OAAO,KAAK;MACd;MAEArH,KAAK,CAACY,cAAc,CAACwG,cAAc,CAAC;MACpCpH,KAAK,CAACY,cAAc,CAACyG,aAAa,CAAC;MAEnC,IAAIC,YAAY,GAAG,CAACF,cAAc,CAAC;MACnC,OAAOE,YAAY,CAACjF,MAAM,KAAK,CAAC,EAAE;QAChC,MAAM3B,QAAQ,GAAG4G,YAAY,CAACC,GAAG,CAAC,CAAC;QAEnC,IAAI7G,QAAQ,KAAK2G,aAAa,EAAE;UAC9B,OAAO,IAAI;QACb;QAEA,MAAM3E,IAAI,GAAG,MAAMlD,MAAM,CAACK,KAAK,CAACmB,YAAY,CAAC;UAAEC,GAAG,EAAEP;QAAS,CAAC,CAAC;;QAE/D;QACA,IAAI,CAACgC,IAAI,EAAE;QAEX4E,YAAY,GAAGA,YAAY,CAACxB,MAAM,CAACpD,IAAI,CAACtB,QAAQ,CAACc,GAAG,CAAEP,CAAC,IAAKA,CAAC,CAACV,GAAG,CAAC,CAAC;MACrE;MAEA,OAAO,KAAK;IACd,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE2C,iBAAiB,EAAE,SAAAA,CAAUjD,OAAO,EAAE;MACpCA,OAAO,GAAGA,OAAO,KAAK6G,SAAS,GAAG,CAAC,CAAC,GAAG7G,OAAO;MAE9C,IAAIA,OAAO,KAAK,IAAI,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QACnDA,OAAO,GAAG;UAAEmD,KAAK,EAAEnD;QAAQ,CAAC;MAC9B;MAEAA,OAAO,CAACmD,KAAK,GAAG9D,KAAK,CAACyH,mBAAmB,CAAC9G,OAAO,CAACmD,KAAK,CAAC;MAExD,OAAOnD,OAAO;IAChB,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE8G,mBAAmB,EAAE,SAAAA,CAAUC,SAAS,EAAE;MACxC;MACA,IAAIA,SAAS,IAAI,IAAI,EAAE;QACrB,OAAO,IAAI;MACb,CAAC,MAAM;QACL,OAAOA,SAAS;MAClB;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE7D,eAAe,EAAE,SAAAA,CAAU6D,SAAS,EAAE;MACpC,IAAIA,SAAS,KAAK,IAAI,EAAE;MAExB,IACE,CAACA,SAAS,IACV,OAAOA,SAAS,KAAK,QAAQ,IAC7BA,SAAS,CAACR,IAAI,CAAC,CAAC,KAAKQ,SAAS,EAC9B;QACA,MAAM,IAAIpG,KAAK,CAAC,sBAAsB,GAAGoG,SAAS,GAAG,IAAI,CAAC;MAC5D;IACF;EACF,CAAC,CAAC;AAAA,EAAAC,IAAA,OAAAC,MAAA"},"sourceType":"module","externalDependencies":{},"hash":"76f87021c5d9404d3208d0143c2b491795a3ccd3"}
